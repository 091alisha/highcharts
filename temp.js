var s = "/**\n * @license Highmaps JS v2.0-dev (2016-01-13)\n * Highmaps as a plugin for Highcharts 4.1.x or Highstock 2.1.x (x being the patch version of this file)\n *\n * (c) 2011-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n/* eslint indent: 0 */\n\n(function (H) {\n        var Axis = H.Axis,\n            each = H.each,\n            pick = H.pick,\n            wrap = H.wrap;\n    /**\n     * Override to use the extreme coordinates from the SVG shape, not the\n     * data values\n     */\n    wrap(Axis.prototype, 'getSeriesExtremes', function (proceed) {\n        var isXAxis = this.isXAxis,\n            dataMin,\n            dataMax,\n            xData = [],\n            useMapGeometry;\n\n        // Remove the xData array and cache it locally so that the proceed method doesn't use it\n        if (isXAxis) {\n            each(this.series, function (series, i) {\n                if (series.useMapGeometry) {\n                    xData[i] = series.xData;\n                    series.xData = [];\n                }\n            });\n        }\n\n        // Call base to reach normal cartesian series (like mappoint)\n        proceed.call(this);\n\n        // Run extremes logic for map and mapline\n        if (isXAxis) {\n            dataMin = pick(this.dataMin, Number.MAX_VALUE);\n            dataMax = pick(this.dataMax, -Number.MAX_VALUE);\n            each(this.series, function (series, i) {\n                if (series.useMapGeometry) {\n                    dataMin = Math.min(dataMin, pick(series.minX, dataMin));\n                    dataMax = Math.max(dataMax, pick(series.maxX, dataMin));\n                    series.xData = xData[i]; // Reset xData array\n                    useMapGeometry = true;\n                }\n            });\n            if (useMapGeometry) {\n                this.dataMin = dataMin;\n                this.dataMax = dataMax;\n            }\n        }\n    });\n\n    /**\n     * Override axis translation to make sure the aspect ratio is always kept\n     */\n    wrap(Axis.prototype, 'setAxisTranslation', function (proceed) {\n        var chart = this.chart,\n            mapRatio,\n            plotRatio = chart.plotWidth / chart.plotHeight,\n            adjustedAxisLength,\n            xAxis = chart.xAxis[0],\n            padAxis,\n            fixTo,\n            fixDiff,\n            preserveAspectRatio;\n\n\n        // Run the parent method\n        proceed.call(this);\n\n        // Check for map-like series\n        if (this.coll === 'yAxis' && xAxis.transA !== undefined) {\n            each(this.series, function (series) {\n                if (series.preserveAspectRatio) {\n                    preserveAspectRatio = true;\n                }\n            });\n        }\n\n        // On Y axis, handle both\n        if (preserveAspectRatio) {\n\n            // Use the same translation for both axes\n            this.transA = xAxis.transA = Math.min(this.transA, xAxis.transA);\n\n            mapRatio = plotRatio / ((xAxis.max - xAxis.min) / (this.max - this.min));\n\n            // What axis to pad to put the map in the middle\n            padAxis = mapRatio < 1 ? this : xAxis;\n\n            // Pad it\n            adjustedAxisLength = (padAxis.max - padAxis.min) * padAxis.transA;\n            padAxis.pixelPadding = padAxis.len - adjustedAxisLength;\n            padAxis.minPixelPadding = padAxis.pixelPadding / 2;\n\n            fixTo = padAxis.fixTo;\n            if (fixTo) {\n                fixDiff = fixTo[1] - padAxis.toValue(fixTo[0], true);\n                fixDiff *= padAxis.transA;\n                if (Math.abs(fixDiff) > padAxis.minPixelPadding || (padAxis.min === padAxis.dataMin && padAxis.max === padAxis.dataMax)) { // zooming out again, keep within restricted area\n                    fixDiff = 0;\n                }\n                padAxis.minPixelPadding -= fixDiff;\n            }\n        }\n    });\n\n    /**\n     * Override Axis.render in order to delete the fixTo prop\n     */\n    wrap(Axis.prototype, 'render', function (proceed) {\n        proceed.call(this);\n        this.fixTo = null;\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Axis = H.Axis,\n            Chart = H.Chart,\n            Color = H.Color,\n            ColorAxis,\n            each = H.each,\n            extend = H.extend,\n            Legend = H.Legend,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            noop = H.noop,\n            merge = H.merge,\n            pick = H.pick,\n            wrap = H.wrap;\n\n    /**\n     * The ColorAxis object for inclusion in gradient legends\n     */\n    ColorAxis = H.ColorAxis = function () {\n        this.isColorAxis = true;\n        this.init.apply(this, arguments);\n    };\n    extend(ColorAxis.prototype, Axis.prototype);\n    extend(ColorAxis.prototype, {\n        defaultColorAxisOptions: {\n            lineWidth: 0,\n            minPadding: 0,\n            maxPadding: 0,\n            gridLineWidth: 1,\n            tickPixelInterval: 72,\n            startOnTick: true,\n            endOnTick: true,\n            offset: 0,\n            marker: {\n                animation: {\n                    duration: 50\n                },\n                color: 'gray',\n                width: 0.01\n            },\n            labels: {\n                overflow: 'justify'\n            },\n            minColor: '#EFEFFF',\n            maxColor: '#003875',\n            tickLength: 5\n        },\n        init: function (chart, userOptions) {\n            var horiz = chart.options.legend.layout !== 'vertical',\n                options;\n\n            // Build the options\n            options = merge(this.defaultColorAxisOptions, {\n                side: horiz ? 2 : 1,\n                reversed: !horiz\n            }, userOptions, {\n                opposite: !horiz,\n                showEmpty: false,\n                title: null,\n                isColor: true\n            });\n\n            Axis.prototype.init.call(this, chart, options);\n\n            // Base init() pushes it to the xAxis array, now pop it again\n            //chart[this.isXAxis ? 'xAxis' : 'yAxis'].pop();\n\n            // Prepare data classes\n            if (userOptions.dataClasses) {\n                this.initDataClasses(userOptions);\n            }\n            this.initStops(userOptions);\n\n            // Override original axis properties\n            this.horiz = horiz;\n            this.zoomEnabled = false;\n        },\n\n        /*\n         * Return an intermediate color between two colors, according to pos where 0\n         * is the from color and 1 is the to color.\n         * NOTE: Changes here should be copied\n         * to the same function in drilldown.src.js and solid-gauge-src.js.\n         */\n        tweenColors: function (from, to, pos) {\n            // Check for has alpha, because rgba colors perform worse due to lack of\n            // support in WebKit.\n            var hasAlpha,\n                ret;\n\n            // Unsupported color, return to-color (#3920)\n            if (!to.rgba.length || !from.rgba.length) {\n                ret = to.input || 'none';\n\n            // Interpolate\n            } else {\n                from = from.rgba;\n                to = to.rgba;\n                hasAlpha = (to[3] !== 1 || from[3] !== 1);\n                ret = (hasAlpha ? 'rgba(' : 'rgb(') +\n                    Math.round(to[0] + (from[0] - to[0]) * (1 - pos)) + ',' +\n                    Math.round(to[1] + (from[1] - to[1]) * (1 - pos)) + ',' +\n                    Math.round(to[2] + (from[2] - to[2]) * (1 - pos)) +\n                    (hasAlpha ? (',' + (to[3] + (from[3] - to[3]) * (1 - pos))) : '') + ')';\n            }\n            return ret;\n        },\n\n        initDataClasses: function (userOptions) {\n            var axis = this,\n                chart = this.chart,\n                dataClasses,\n                colorCounter = 0,\n                options = this.options,\n                len = userOptions.dataClasses.length;\n            this.dataClasses = dataClasses = [];\n            this.legendItems = [];\n\n            each(userOptions.dataClasses, function (dataClass, i) {\n                var colors;\n\n                dataClass = merge(dataClass);\n                dataClasses.push(dataClass);\n                if (!dataClass.color) {\n                    if (options.dataClassColor === 'category') {\n                        colors = chart.options.colors;\n                        dataClass.color = colors[colorCounter++];\n                        // loop back to zero\n                        if (colorCounter === colors.length) {\n                            colorCounter = 0;\n                        }\n                    } else {\n                        dataClass.color = axis.tweenColors(\n                            Color(options.minColor),\n                            Color(options.maxColor),\n                            len < 2 ? 0.5 : i / (len - 1) // #3219\n                        );\n                    }\n                }\n            });\n        },\n\n        initStops: function (userOptions) {\n            this.stops = userOptions.stops || [\n                [0, this.options.minColor],\n                [1, this.options.maxColor]\n            ];\n            each(this.stops, function (stop) {\n                stop.color = Color(stop[1]);\n            });\n        },\n\n        /**\n         * Extend the setOptions method to process extreme colors and color\n         * stops.\n         */\n        setOptions: function (userOptions) {\n            Axis.prototype.setOptions.call(this, userOptions);\n\n            this.options.crosshair = this.options.marker;\n            this.coll = 'colorAxis';\n        },\n\n        setAxisSize: function () {\n            var symbol = this.legendSymbol,\n                chart = this.chart,\n                x,\n                y,\n                width,\n                height;\n\n            if (symbol) {\n                this.left = x = symbol.attr('x');\n                this.top = y = symbol.attr('y');\n                this.width = width = symbol.attr('width');\n                this.height = height = symbol.attr('height');\n                this.right = chart.chartWidth - x - width;\n                this.bottom = chart.chartHeight - y - height;\n\n                this.len = this.horiz ? width : height;\n                this.pos = this.horiz ? x : y;\n            }\n        },\n\n        /**\n         * Translate from a value to a color\n         */\n        toColor: function (value, point) {\n            var pos,\n                stops = this.stops,\n                from,\n                to,\n                color,\n                dataClasses = this.dataClasses,\n                dataClass,\n                i;\n\n            if (dataClasses) {\n                i = dataClasses.length;\n                while (i--) {\n                    dataClass = dataClasses[i];\n                    from = dataClass.from;\n                    to = dataClass.to;\n                    if ((from === undefined || value >= from) && (to === undefined || value <= to)) {\n                        color = dataClass.color;\n                        if (point) {\n                            point.dataClass = i;\n                        }\n                        break;\n                    }\n                }\n\n            } else {\n\n                if (this.isLog) {\n                    value = this.val2lin(value);\n                }\n                pos = 1 - ((this.max - value) / ((this.max - this.min) || 1));\n                i = stops.length;\n                while (i--) {\n                    if (pos > stops[i][0]) {\n                        break;\n                    }\n                }\n                from = stops[i] || stops[i + 1];\n                to = stops[i + 1] || from;\n\n                // The position within the gradient\n                pos = 1 - (to[0] - pos) / ((to[0] - from[0]) || 1);\n\n                color = this.tweenColors(\n                    from.color,\n                    to.color,\n                    pos\n                );\n            }\n            return color;\n        },\n\n        /**\n         * Override the getOffset method to add the whole axis groups inside the legend.\n         */\n        getOffset: function () {\n            var group = this.legendGroup,\n                sideOffset = this.chart.axisOffset[this.side];\n\n            if (group) {\n\n                // Hook for the getOffset method to add groups to this parent group\n                this.axisParent = group;\n\n                // Call the base\n                Axis.prototype.getOffset.call(this);\n\n                // First time only\n                if (!this.added) {\n\n                    this.added = true;\n\n                    this.labelLeft = 0;\n                    this.labelRight = this.width;\n                }\n                // Reset it to avoid color axis reserving space\n                this.chart.axisOffset[this.side] = sideOffset;\n            }\n        },\n\n        /**\n         * Create the color gradient\n         */\n        setLegendColor: function () {\n            var grad,\n                horiz = this.horiz,\n                options = this.options,\n                reversed = this.reversed,\n                one = reversed ? 1 : 0,\n                zero = reversed ? 0 : 1;\n\n            grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one]; // #3190\n            this.legendColor = {\n                linearGradient: { x1: grad[0], y1: grad[1], x2: grad[2], y2: grad[3] },\n                stops: options.stops || [\n                    [0, options.minColor],\n                    [1, options.maxColor]\n                ]\n            };\n        },\n\n        /**\n         * The color axis appears inside the legend and has its own legend symbol\n         */\n        drawLegendSymbol: function (legend, item) {\n            var padding = legend.padding,\n                legendOptions = legend.options,\n                horiz = this.horiz,\n                width = pick(legendOptions.symbolWidth, horiz ? 200 : 12),\n                height = pick(legendOptions.symbolHeight, horiz ? 12 : 200),\n                labelPadding = pick(legendOptions.labelPadding, horiz ? 16 : 30),\n                itemDistance = pick(legendOptions.itemDistance, 10);\n\n            this.setLegendColor();\n\n            // Create the gradient\n            item.legendSymbol = this.chart.renderer.rect(\n                0,\n                legend.baseline - 11,\n                width,\n                height\n            ).attr({\n                zIndex: 1\n            }).add(item.legendGroup);\n\n            // Set how much space this legend item takes up\n            this.legendItemWidth = width + padding + (horiz ? itemDistance : labelPadding);\n            this.legendItemHeight = height + padding + (horiz ? labelPadding : 0);\n        },\n        /**\n         * Fool the legend\n         */\n        setState: noop,\n        visible: true,\n        setVisible: noop,\n        getSeriesExtremes: function () {\n            var series;\n            if (this.series.length) {\n                series = this.series[0];\n                this.dataMin = series.valueMin;\n                this.dataMax = series.valueMax;\n            }\n        },\n        drawCrosshair: function (e, point) {\n            var plotX = point && point.plotX,\n                plotY = point && point.plotY,\n                crossPos,\n                axisPos = this.pos,\n                axisLen = this.len;\n\n            if (point) {\n                crossPos = this.toPixels(point[point.series.colorKey]);\n                if (crossPos < axisPos) {\n                    crossPos = axisPos - 2;\n                } else if (crossPos > axisPos + axisLen) {\n                    crossPos = axisPos + axisLen + 2;\n                }\n\n                point.plotX = crossPos;\n                point.plotY = this.len - crossPos;\n                Axis.prototype.drawCrosshair.call(this, e, point);\n                point.plotX = plotX;\n                point.plotY = plotY;\n\n                if (this.cross) {\n                    this.cross\n                        .attr({\n                            fill: this.crosshair.color\n                        })\n                        .add(this.legendGroup);\n                }\n            }\n        },\n        getPlotLinePath: function (a, b, c, d, pos) {\n            return typeof pos === 'number' ? // crosshairs only // #3969 pos can be 0 !!\n                (this.horiz ?\n                    ['M', pos - 4, this.top - 6, 'L', pos + 4, this.top - 6, pos, this.top, 'Z'] :\n                    ['M', this.left, pos, 'L', this.left - 6, pos + 6, this.left - 6, pos - 6, 'Z']\n                ) :\n                Axis.prototype.getPlotLinePath.call(this, a, b, c, d);\n        },\n\n        update: function (newOptions, redraw) {\n            var chart = this.chart,\n                legend = chart.legend;\n\n            each(this.series, function (series) {\n                series.isDirtyData = true; // Needed for Axis.update when choropleth colors change\n            });\n\n            // When updating data classes, destroy old items and make sure new ones are created (#3207)\n            if (newOptions.dataClasses && legend.allItems) {\n                each(legend.allItems, function (item) {\n                    if (item.isDataClass) {\n                        item.legendGroup.destroy();\n                    }\n                });\n                chart.isDirtyLegend = true;\n            }\n\n            // Keep the options structure updated for export. Unlike xAxis and yAxis, the colorAxis is\n            // not an array. (#3207)\n            chart.options[this.coll] = merge(this.userOptions, newOptions);\n\n            Axis.prototype.update.call(this, newOptions, redraw);\n            if (this.legendItem) {\n                this.setLegendColor();\n                legend.colorizeItem(this, true);\n            }\n        },\n\n        /**\n         * Get the legend item symbols for data classes\n         */\n        getDataClassLegendSymbols: function () {\n            var axis = this,\n                chart = this.chart,\n                legendItems = this.legendItems,\n                legendOptions = chart.options.legend,\n                valueDecimals = legendOptions.valueDecimals,\n                valueSuffix = legendOptions.valueSuffix || '',\n                name;\n\n            if (!legendItems.length) {\n                each(this.dataClasses, function (dataClass, i) {\n                    var vis = true,\n                        from = dataClass.from,\n                        to = dataClass.to;\n\n                    // Assemble the default name. This can be overridden by legend.options.labelFormatter\n                    name = '';\n                    if (from === undefined) {\n                        name = '< ';\n                    } else if (to === undefined) {\n                        name = '> ';\n                    }\n                    if (from !== undefined) {\n                        name += H.numberFormat(from, valueDecimals) + valueSuffix;\n                    }\n                    if (from !== undefined && to !== undefined) {\n                        name += ' - ';\n                    }\n                    if (to !== undefined) {\n                        name += H.numberFormat(to, valueDecimals) + valueSuffix;\n                    }\n                    // Add a mock object to the legend items\n                    legendItems.push(extend({\n                        chart: chart,\n                        name: name,\n                        options: {},\n                        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n                        visible: true,\n                        setState: noop,\n                        isDataClass: true,\n                        setVisible: function () {\n                            vis = this.visible = !vis;\n                            each(axis.series, function (series) {\n                                each(series.points, function (point) {\n                                    if (point.dataClass === i) {\n                                        point.setVisible(vis);\n                                    }\n                                });\n                            });\n\n                            chart.legend.colorizeItem(this, vis);\n                        }\n                    }, dataClass));\n                });\n            }\n            return legendItems;\n        },\n        name: '' // Prevents 'undefined' in legend in IE8\n    });\n\n    /**\n     * Handle animation of the color attributes directly\n     */\n    each(['fill', 'stroke'], function (prop) {\n        Highcharts.Fx.prototype[prop + 'Setter'] = function () {\n            this.elem.attr(prop, ColorAxis.prototype.tweenColors(Color(this.start), Color(this.end), this.pos));\n        };\n    });\n\n    /**\n     * Extend the chart getAxes method to also get the color axis\n     */\n    wrap(Chart.prototype, 'getAxes', function (proceed) {\n\n        var options = this.options,\n            colorAxisOptions = options.colorAxis;\n\n        proceed.call(this);\n\n        this.colorAxis = [];\n        if (colorAxisOptions) {\n            new ColorAxis(this, colorAxisOptions); // eslint-disable-line no-new\n        }\n    });\n\n\n    /**\n     * Wrap the legend getAllItems method to add the color axis. This also removes the\n     * axis' own series to prevent them from showing up individually.\n     */\n    wrap(Legend.prototype, 'getAllItems', function (proceed) {\n        var allItems = [],\n            colorAxis = this.chart.colorAxis[0];\n\n        if (colorAxis) {\n\n            // Data classes\n            if (colorAxis.options.dataClasses) {\n                allItems = allItems.concat(colorAxis.getDataClassLegendSymbols());\n            // Gradient legend\n            } else {\n                // Add this axis on top\n                allItems.push(colorAxis);\n            }\n\n            // Don't add the color axis' series\n            each(colorAxis.series, function (series) {\n                series.options.showInLegend = false;\n            });\n        }\n\n        return allItems.concat(proceed.call(this));\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var each = H.each,\n            noop = H.noop,\n            seriesTypes = H.seriesTypes;\n\n    /**\n     * Mixin for maps and heatmaps\n     */\n    H.colorPointMixin = {\n        /**\n         * Set the visibility of a single point\n         */\n        setVisible: function (vis) {\n            var point = this,\n                method = vis ? 'show' : 'hide';\n\n            // Show and hide associated elements\n            each(['graphic', 'dataLabel'], function (key) {\n                if (point[key]) {\n                    point[key][method]();\n                }\n            });\n        }\n    };\n\n    H.colorSeriesMixin = {\n        pointArrayMap: ['value'],\n        axisTypes: ['xAxis', 'yAxis', 'colorAxis'],\n        optionalAxis: 'colorAxis',\n        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n        getSymbol: noop,\n        parallelArrays: ['x', 'y', 'value'],\n        colorKey: 'value',\n\n        pointAttribs: seriesTypes.column.prototype.pointAttribs,\n    \n        /**\n         * In choropleth maps, the color is a result of the value, so this needs translation too\n         */\n        translateColors: function () {\n            var series = this,\n                nullColor = this.options.nullColor,\n                colorAxis = this.colorAxis,\n                colorKey = this.colorKey;\n\n            each(this.data, function (point) {\n                var value = point[colorKey],\n                    color;\n\n                color = point.options.color ||\n                    (value === null ? nullColor : (colorAxis && value !== undefined) ? colorAxis.toColor(value, point) : point.color || series.color);\n\n                if (color) {\n                    point.color = color;\n                }\n            });\n        }\n    };\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            merge = H.merge,\n            pick = H.pick,\n            wrap = H.wrap;\n\n    // Add events to the Chart object itself\n    extend(Chart.prototype, {\n        renderMapNavigation: function () {\n            var chart = this,\n                options = this.options.mapNavigation,\n                buttons = options.buttons,\n                n,\n                button,\n                buttonOptions,\n                attr,\n                states,\n                stopEvent = function (e) {\n                    if (e) {\n                        if (e.preventDefault) {\n                            e.preventDefault();\n                        }\n                        if (e.stopPropagation) {\n                            e.stopPropagation();\n                        }\n                        e.cancelBubble = true;\n                    }\n                },\n                outerHandler = function (e) {\n                    this.handler.call(chart, e);\n                    stopEvent(e); // Stop default click event (#4444)\n                };\n\n            if (pick(options.enableButtons, options.enabled) && !chart.renderer.forExport) {\n                for (n in buttons) {\n                    if (buttons.hasOwnProperty(n)) {\n                        buttonOptions = merge(options.buttonOptions, buttons[n]);\n                        attr = buttonOptions.theme;\n                        attr.style = merge(buttonOptions.theme.style, buttonOptions.style); // #3203\n                        states = attr.states;\n                        button = chart.renderer.button(\n                                buttonOptions.text,\n                                0,\n                                0,\n                                outerHandler,\n                                attr,\n                                states && states.hover,\n                                states && states.select,\n                                0,\n                                n === 'zoomIn' ? 'topbutton' : 'bottombutton'\n                            )\n                            .attr({\n                                width: buttonOptions.width,\n                                height: buttonOptions.height,\n                                title: chart.options.lang[n],\n                                zIndex: 5\n                            })\n                            .add();\n                        button.handler = buttonOptions.onclick;\n                        button.align(extend(buttonOptions, { width: button.width, height: 2 * button.height }), null, buttonOptions.alignTo);\n                        addEvent(button.element, 'dblclick', stopEvent); // Stop double click event (#4444)\n                    }\n                }\n            }\n        },\n\n        /**\n         * Fit an inner box to an outer. If the inner box overflows left or right, align it to the sides of the\n         * outer. If it overflows both sides, fit it within the outer. This is a pattern that occurs more places\n         * in Highcharts, perhaps it should be elevated to a common utility function.\n         */\n        fitToBox: function (inner, outer) {\n            each([['x', 'width'], ['y', 'height']], function (dim) {\n                var pos = dim[0],\n                    size = dim[1];\n\n                if (inner[pos] + inner[size] > outer[pos] + outer[size]) { // right overflow\n                    if (inner[size] > outer[size]) { // the general size is greater, fit fully to outer\n                        inner[size] = outer[size];\n                        inner[pos] = outer[pos];\n                    } else { // align right\n                        inner[pos] = outer[pos] + outer[size] - inner[size];\n                    }\n                }\n                if (inner[size] > outer[size]) {\n                    inner[size] = outer[size];\n                }\n                if (inner[pos] < outer[pos]) {\n                    inner[pos] = outer[pos];\n                }\n            });\n\n\n            return inner;\n        },\n\n        /**\n         * Zoom the map in or out by a certain amount. Less than 1 zooms in, greater than 1 zooms out.\n         */\n        mapZoom: function (howMuch, centerXArg, centerYArg, mouseX, mouseY) {\n            /*if (this.isMapZooming) {\n                this.mapZoomQueue = arguments;\n                return;\n            }*/\n\n            var chart = this,\n                xAxis = chart.xAxis[0],\n                xRange = xAxis.max - xAxis.min,\n                centerX = pick(centerXArg, xAxis.min + xRange / 2),\n                newXRange = xRange * howMuch,\n                yAxis = chart.yAxis[0],\n                yRange = yAxis.max - yAxis.min,\n                centerY = pick(centerYArg, yAxis.min + yRange / 2),\n                newYRange = yRange * howMuch,\n                fixToX = mouseX ? ((mouseX - xAxis.pos) / xAxis.len) : 0.5,\n                fixToY = mouseY ? ((mouseY - yAxis.pos) / yAxis.len) : 0.5,\n                newXMin = centerX - newXRange * fixToX,\n                newYMin = centerY - newYRange * fixToY,\n                newExt = chart.fitToBox({\n                    x: newXMin,\n                    y: newYMin,\n                    width: newXRange,\n                    height: newYRange\n                }, {\n                    x: xAxis.dataMin,\n                    y: yAxis.dataMin,\n                    width: xAxis.dataMax - xAxis.dataMin,\n                    height: yAxis.dataMax - yAxis.dataMin\n                });\n\n            // When mousewheel zooming, fix the point under the mouse\n            if (mouseX) {\n                xAxis.fixTo = [mouseX - xAxis.pos, centerXArg];\n            }\n            if (mouseY) {\n                yAxis.fixTo = [mouseY - yAxis.pos, centerYArg];\n            }\n\n            // Zoom\n            if (howMuch !== undefined) {\n                xAxis.setExtremes(newExt.x, newExt.x + newExt.width, false);\n                yAxis.setExtremes(newExt.y, newExt.y + newExt.height, false);\n\n            // Reset zoom\n            } else {\n                xAxis.setExtremes(undefined, undefined, false);\n                yAxis.setExtremes(undefined, undefined, false);\n            }\n\n            // Prevent zooming until this one is finished animating\n            /*chart.holdMapZoom = true;\n            setTimeout(function () {\n                chart.holdMapZoom = false;\n            }, 200);*/\n            /*delay = animation ? animation.duration || 500 : 0;\n            if (delay) {\n                chart.isMapZooming = true;\n                setTimeout(function () {\n                    chart.isMapZooming = false;\n                    if (chart.mapZoomQueue) {\n                        chart.mapZoom.apply(chart, chart.mapZoomQueue);\n                    }\n                    chart.mapZoomQueue = null;\n                }, delay);\n            }*/\n\n            chart.redraw();\n        }\n    });\n\n    /**\n     * Extend the Chart.render method to add zooming and panning\n     */\n    wrap(Chart.prototype, 'render', function (proceed) {\n        var chart = this,\n            mapNavigation = chart.options.mapNavigation;\n\n        // Render the plus and minus buttons. Doing this before the shapes makes getBBox much quicker, at least in Chrome.\n        chart.renderMapNavigation();\n\n        proceed.call(chart);\n\n        // Add the double click event\n        if (pick(mapNavigation.enableDoubleClickZoom, mapNavigation.enabled) || mapNavigation.enableDoubleClickZoomTo) {\n            addEvent(chart.container, 'dblclick', function (e) {\n                chart.pointer.onContainerDblClick(e);\n            });\n        }\n\n        // Add the mousewheel event\n        if (pick(mapNavigation.enableMouseWheelZoom, mapNavigation.enabled)) {\n            addEvent(chart.container, doc.onmousewheel === undefined ? 'DOMMouseScroll' : 'mousewheel', function (e) {\n                chart.pointer.onContainerMouseWheel(e);\n                return false;\n            });\n        }\n    });\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var extend = H.extend,\n            pick = H.pick,\n            Pointer = H.Pointer,\n            wrap = H.wrap;\n        \n    // Extend the Pointer\n    extend(Pointer.prototype, {\n\n        /**\n         * The event handler for the doubleclick event\n         */\n        onContainerDblClick: function (e) {\n            var chart = this.chart;\n\n            e = this.normalize(e);\n\n            if (chart.options.mapNavigation.enableDoubleClickZoomTo) {\n                if (chart.pointer.inClass(e.target, 'highcharts-tracker')) {\n                    chart.hoverPoint.zoomTo();\n                }\n            } else if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                chart.mapZoom(\n                    0.5,\n                    chart.xAxis[0].toValue(e.chartX),\n                    chart.yAxis[0].toValue(e.chartY),\n                    e.chartX,\n                    e.chartY\n                );\n            }\n        },\n\n        /**\n         * The event handler for the mouse scroll event\n         */\n        onContainerMouseWheel: function (e) {\n            var chart = this.chart,\n                delta;\n\n            e = this.normalize(e);\n\n            // Firefox uses e.detail, WebKit and IE uses wheelDelta\n            delta = e.detail || -(e.wheelDelta / 120);\n            if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                chart.mapZoom(\n                    //delta > 0 ? 2 : 0.5,\n                    Math.pow(2, delta),\n                    chart.xAxis[0].toValue(e.chartX),\n                    chart.yAxis[0].toValue(e.chartY),\n                    e.chartX,\n                    e.chartY\n                );\n            }\n        }\n    });\n\n    // Implement the pinchType option\n    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n\n        proceed.call(this, chart, options);\n\n        // Pinch status\n        if (pick(options.mapNavigation.enableTouchZoom, options.mapNavigation.enabled)) {\n            this.pinchX = this.pinchHor = this.pinchY = this.pinchVert = this.hasZoom = true;\n        }\n    });\n\n    // Extend the pinchTranslate method to preserve fixed ratio when zooming\n    wrap(Pointer.prototype, 'pinchTranslate', function (proceed, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n        var xBigger;\n        proceed.call(this, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n        // Keep ratio\n        if (this.chart.options.chart.type === 'map' && this.hasZoom) {\n            xBigger = transform.scaleX > transform.scaleY;\n            this.pinchTranslateDirection(\n                !xBigger,\n                pinchDown,\n                touches,\n                transform,\n                selectionMarker,\n                clip,\n                lastValidTouch,\n                xBigger ? transform.scaleX : transform.scaleY\n            );\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Color = H.Color,\n            ColorAxis = H.ColorAxis,\n            colorPointMixin = H.colorPointMixin,\n            colorSeriesMixin = H.colorSeriesMixin,\n            defaultPlotOptions = H.defaultPlotOptions,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            splat = H.splat;\n\n    // The vector-effect attribute is not supported in IE <= 11 (at least), so we need\n    // diffent logic (#3218)\n    var supportsVectorEffect = doc.documentElement.style.vectorEffect !== undefined;\n\n    /**\n     * Extend the default options with map options\n     */\n    defaultPlotOptions.map = merge(defaultPlotOptions.scatter, {\n        allAreas: true,\n\n        animation: false, // makes the complex shapes slow\n        nullColor: '#F8F8F8',\n        borderColor: 'silver',\n        borderWidth: 1,\n        marker: null,\n        stickyTracking: false,\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.value;\n            },\n            inside: true, // for the color\n            verticalAlign: 'middle',\n            crop: false,\n            overflow: false,\n            padding: 0\n        },\n        turboThreshold: 0,\n        tooltip: {\n            followPointer: true,\n            pointFormat: '{point.name}: {point.value}<br/>'\n        },\n        states: {\n            normal: {\n                animation: true\n            },\n            hover: {\n                brightness: 0.2,\n                halo: null\n            },\n            select: {\n                color: '#C0C0C0'\n            }\n        }\n    });\n\n    /**\n     * The MapAreaPoint object\n     */\n    var MapAreaPoint = H.MapAreaPoint = extendClass(Point, extend({\n        /**\n         * Extend the Point object to split paths\n         */\n        applyOptions: function (options, x) {\n\n            var point = Point.prototype.applyOptions.call(this, options, x),\n                series = this.series,\n                joinBy = series.joinBy,\n                mapPoint;\n\n            if (series.mapData) {\n                mapPoint = point[joinBy[1]] !== undefined && series.mapMap[point[joinBy[1]]];\n                if (mapPoint) {\n                    // This applies only to bubbles\n                    if (series.xyFromShape) {\n                        point.x = mapPoint._midX;\n                        point.y = mapPoint._midY;\n                    }\n                    extend(point, mapPoint); // copy over properties\n                } else {\n                    point.value = point.value || null;\n                }\n            }\n\n            return point;\n        },\n\n        /**\n         * Stop the fade-out\n         */\n        onMouseOver: function (e) {\n            clearTimeout(this.colorInterval);\n            if (this.value !== null) {\n                Point.prototype.onMouseOver.call(this, e);\n            } else { //#3401 Tooltip doesn't hide when hovering over null points\n                this.series.onMouseOut(e);\n            }\n        },\n        ";
if (build.classic) { 
s += "\n        // Todo: check unstyled\n        /**\n         * Custom animation for tweening out the colors. Animation reduces blinking when hovering\n         * over islands and coast lines. We run a custom implementation of animation becuase we\n         * need to be able to run this independently from other animations like zoom redraw. Also,\n         * adding color animation to the adapters would introduce almost the same amount of code.\n         */\n        onMouseOut: function () {\n            var point = this,\n                start = +new Date(),\n                normalColor = Color(point.color),\n                hoverColor = Color(point.series.pointAttribs(point, 'hover').fill),\n                animation = point.series.options.states.normal.animation,\n                duration = animation && (animation.duration || 500);\n\n            if (duration && normalColor.rgba.length === 4 && hoverColor.rgba.length === 4 && point.state !== 'select') {\n                clearTimeout(point.colorInterval);\n                point.colorInterval = setInterval(function () {\n                    var pos = (new Date() - start) / duration,\n                        graphic = point.graphic;\n                    if (pos > 1) {\n                        pos = 1;\n                    }\n                    if (graphic) {\n                        graphic.attr('fill', ColorAxis.prototype.tweenColors.call(0, hoverColor, normalColor, pos));\n                    }\n                    if (pos >= 1) {\n                        clearTimeout(point.colorInterval);\n                    }\n                }, 13);\n            }\n            point.isFading = true;\n            Point.prototype.onMouseOut.call(point);\n            point.isFading = null;\n        },\n        ";
} 
s += "\n\n        /**\n         * Zoom the chart to view a specific area point\n         */\n        zoomTo: function () {\n            var point = this,\n                series = point.series;\n\n            series.xAxis.setExtremes(\n                point._minX,\n                point._maxX,\n                false\n            );\n            series.yAxis.setExtremes(\n                point._minY,\n                point._maxY,\n                false\n            );\n            series.chart.redraw();\n        }\n    }, colorPointMixin)\n    );\n\n    /**\n     * Add the series type\n     */\n    seriesTypes.map = extendClass(seriesTypes.scatter, merge(colorSeriesMixin, {\n        type: 'map',\n        pointClass: MapAreaPoint,\n        supportsDrilldown: true,\n        getExtremesFromAll: true,\n        useMapGeometry: true, // get axis extremes from paths, not values\n        forceDL: true,\n        searchPoint: noop,\n        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n        preserveAspectRatio: true, // X axis and Y axis must have same translation slope\n        /**\n         * Get the bounding box of all paths in the map combined.\n         */\n        getBox: function (paths) {\n            var MAX_VALUE = Number.MAX_VALUE,\n                maxX = -MAX_VALUE,\n                minX =  MAX_VALUE,\n                maxY = -MAX_VALUE,\n                minY =  MAX_VALUE,\n                minRange = MAX_VALUE,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                hasBox;\n\n            // Find the bounding box\n            each(paths || [], function (point) {\n\n                if (point.path) {\n                    if (typeof point.path === 'string') {\n                        point.path = H.splitPath(point.path);\n                    }\n\n                    var path = point.path || [],\n                        i = path.length,\n                        even = false, // while loop reads from the end\n                        pointMaxX = -MAX_VALUE,\n                        pointMinX =  MAX_VALUE,\n                        pointMaxY = -MAX_VALUE,\n                        pointMinY =  MAX_VALUE,\n                        properties = point.properties;\n\n                    // The first time a map point is used, analyze its box\n                    if (!point._foundBox) {\n                        while (i--) {\n                            if (typeof path[i] === 'number' && !isNaN(path[i])) {\n                                if (even) { // even = x\n                                    pointMaxX = Math.max(pointMaxX, path[i]);\n                                    pointMinX = Math.min(pointMinX, path[i]);\n                                } else { // odd = Y\n                                    pointMaxY = Math.max(pointMaxY, path[i]);\n                                    pointMinY = Math.min(pointMinY, path[i]);\n                                }\n                                even = !even;\n                            }\n                        }\n                        // Cache point bounding box for use to position data labels, bubbles etc\n                        point._midX = pointMinX + (pointMaxX - pointMinX) *\n                            (point.middleX || (properties && properties['hc-middle-x']) || 0.5); // pick is slower and very marginally needed\n                        point._midY = pointMinY + (pointMaxY - pointMinY) *\n                            (point.middleY || (properties && properties['hc-middle-y']) || 0.5);\n                        point._maxX = pointMaxX;\n                        point._minX = pointMinX;\n                        point._maxY = pointMaxY;\n                        point._minY = pointMinY;\n                        point.labelrank = pick(point.labelrank, (pointMaxX - pointMinX) * (pointMaxY - pointMinY));\n                        point._foundBox = true;\n                    }\n\n                    maxX = Math.max(maxX, point._maxX);\n                    minX = Math.min(minX, point._minX);\n                    maxY = Math.max(maxY, point._maxY);\n                    minY = Math.min(minY, point._minY);\n                    minRange = Math.min(point._maxX - point._minX, point._maxY - point._minY, minRange);\n                    hasBox = true;\n                }\n            });\n\n            // Set the box for the whole series\n            if (hasBox) {\n                this.minY = Math.min(minY, pick(this.minY, MAX_VALUE));\n                this.maxY = Math.max(maxY, pick(this.maxY, -MAX_VALUE));\n                this.minX = Math.min(minX, pick(this.minX, MAX_VALUE));\n                this.maxX = Math.max(maxX, pick(this.maxX, -MAX_VALUE));\n\n                // If no minRange option is set, set the default minimum zooming range to 5 times the\n                // size of the smallest element\n                if (xAxis && xAxis.options.minRange === undefined) {\n                    xAxis.minRange = Math.min(5 * minRange, (this.maxX - this.minX) / 5, xAxis.minRange || MAX_VALUE);\n                }\n                if (yAxis && yAxis.options.minRange === undefined) {\n                    yAxis.minRange = Math.min(5 * minRange, (this.maxY - this.minY) / 5, yAxis.minRange || MAX_VALUE);\n                }\n            }\n        },\n\n        getExtremes: function () {\n            // Get the actual value extremes for colors\n            Series.prototype.getExtremes.call(this, this.valueData);\n\n            // Recalculate box on updated data\n            if (this.chart.hasRendered && this.isDirtyData) {\n                this.getBox(this.options.data);\n            }\n\n            this.valueMin = this.dataMin;\n            this.valueMax = this.dataMax;\n\n            // Extremes for the mock Y axis\n            this.dataMin = this.minY;\n            this.dataMax = this.maxY;\n        },\n\n        /**\n         * Translate the path so that it automatically fits into the plot area box\n         * @param {Object} path\n         */\n        translatePath: function (path) {\n\n            var series = this,\n                even = false, // while loop reads from the end\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                xMin = xAxis.min,\n                xTransA = xAxis.transA,\n                xMinPixelPadding = xAxis.minPixelPadding,\n                yMin = yAxis.min,\n                yTransA = yAxis.transA,\n                yMinPixelPadding = yAxis.minPixelPadding,\n                i,\n                ret = []; // Preserve the original\n\n            // Do the translation\n            if (path) {\n                i = path.length;\n                while (i--) {\n                    if (typeof path[i] === 'number') {\n                        ret[i] = even ?\n                            (path[i] - xMin) * xTransA + xMinPixelPadding :\n                            (path[i] - yMin) * yTransA + yMinPixelPadding;\n                        even = !even;\n                    } else {\n                        ret[i] = path[i];\n                    }\n                }\n            }\n\n            return ret;\n        },\n\n        /**\n         * Extend setData to join in mapData. If the allAreas option is true, all areas\n         * from the mapData are used, and those that don't correspond to a data value\n         * are given null values.\n         */\n        setData: function (data, redraw) {\n            var options = this.options,\n                mapData = options.mapData,\n                joinBy = options.joinBy,\n                joinByNull = joinBy === null,\n                dataUsed = [],\n                mapPoint,\n                transform,\n                mapTransforms,\n                props,\n                i;\n\n            if (joinByNull) {\n                joinBy = '_i';\n            }\n            joinBy = this.joinBy = splat(joinBy);\n            if (!joinBy[1]) {\n                joinBy[1] = joinBy[0];\n            }\n\n            // Pick up numeric values, add index\n            if (data) {\n                each(data, function (val, i) {\n                    if (typeof val === 'number') {\n                        data[i] = {\n                            value: val\n                        };\n                    }\n                    if (joinByNull) {\n                        data[i]._i = i;\n                    }\n                });\n            }\n\n            this.getBox(data);\n            if (mapData) {\n                if (mapData.type === 'FeatureCollection') {\n                    if (mapData['hc-transform']) {\n                        this.chart.mapTransforms = mapTransforms = mapData['hc-transform'];\n                        // Cache cos/sin of transform rotation angle\n                        for (transform in mapTransforms) {\n                            if (mapTransforms.hasOwnProperty(transform) && transform.rotation) {\n                                transform.cosAngle = Math.cos(transform.rotation);\n                                transform.sinAngle = Math.sin(transform.rotation);\n                            }\n                        }\n                    }\n                    mapData = H.geojson(mapData, this.type, this);\n                }\n\n                this.getBox(mapData);\n                this.mapData = mapData;\n                this.mapMap = {};\n\n                for (i = 0; i < mapData.length; i++) {\n                    mapPoint = mapData[i];\n                    props = mapPoint.properties;\n\n                    mapPoint._i = i;\n                    // Copy the property over to root for faster access\n                    if (joinBy[0] && props && props[joinBy[0]]) {\n                        mapPoint[joinBy[0]] = props[joinBy[0]];\n                    }\n                    this.mapMap[mapPoint[joinBy[0]]] = mapPoint;\n                }\n\n                if (options.allAreas) {\n\n                    data = data || [];\n\n                    // Registered the point codes that actually hold data\n                    if (joinBy[1]) {\n                        each(data, function (point) {\n                            dataUsed.push(point[joinBy[1]]);\n                        });\n                    }\n\n                    // Add those map points that don't correspond to data, which will be drawn as null points\n                    dataUsed = '|' + dataUsed.join('|') + '|'; // String search is faster than array.indexOf\n\n                    each(mapData, function (mapPoint) {\n                        if (!joinBy[0] || dataUsed.indexOf('|' + mapPoint[joinBy[0]] + '|') === -1) {\n                            data.push(merge(mapPoint, { value: null }));\n                        }\n                    });\n                }\n            }\n            Series.prototype.setData.call(this, data, redraw);\n        },\n\n\n        /**\n         * No graph for the map series\n         */\n        drawGraph: noop,\n\n        /**\n         * We need the points' bounding boxes in order to draw the data labels, so\n         * we skip it now and call it from drawPoints instead.\n         */\n        drawDataLabels: noop,\n\n        /**\n         * Allow a quick redraw by just translating the area group. Used for zooming and panning\n         * in capable browsers.\n         */\n        doFullTranslate: function () {\n            return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;\n        },\n\n        /**\n         * Add the path option for data points. Find the max value for color calculation.\n         */\n        translate: function () {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                doFullTranslate = series.doFullTranslate();\n\n            series.generatePoints();\n\n            each(series.data, function (point) {\n\n                // Record the middle point (loosely based on centroid), determined\n                // by the middleX and middleY options.\n                point.plotX = xAxis.toPixels(point._midX, true);\n                point.plotY = yAxis.toPixels(point._midY, true);\n\n                if (doFullTranslate) {\n\n                    point.shapeType = 'path';\n                    point.shapeArgs = {\n                        d: series.translatePath(point.path)\n                    };\n                }\n            });\n\n            series.translateColors();\n        },\n\n        /**\n         * Get presentational attributes\n         */\n        pointAttribs: function (point, state) {\n            var attr = seriesTypes.column.prototype.pointAttribs.call(this, point, state);\n\n            // Prevent flickering whan called from setState\n            if (point.isFading) {\n                delete attr.fill;\n            }\n\n            // If vector-effect is not supported, we set the stroke-width on the group element\n            // and let all point graphics inherit. That way we don't have to iterate over all \n            // points to update the stroke-width on zooming. TODO: Check unstyled\n            if (supportsVectorEffect) {\n                attr['vector-effect'] = 'non-scaling-stroke';\n            } else {\n                attr['stroke-width'] = 'inherit';\n            }\n\n            return attr;\n        },\n    \n        /** \n         * Use the drawPoints method of column, that is able to handle simple shapeArgs.\n         * Extend it by assigning the tooltip position.\n         */\n        drawPoints: function () {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                group = series.group,\n                chart = series.chart,\n                renderer = chart.renderer,\n                scaleX,\n                scaleY,\n                translateX,\n                translateY,\n                baseTrans = this.baseTrans;\n\n            // Set a group that handles transform during zooming and panning in order to preserve clipping\n            // on series.group\n            if (!series.transformGroup) {\n                series.transformGroup = renderer.g()\n                    .attr({\n                        scaleX: 1,\n                        scaleY: 1\n                    })\n                    .add(group);\n                series.transformGroup.survive = true;\n            }\n\n            // Draw the shapes again\n            if (series.doFullTranslate()) {\n\n                // Individual point actions. TODO: Check unstyled.\n                ";
if (build.classic) { 
s += "\n                if (chart.hasRendered) {\n                    each(series.points, function (point) {\n\n                        // Restore state color on update/redraw (#3529)\n                        if (point.shapeArgs) {\n                            point.shapeArgs.fill = series.pointAttribs(point, point.state).fill;\n                        }\n                    });\n                }\n                ";
} 
s += "\n\n                // Draw them in transformGroup\n                series.group = series.transformGroup;\n                seriesTypes.column.prototype.drawPoints.apply(series);\n                series.group = group; // Reset\n\n                // Add class names\n                each(series.points, function (point) {\n                    if (point.graphic) {\n                        if (point.name) {\n                            point.graphic.addClass('highcharts-name-' + point.name.replace(' ', '-').toLowerCase());\n                        }\n                        if (point.properties && point.properties['hc-key']) {\n                            point.graphic.addClass('highcharts-key-' + point.properties['hc-key'].toLowerCase());\n                        }\n                    }\n                });\n\n                // Set the base for later scale-zooming. The originX and originY properties are the\n                // axis values in the plot area's upper left corner.\n                this.baseTrans = {\n                    originX: xAxis.min - xAxis.minPixelPadding / xAxis.transA,\n                    originY: yAxis.min - yAxis.minPixelPadding / yAxis.transA + (yAxis.reversed ? 0 : yAxis.len / yAxis.transA),\n                    transAX: xAxis.transA,\n                    transAY: yAxis.transA\n                };\n\n                // Reset transformation in case we're doing a full translate (#3789)\n                this.transformGroup.animate({\n                    translateX: 0,\n                    translateY: 0,\n                    scaleX: 1,\n                    scaleY: 1\n                });\n\n            // Just update the scale and transform for better performance\n            } else {\n                scaleX = xAxis.transA / baseTrans.transAX;\n                scaleY = yAxis.transA / baseTrans.transAY;\n                translateX = xAxis.toPixels(baseTrans.originX, true);\n                translateY = yAxis.toPixels(baseTrans.originY, true);\n\n                // Handle rounding errors in normal view (#3789)\n                if (scaleX > 0.99 && scaleX < 1.01 && scaleY > 0.99 && scaleY < 1.01) {\n                    scaleX = 1;\n                    scaleY = 1;\n                    translateX = Math.round(translateX);\n                    translateY = Math.round(translateY);\n                }\n\n                this.transformGroup.animate({\n                    translateX: translateX,\n                    translateY: translateY,\n                    scaleX: scaleX,\n                    scaleY: scaleY\n                });\n\n            }\n\n            // Set the stroke-width directly on the group element so the children inherit it. We need to use\n            // setAttribute directly, because the stroke-widthSetter method expects a stroke color also to be\n            // set.\n            if (!supportsVectorEffect) {\n                series.group.element.setAttribute('stroke-width', series.options.borderWidth / (scaleX || 1));\n            }\n\n            this.drawMapDataLabels();\n\n\n        },\n\n        /**\n         * Draw the data labels. Special for maps is the time that the data labels are drawn (after points),\n         * and the clipping of the dataLabelsGroup.\n         */\n        drawMapDataLabels: function () {\n\n            Series.prototype.drawDataLabels.call(this);\n            if (this.dataLabelsGroup) {\n                this.dataLabelsGroup.clip(this.chart.clipRect);\n            }\n        },\n\n        /**\n         * Override render to throw in an async call in IE8. Otherwise it chokes on the US counties demo.\n         */\n        render: function () {\n            var series = this,\n                render = Series.prototype.render;\n\n            // Give IE8 some time to breathe.\n            if (series.chart.renderer.isVML && series.data.length > 3000) {\n                setTimeout(function () {\n                    render.call(series);\n                });\n            } else {\n                render.call(series);\n            }\n        },\n\n        /**\n         * The initial animation for the map series. By default, animation is disabled.\n         * Animation of map shapes is not at all supported in VML browsers.\n         */\n        animate: function (init) {\n            var chart = this.chart,\n                animation = this.options.animation,\n                group = this.group,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                left = xAxis.pos,\n                top = yAxis.pos;\n\n            if (chart.renderer.isSVG) {\n\n                if (animation === true) {\n                    animation = {\n                        duration: 1000\n                    };\n                }\n\n                // Initialize the animation\n                if (init) {\n\n                    // Scale down the group and place it in the center\n                    group.attr({\n                        translateX: left + xAxis.len / 2,\n                        translateY: top + yAxis.len / 2,\n                        scaleX: 0.001, // #1499\n                        scaleY: 0.001\n                    });\n\n                // Run the animation\n                } else {\n                    group.animate({\n                        translateX: left,\n                        translateY: top,\n                        scaleX: 1,\n                        scaleY: 1\n                    }, animation);\n\n                    // Delete this function to allow it only once\n                    this.animate = null;\n                }\n            }\n        },\n\n        /**\n         * Animate in the new series from the clicked point in the old series.\n         * Depends on the drilldown.js module\n         */\n        animateDrilldown: function (init) {\n            var toBox = this.chart.plotBox,\n                level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],\n                fromBox = level.bBox,\n                animationOptions = this.chart.options.drilldown.animation,\n                scale;\n\n            if (!init) {\n\n                scale = Math.min(fromBox.width / toBox.width, fromBox.height / toBox.height);\n                level.shapeArgs = {\n                    scaleX: scale,\n                    scaleY: scale,\n                    translateX: fromBox.x,\n                    translateY: fromBox.y\n                };\n\n                each(this.points, function (point) {\n                    if (point.graphic) {\n                        point.graphic\n                            .attr(level.shapeArgs)\n                            .animate({\n                                scaleX: 1,\n                                scaleY: 1,\n                                translateX: 0,\n                                translateY: 0\n                            }, animationOptions);\n                    }\n                });\n\n                this.animate = null;\n            }\n\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n        /**\n         * When drilling up, pull out the individual point graphics from the lower series\n         * and animate them into the origin point in the upper series.\n         */\n        animateDrillupFrom: function (level) {\n            seriesTypes.column.prototype.animateDrillupFrom.call(this, level);\n        },\n\n\n        /**\n         * When drilling up, keep the upper series invisible until the lower series has\n         * moved into place\n         */\n        animateDrillupTo: function (init) {\n            seriesTypes.column.prototype.animateDrillupTo.call(this, init);\n        }\n    }));\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            seriesTypes = H.seriesTypes;\n\n    // The mapline series type\n    defaultPlotOptions.mapline = merge(defaultPlotOptions.map, {\n        lineWidth: 1,\n        fillColor: 'none'\n    });\n    seriesTypes.mapline = extendClass(seriesTypes.map, {\n        type: 'mapline',\n        pointAttrToOptions: {\n            'stroke-width': 'lineWidth'\n        },\n        /**\n         * Get presentational attributes\n         */\n        pointAttribs: function (point, state) {\n            var attr = seriesTypes.map.prototype.pointAttribs.call(this, point, state);\n\n            // The difference from a map series is that the stroke takes the point color\n            attr.stroke = attr.fill;\n            attr.fill = this.options.fillColor;\n\n            return attr;\n        },\n        drawLegendSymbol: seriesTypes.line.prototype.drawLegendSymbol\n    });\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            Point = H.Point,\n            seriesTypes = H.seriesTypes;\n\n    // The mappoint series type\n    defaultPlotOptions.mappoint = merge(defaultPlotOptions.scatter, {\n        dataLabels: {\n            enabled: true,\n            formatter: function () { // #2945\n                return this.point.name;\n            },\n            crop: false,\n            defer: false,\n            overflow: false,\n            style: {\n                color: '#000000'\n            }\n        }\n    });\n    seriesTypes.mappoint = extendClass(seriesTypes.scatter, {\n        type: 'mappoint',\n        forceDL: true,\n        pointClass: extendClass(Point, {\n            applyOptions: function (options, x) {\n                var point = Point.prototype.applyOptions.call(this, options, x);\n                if (options.lat !== undefined && options.lon !== undefined) {\n                    point = extend(point, this.series.chart.fromLatLonToPoint(point));\n                }\n                return point;\n            }\n        })\n    });\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            MapAreaPoint = H.MapAreaPoint,\n            merge = H.merge,\n            Point = H.Point,\n            seriesTypes = H.seriesTypes;\n\n    // The mapbubble series type\n    if (seriesTypes.bubble) {\n\n        defaultPlotOptions.mapbubble = merge(defaultPlotOptions.bubble, {\n            animationLimit: 500,\n            tooltip: {\n                pointFormat: '{point.name}: {point.z}'\n            }\n        });\n        seriesTypes.mapbubble = extendClass(seriesTypes.bubble, {\n            pointClass: extendClass(Point, {\n                applyOptions: function (options, x) {\n                    var point;\n                    if (options && options.lat !== undefined && options.lon !== undefined) {\n                        point = Point.prototype.applyOptions.call(this, options, x);\n                        point = extend(point, this.series.chart.fromLatLonToPoint(point));\n                    } else {\n                        point = MapAreaPoint.prototype.applyOptions.call(this, options, x);\n                    }\n                    return point;\n                },\n                ttBelow: false\n            }),\n            xyFromShape: true,\n            type: 'mapbubble',\n            pointArrayMap: ['z'], // If one single value is passed, it is interpreted as z\n            /**\n             * Return the map area identified by the dataJoinBy option\n             */\n            getMapData: seriesTypes.map.prototype.getMapData,\n            getBox: seriesTypes.map.prototype.getBox,\n            setData: seriesTypes.map.prototype.setData\n        });\n    }\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var colorPointMixin = H.colorPointMixin,\n            colorSeriesMixin = H.colorSeriesMixin,\n            defaultOptions = H.defaultOptions,\n            each = H.each,\n            extendClass = H.extendClass,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes;\n    /**\n     * Extend the default options with map options\n     */\n    defaultOptions.plotOptions.heatmap = merge(defaultOptions.plotOptions.scatter, {\n        animation: false,\n        borderWidth: 0,\n        nullColor: '#F8F8F8',\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.value;\n            },\n            inside: true,\n            verticalAlign: 'middle',\n            crop: false,\n            overflow: false,\n            padding: 0 // #3837\n        },\n        marker: null,\n        pointRange: null, // dynamically set to colsize by default\n        tooltip: {\n            pointFormat: '{point.x}, {point.y}: {point.value}<br/>'\n        },\n        states: {\n            normal: {\n                animation: true\n            },\n            hover: {\n                halo: false,  // #3406, halo is not required on heatmaps\n                brightness: 0.2\n            }\n        }\n    });\n\n    // The Heatmap series type\n    seriesTypes.heatmap = extendClass(seriesTypes.scatter, merge(colorSeriesMixin, {\n        type: 'heatmap',\n        pointArrayMap: ['y', 'value'],\n        hasPointSpecificOptions: true,\n        pointClass: extendClass(Point, colorPointMixin),\n        supportsDrilldown: true,\n        getExtremesFromAll: true,\n        directTouch: true,\n\n        /**\n         * Override the init method to add point ranges on both axes.\n         */\n        init: function () {\n            var options;\n            seriesTypes.scatter.prototype.init.apply(this, arguments);\n\n            options = this.options;\n            options.pointRange = pick(options.pointRange, options.colsize || 1); // #3758, prevent resetting in setData\n            this.yAxis.axisPointRange = options.rowsize || 1; // general point range\n        },\n        translate: function () {\n            var series = this,\n                options = series.options,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                between = function (x, a, b) {\n                    return Math.min(Math.max(a, x), b);\n                };\n\n            series.generatePoints();\n\n            each(series.points, function (point) {\n                var xPad = (options.colsize || 1) / 2,\n                    yPad = (options.rowsize || 1) / 2,\n                    x1 = between(Math.round(xAxis.len - xAxis.translate(point.x - xPad, 0, 1, 0, 1)), 0, xAxis.len),\n                    x2 = between(Math.round(xAxis.len - xAxis.translate(point.x + xPad, 0, 1, 0, 1)), 0, xAxis.len),\n                    y1 = between(Math.round(yAxis.translate(point.y - yPad, 0, 1, 0, 1)), 0, yAxis.len),\n                    y2 = between(Math.round(yAxis.translate(point.y + yPad, 0, 1, 0, 1)), 0, yAxis.len);\n\n                // Set plotX and plotY for use in K-D-Tree and more\n                point.plotX = point.clientX = (x1 + x2) / 2;\n                point.plotY = (y1 + y2) / 2;\n\n                point.shapeType = 'rect';\n                point.shapeArgs = {\n                    x: Math.min(x1, x2),\n                    y: Math.min(y1, y2),\n                    width: Math.abs(x2 - x1),\n                    height: Math.abs(y2 - y1)\n                };\n            });\n\n            series.translateColors();\n\n            // Make sure colors are updated on colorAxis update (#2893)\n            if (this.chart.hasRendered) {\n                each(series.points, function (point) {\n                    point.shapeArgs.fill = point.options.color || point.color; // #3311\n                });\n            }\n        },\n        drawPoints: seriesTypes.column.prototype.drawPoints,\n        animate: noop,\n        getBox: noop,\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n        getExtremes: function () {\n            // Get the extremes from the value data\n            Series.prototype.getExtremes.call(this, this.valueData);\n            this.valueMin = this.dataMin;\n            this.valueMax = this.dataMax;\n\n            // Get the extremes from the y data\n            Series.prototype.getExtremes.call(this);\n        }\n\n    }));\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultOptions = H.defaultOptions,\n            Chart = H.Chart,\n            each = H.each,\n            extend = H.extend,\n            error = H.error,\n            win = H.win,\n            wrap = H.wrap;\n    /** \n     * Test for point in polygon. Polygon defined as array of [x,y] points.\n     */\n    function pointInPolygon(point, polygon) {\n        var i, j, rel1, rel2, c = false,\n            x = point.x,\n            y = point.y;\n\n        for (i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n            rel1 = polygon[i][1] > y;\n            rel2 = polygon[j][1] > y;\n            if (rel1 !== rel2 && (x < (polygon[j][0] - polygon[i][0]) * (y - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0])) {\n                c = !c;\n            }\n        }\n\n        return c;\n    }\n\n    /**\n     * Get point from latLon using specified transform definition\n     */\n    Chart.prototype.transformFromLatLon = function (latLon, transform) {\n        if (win.proj4 === undefined) {\n            error(21);\n            return {\n                x: 0,\n                y: null\n            };\n        }\n\n        var projected = win.proj4(transform.crs, [latLon.lon, latLon.lat]),\n            cosAngle = transform.cosAngle || (transform.rotation && Math.cos(transform.rotation)),\n            sinAngle = transform.sinAngle || (transform.rotation && Math.sin(transform.rotation)),\n            rotated = transform.rotation ? [projected[0] * cosAngle + projected[1] * sinAngle, -projected[0] * sinAngle + projected[1] * cosAngle] : projected;\n\n        return {\n            x: ((rotated[0] - (transform.xoffset || 0)) * (transform.scale || 1) + (transform.xpan || 0)) * (transform.jsonres || 1) + (transform.jsonmarginX || 0),\n            y: (((transform.yoffset || 0) - rotated[1]) * (transform.scale || 1) + (transform.ypan || 0)) * (transform.jsonres || 1) - (transform.jsonmarginY || 0)\n        };\n    };\n\n    /**\n     * Get latLon from point using specified transform definition\n     */\n    Chart.prototype.transformToLatLon = function (point, transform) {\n        if (win.proj4 === undefined) {\n            error(21);\n            return;\n        }\n\n        var normalized = {\n                x: ((point.x - (transform.jsonmarginX || 0)) / (transform.jsonres || 1) - (transform.xpan || 0)) / (transform.scale || 1) + (transform.xoffset || 0),\n                y: ((-point.y - (transform.jsonmarginY || 0)) / (transform.jsonres || 1) + (transform.ypan || 0)) / (transform.scale || 1) + (transform.yoffset || 0)\n            },\n            cosAngle = transform.cosAngle || (transform.rotation && Math.cos(transform.rotation)),\n            sinAngle = transform.sinAngle || (transform.rotation && Math.sin(transform.rotation)),\n            // Note: Inverted sinAngle to reverse rotation direction\n            projected = win.proj4(transform.crs, 'WGS84', transform.rotation ? {\n                x: normalized.x * cosAngle + normalized.y * -sinAngle,\n                y: normalized.x * sinAngle + normalized.y * cosAngle\n            } : normalized);\n\n        return { lat: projected.y, lon: projected.x };\n    };\n\n    Chart.prototype.fromPointToLatLon = function (point) {\n        var transforms = this.mapTransforms,\n            transform;\n\n        if (!transforms) {\n            error(22);\n            return;\n        }\n\n        for (transform in transforms) {\n            if (transforms.hasOwnProperty(transform) && transforms[transform].hitZone && \n                    pointInPolygon({ x: point.x, y: -point.y }, transforms[transform].hitZone.coordinates[0])) {\n                return this.transformToLatLon(point, transforms[transform]);\n            }\n        }\n\n        return this.transformToLatLon(point, transforms['default']); // eslint-disable-line dot-notation\n    };\n\n    Chart.prototype.fromLatLonToPoint = function (latLon) {\n        var transforms = this.mapTransforms,\n            transform,\n            coords;\n\n        if (!transforms) {\n            error(22);\n            return {\n                x: 0,\n                y: null\n            };\n        }\n\n        for (transform in transforms) {\n            if (transforms.hasOwnProperty(transform) && transforms[transform].hitZone) {\n                coords = this.transformFromLatLon(latLon, transforms[transform]);\n                if (pointInPolygon({ x: coords.x, y: -coords.y }, transforms[transform].hitZone.coordinates[0])) {\n                    return coords;\n                }\n            }\n        }\n\n        return this.transformFromLatLon(latLon, transforms['default']); // eslint-disable-line dot-notation\n    };\n\n    /**\n     * Convert a geojson object to map data of a given Highcharts type (map, mappoint or mapline).\n     */\n    H.geojson = function (geojson, hType, series) {\n        var mapData = [],\n            path = [],\n            polygonToPath = function (polygon) {\n                var i,\n                    len = polygon.length;\n                path.push('M');\n                for (i = 0; i < len; i++) {\n                    if (i === 1) {\n                        path.push('L');\n                    }\n                    path.push(polygon[i][0], -polygon[i][1]);\n                }\n            };\n\n        hType = hType || 'map';\n\n        each(geojson.features, function (feature) {\n\n            var geometry = feature.geometry,\n                type = geometry.type,\n                coordinates = geometry.coordinates,\n                properties = feature.properties,\n                point;\n\n            path = [];\n\n            if (hType === 'map' || hType === 'mapbubble') {\n                if (type === 'Polygon') {\n                    each(coordinates, polygonToPath);\n                    path.push('Z');\n\n                } else if (type === 'MultiPolygon') {\n                    each(coordinates, function (items) {\n                        each(items, polygonToPath);\n                    });\n                    path.push('Z');\n                }\n\n                if (path.length) {\n                    point = { path: path };\n                }\n\n            } else if (hType === 'mapline') {\n                if (type === 'LineString') {\n                    polygonToPath(coordinates);\n                } else if (type === 'MultiLineString') {\n                    each(coordinates, polygonToPath);\n                }\n\n                if (path.length) {\n                    point = { path: path };\n                }\n\n            } else if (hType === 'mappoint') {\n                if (type === 'Point') {\n                    point = {\n                        x: coordinates[0],\n                        y: -coordinates[1]\n                    };\n                }\n            }\n            if (point) {\n                mapData.push(extend(point, {\n                    name: properties.name || properties.NAME,\n                    properties: properties\n                }));\n            }\n\n        });\n\n        // Create a credits text that includes map source, to be picked up in Chart.showCredits\n        if (series && geojson.copyrightShort) {\n            series.chart.mapCredits = '<a href=___doublequote___http://www.highcharts.com___doublequote___>Highcharts</a> \\u00A9 ' +\n                '<a href=___doublequote___' + geojson.copyrightUrl + '___doublequote___>' + geojson.copyrightShort + '</a>';\n            series.chart.mapCreditsFull = geojson.copyright;\n        }\n\n        return mapData;\n    };\n\n    /**\n     * Override showCredits to include map source by default\n     */\n    wrap(Chart.prototype, 'showCredits', function (proceed, credits) {\n\n        if (defaultOptions.credits.text === this.options.credits.text && this.mapCredits) { // default text and mapCredits is set\n            credits.text = this.mapCredits;\n            credits.href = null;\n        }\n\n        proceed.call(this, credits);\n\n        if (this.credits && this.mapCreditsFull) {\n            this.credits.attr({\n                title: this.mapCreditsFull\n            });\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Chart = H.Chart,\n            defaultOptions = H.defaultOptions,\n            each = H.each,\n            extend = H.extend,\n            merge = H.merge,\n            Renderer = H.Renderer,\n            SVGRenderer = H.SVGRenderer,\n            VMLRenderer = H.VMLRenderer;\n\n\n    // Add language\n    extend(defaultOptions.lang, {\n        zoomIn: 'Zoom in',\n        zoomOut: 'Zoom out'\n    });\n\n\n    // Set the default map navigation options\n    defaultOptions.mapNavigation = {\n        buttonOptions: {\n            alignTo: 'plotBox',\n            align: 'left',\n            verticalAlign: 'top',\n            x: 0,\n            width: 18,\n            height: 18,\n            style: {\n                fontSize: '15px',\n                fontWeight: 'bold',\n                textAlign: 'center'\n            },\n            theme: {\n                'stroke-width': 1\n            }\n        },\n        buttons: {\n            zoomIn: {\n                onclick: function () {\n                    this.mapZoom(0.5);\n                },\n                text: '+',\n                y: 0\n            },\n            zoomOut: {\n                onclick: function () {\n                    this.mapZoom(2);\n                },\n                text: '-',\n                y: 28\n            }\n        }\n        // enabled: false,\n        // enableButtons: null, // inherit from enabled\n        // enableTouchZoom: null, // inherit from enabled\n        // enableDoubleClickZoom: null, // inherit from enabled\n        // enableDoubleClickZoomTo: false\n        // enableMouseWheelZoom: null, // inherit from enabled\n    };\n\n    /**\n     * Utility for reading SVG paths directly.\n     */\n    H.splitPath = function (path) {\n        var i;\n\n        // Move letters apart\n        path = path.replace(/([A-Za-z])/g, ' $1 ');\n        // Trim\n        path = path.replace(/^\\s*/, '').replace(/\\s*$/, '');\n\n        // Split on spaces and commas\n        path = path.split(/[ ,,]+/); // Extra comma to escape gulp.scripts task\n    \n        // Parse numbers\n        for (i = 0; i < path.length; i++) {\n            if (!/[a-zA-Z]/.test(path[i])) {\n                path[i] = parseFloat(path[i]);\n            }\n        }\n        return path;\n    };\n\n    // A placeholder for map definitions\n    H.maps = {};\n\n\n\n\n\n    // Create symbols for the zoom buttons\n    function selectiveRoundedRect(x, y, w, h, rTopLeft, rTopRight, rBottomRight, rBottomLeft) {\n        return ['M', x + rTopLeft, y,\n            // top side\n            'L', x + w - rTopRight, y,\n            // top right corner\n            'C', x + w - rTopRight / 2, y, x + w, y + rTopRight / 2, x + w, y + rTopRight,\n            // right side\n            'L', x + w, y + h - rBottomRight,\n            // bottom right corner\n            'C', x + w, y + h - rBottomRight / 2, x + w - rBottomRight / 2, y + h, x + w - rBottomRight, y + h,\n            // bottom side\n            'L', x + rBottomLeft, y + h,\n            // bottom left corner\n            'C', x + rBottomLeft / 2, y + h, x, y + h - rBottomLeft / 2, x, y + h - rBottomLeft,\n            // left side\n            'L', x, y + rTopLeft,\n            // top left corner\n            'C', x, y + rTopLeft / 2, x + rTopLeft / 2, y, x + rTopLeft, y,\n            'Z'\n        ];\n    }\n    SVGRenderer.prototype.symbols.topbutton = function (x, y, w, h, attr) {\n        return selectiveRoundedRect(x - 1, y - 1, w, h, attr.r, attr.r, 0, 0);\n    };\n    SVGRenderer.prototype.symbols.bottombutton = function (x, y, w, h, attr) {\n        return selectiveRoundedRect(x - 1, y - 1, w, h, 0, 0, attr.r, attr.r);\n    };\n    // The symbol callbacks are generated on the SVGRenderer object in all browsers. Even\n    // VML browsers need this in order to generate shapes in export. Now share\n    // them with the VMLRenderer.\n    if (Renderer === VMLRenderer) {\n        each(['topbutton', 'bottombutton'], function (shape) {\n            VMLRenderer.prototype.symbols[shape] = SVGRenderer.prototype.symbols[shape];\n        });\n    }\n\n\n    /**\n     * A wrapper for Chart with all the default values for a Map\n     */\n    Highcharts.Map = Highcharts.mapChart = function (a, b, c) {\n\n        var hasRenderToArg = typeof a === 'string' || a.nodeName,\n            options = arguments[hasRenderToArg ? 1 : 0],\n            hiddenAxis = {\n                endOnTick: false,\n                gridLineWidth: 0,\n                lineWidth: 0,\n                minPadding: 0,\n                maxPadding: 0,\n                startOnTick: false,\n                title: null,\n                tickPositions: []\n            },\n            seriesOptions;\n\n        /* For visual testing\n        hiddenAxis.gridLineWidth = 1;\n        hiddenAxis.gridZIndex = 10;\n        hiddenAxis.tickPositions = undefined;\n        // */\n\n        // Don't merge the data\n        seriesOptions = options.series;\n        options.series = null;\n\n        options = merge(\n            {\n                chart: {\n                    panning: 'xy',\n                    type: 'map'\n                },\n                xAxis: hiddenAxis,\n                yAxis: merge(hiddenAxis, { reversed: true })\n            },\n            options, // user's options\n\n            { // forced options\n                chart: {\n                    inverted: false,\n                    alignTicks: false\n                }\n            }\n        );\n\n        options.series = seriesOptions;\n\n\n        return hasRenderToArg ? \n            new Chart(a, options, c) :\n            new Chart(options, b);\n    };\n\n        return H;\n    }(Highcharts));\n    ";
return s;ld(dummy);\n                ret = dummy.getBBox().width;\n                dummy.parentNode.removeChild(dummy);\n            }\n            return ret;\n        },\n        ";
} 
s += "\n        /**\n         * Add an event listener\n         * @param {String} eventType\n         * @param {Function} handler\n         */\n        on: function (eventType, handler) {\n            var svgElement = this,\n                element = svgElement.element;\n\n            // touch\n            if (hasTouch && eventType === 'click') {\n                element.ontouchstart = function (e) {\n                    svgElement.touchEventFired = Date.now();\n                    e.preventDefault();\n                    handler.call(element, e);\n                };\n                element.onclick = function (e) {                                            \n                    if (win.navigator.userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n                        handler.call(element, e);\n                    }\n                };\n            } else {\n                // simplest possible event model for internal use\n                element['on' + eventType] = handler;\n            }\n            return this;\n        },\n\n        /**\n         * Set the coordinates needed to draw a consistent radial gradient across\n         * pie slices regardless of positioning inside the chart. The format is\n         * [centerX, centerY, diameter] in pixels.\n         */\n        setRadialReference: function (coordinates) {\n            var existingGradient = this.renderer.gradients[this.element.gradient];\n\n            this.element.radialReference = coordinates;\n\n            // On redrawing objects with an existing gradient, the gradient needs\n            // to be repositioned (#3801)\n            if (existingGradient && existingGradient.radAttr) {\n                existingGradient.animate(\n                    this.renderer.getRadialAttr(\n                        coordinates,\n                        existingGradient.radAttr\n                    )\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Move an object and its children by x and y values\n         * @param {Number} x\n         * @param {Number} y\n         */\n        translate: function (x, y) {\n            return this.attr({\n                translateX: x,\n                translateY: y\n            });\n        },\n\n        /**\n         * Invert a group, rotate and flip\n         */\n        invert: function () {\n            var wrapper = this;\n            wrapper.inverted = true;\n            wrapper.updateTransform();\n            return wrapper;\n        },\n\n        /**\n         * Private method to update the transform attribute based on internal\n         * properties\n         */\n        updateTransform: function () {\n            var wrapper = this,\n                translateX = wrapper.translateX || 0,\n                translateY = wrapper.translateY || 0,\n                scaleX = wrapper.scaleX,\n                scaleY = wrapper.scaleY,\n                inverted = wrapper.inverted,\n                rotation = wrapper.rotation,\n                element = wrapper.element,\n                transform;\n\n            // flipping affects translate as adjustment for flipping around the group's axis\n            if (inverted) {\n                translateX += wrapper.attr('width');\n                translateY += wrapper.attr('height');\n            }\n\n            // Apply translate. Nearly all transformed elements have translation, so instead\n            // of checking for translate = 0, do it always (#1767, #1846).\n            transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n            // apply rotation\n            if (inverted) {\n                transform.push('rotate(90) scale(-1,1)');\n            } else if (rotation) { // text rotation\n                transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\n                // Delete bBox memo when the rotation changes\n                //delete wrapper.bBox;\n            }\n\n            // apply scale\n            if (defined(scaleX) || defined(scaleY)) {\n                transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n            }\n\n            if (transform.length) {\n                element.setAttribute('transform', transform.join(' '));\n            }\n        },\n        /**\n         * Bring the element to the front\n         */\n        toFront: function () {\n            var element = this.element;\n            element.parentNode.appendChild(element);\n            return this;\n        },\n\n\n        /**\n         * Break down alignment options like align, verticalAlign, x and y\n         * to x and y relative to the chart.\n         *\n         * @param {Object} alignOptions\n         * @param {Boolean} alignByTranslate\n         * @param {String[Object} box The box to align to, needs a width and height. When the\n         *        box is a string, it refers to an object in the Renderer. For example, when\n         *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n         *        x and y properties.\n         *\n         */\n        align: function (alignOptions, alignByTranslate, box) {\n            var align,\n                vAlign,\n                x,\n                y,\n                attribs = {},\n                alignTo,\n                renderer = this.renderer,\n                alignedObjects = renderer.alignedObjects,\n                alignFactor,\n                vAlignFactor;\n\n            // First call on instanciate\n            if (alignOptions) {\n                this.alignOptions = alignOptions;\n                this.alignByTranslate = alignByTranslate;\n                if (!box || isString(box)) { // boxes other than renderer handle this internally\n                    this.alignTo = alignTo = box || 'renderer';\n                    erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n                    alignedObjects.push(this);\n                    box = null; // reassign it below\n                }\n\n            // When called on resize, no arguments are supplied\n            } else {\n                alignOptions = this.alignOptions;\n                alignByTranslate = this.alignByTranslate;\n                alignTo = this.alignTo;\n            }\n\n            box = pick(box, renderer[alignTo], renderer);\n\n            // Assign variables\n            align = alignOptions.align;\n            vAlign = alignOptions.verticalAlign;\n            x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n            y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n            // Align\n            if (align === 'right') {\n                alignFactor = 1;\n            } else if (align === 'center') {\n                alignFactor = 2;\n            }\n            if (alignFactor) {\n                x += (box.width - (alignOptions.width || 0)) / alignFactor;\n            }\n            attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n            // Vertical align\n            if (vAlign === 'bottom') {\n                vAlignFactor = 1;\n            } else if (vAlign === 'middle') {\n                vAlignFactor = 2;\n            }\n            if (vAlignFactor) {\n                y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n            }\n            attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n            // Animate only if already placed\n            this[this.placed ? 'animate' : 'attr'](attribs);\n            this.placed = true;\n            this.alignAttr = attribs;\n\n            return this;\n        },\n\n        /**\n         * Get the bounding box (width, height, x and y) for the element\n         */\n        getBBox: function (reload) {\n            var wrapper = this,\n                bBox, // = wrapper.bBox,\n                renderer = wrapper.renderer,\n                width,\n                height,\n                rotation,\n                rad,\n                element = wrapper.element,\n                styles = wrapper.styles,\n                textStr = wrapper.textStr,\n                textShadow,\n                elemStyle = element.style,\n                toggleTextShadowShim,\n                cache = renderer.cache,\n                cacheKeys = renderer.cacheKeys,\n                cacheKey;\n\n            if (textStr !== undefined) {\n\n                // Properties that affect bounding box\n                cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n                // Since numbers are monospaced, and numerical labels appear a lot in a chart,\n                // we assume that a label of n characters has the same bounding box as others\n                // of the same length.\n                if (textStr === '' || /^[0-9]+$/.test(textStr)) {\n                    cacheKey = 'num:' + textStr.toString().length + cacheKey;\n\n                // Caching all strings reduces rendering time by 4-5%.\n                } else {\n                    cacheKey = textStr + cacheKey;\n                }\n            }\n\n            if (cacheKey && !reload) {\n                bBox = cache[cacheKey];\n            }\n\n            // No cache found\n            if (!bBox) {\n\n                // SVG elements\n                if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n                    try { // Fails in Firefox if the container has display: none.\n\n                        // When the text shadow shim is used, we need to hide the fake shadows\n                        // to get the correct bounding box (#3872)\n                        toggleTextShadowShim = this.fakeTS && function (display) {\n                            each(element.querySelectorAll('.highcharts-text-shadow'), function (tspan) {\n                                tspan.style.display = display;\n                            });\n                        };\n\n                        // Workaround for #3842, Firefox reporting wrong bounding box for shadows\n                        if (isFirefox && elemStyle.textShadow) {\n                            textShadow = elemStyle.textShadow;\n                            elemStyle.textShadow = '';\n                        } else if (toggleTextShadowShim) {\n                            toggleTextShadowShim('none');\n                        }\n\n                        bBox = element.getBBox ?\n                            // SVG: use extend because IE9 is not allowed to change width and height in case\n                            // of rotation (below)\n                            extend({}, element.getBBox()) :\n                            // Canvas renderer and legacy IE in export mode\n                            {\n                                width: element.offsetWidth,\n                                height: element.offsetHeight\n                            };\n\n                        // #3842\n                        if (textShadow) {\n                            elemStyle.textShadow = textShadow;\n                        } else if (toggleTextShadowShim) {\n                            toggleTextShadowShim('');\n                        }\n                    } catch (ignore) {}\n\n                    // If the bBox is not set, the try-catch block above failed. The other condition\n                    // is for Opera that returns a width of -Infinity on hidden elements.\n                    if (!bBox || bBox.width < 0) {\n                        bBox = { width: 0, height: 0 };\n                    }\n\n\n                // VML Renderer or useHTML within SVG\n                } else {\n\n                    bBox = wrapper.htmlGetBBox();\n\n                }\n\n                // True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n                // need to compensated for rotation\n                if (renderer.isSVG) {\n                    width = bBox.width;\n                    height = bBox.height;\n\n                    // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n                    if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n                        bBox.height = height = 14;\n                    }\n\n                    // Adjust for rotated text\n                    if (rotation) {\n                        bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));\n                        bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));\n                    }\n                }\n\n                // Cache it\n                if (cacheKey) {\n\n                    // Rotate (#4681)\n                    while (cacheKeys.length > 250) {\n                        delete cache[cacheKeys.shift()];\n                    }\n\n                    if (!cache[cacheKey]) {\n                        cacheKeys.push(cacheKey);\n                    }\n                    cache[cacheKey] = bBox;\n                }\n            }\n            return bBox;\n        },\n\n        /**\n         * Show the element\n         */\n        show: function (inherit) {\n            return this.attr({ visibility: inherit ? 'inherit' : 'visible' });\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            return this.attr({ visibility: 'hidden' });\n        },\n\n        fadeOut: function (duration) {\n            var elemWrapper = this;\n            elemWrapper.animate({\n                opacity: 0\n            }, {\n                duration: duration || 150,\n                complete: function () {\n                    elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n                }\n            });\n        },\n\n        /**\n         * Add the element\n         * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n         *    to append the element to the renderer.box.\n         */\n        add: function (parent) {\n\n            var renderer = this.renderer,\n                element = this.element,\n                inserted;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // mark as inverted\n            this.parentInverted = parent && parent.inverted;\n\n            // build formatted text\n            if (this.textStr !== undefined) {\n                renderer.buildText(this);\n            }\n\n            // Mark as added\n            this.added = true;\n\n            // If we're adding to renderer root, or other elements in the group\n            // have a z index, we need to handle it\n            if (!parent || parent.handleZ || this.zIndex) {\n                inserted = this.zIndexSetter();\n            }\n\n            // If zIndex is not handled, append at the end\n            if (!inserted) {\n                (parent ? parent.element : renderer.box).appendChild(element);\n            }\n\n            // fire an event for internal hooks\n            if (this.onAdd) {\n                this.onAdd();\n            }\n\n            return this;\n        },\n\n        /**\n         * Removes a child either by removeChild or move to garbageBin.\n         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n         */\n        safeRemoveChild: function (element) {\n            var parentNode = element.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(element);\n            }\n        },\n\n        /**\n         * Destroy the element and element wrapper\n         */\n        destroy: function () {\n            var wrapper = this,\n                element = wrapper.element || {},\n                shadows = wrapper.shadows,\n                parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n                grandParent,\n                key,\n                i;\n\n            // remove events\n            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n            stop(wrapper); // stop running animations\n\n            if (wrapper.clipPath) {\n                wrapper.clipPath = wrapper.clipPath.destroy();\n            }\n\n            // Destroy stops in case this is a gradient object\n            if (wrapper.stops) {\n                for (i = 0; i < wrapper.stops.length; i++) {\n                    wrapper.stops[i] = wrapper.stops[i].destroy();\n                }\n                wrapper.stops = null;\n            }\n\n            // remove element\n            wrapper.safeRemoveChild(element);\n\n            // destroy shadows\n            if (shadows) {\n                each(shadows, function (shadow) {\n                    wrapper.safeRemoveChild(shadow);\n                });\n            }\n\n            // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n            while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n                grandParent = parentToClean.parentGroup;\n                wrapper.safeRemoveChild(parentToClean.div);\n                delete parentToClean.div;\n                parentToClean = grandParent;\n            }\n\n            // remove from alignObjects\n            if (wrapper.alignTo) {\n                erase(wrapper.renderer.alignedObjects, wrapper);\n            }\n\n            for (key in wrapper) {\n                delete wrapper[key];\n            }\n\n            return null;\n        },\n\n        /**\n         * Add a shadow to the element. Must be done after the element is added to the DOM\n         * @param {Boolean|Object} shadowOptions\n         */\n        shadow: function (shadowOptions, group, cutOff) {\n            var shadows = [],\n                i,\n                shadow,\n                element = this.element,\n                strokeWidth,\n                shadowWidth,\n                shadowElementOpacity,\n\n                // compensate for inverted plot area\n                transform;\n\n\n            if (shadowOptions) {\n                shadowWidth = pick(shadowOptions.width, 3);\n                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                transform = this.parentInverted ?\n                        '(-1,-1)' :\n                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n                for (i = 1; i <= shadowWidth; i++) {\n                    shadow = element.cloneNode(0);\n                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n                    attr(shadow, {\n                        'isShadow': 'true',\n                        'stroke': shadowOptions.color || 'black',\n                        'stroke-opacity': shadowElementOpacity * i,\n                        'stroke-width': strokeWidth,\n                        'transform': 'translate' + transform,\n                        'fill': 'none'\n                    });\n                    if (cutOff) {\n                        attr(shadow, 'height', Math.max(attr(shadow, 'height') - strokeWidth, 0));\n                        shadow.cutHeight = strokeWidth;\n                    }\n\n                    if (group) {\n                        group.element.appendChild(shadow);\n                    } else {\n                        element.parentNode.insertBefore(shadow, element);\n                    }\n\n                    shadows.push(shadow);\n                }\n\n                this.shadows = shadows;\n            }\n            return this;\n\n        },\n\n        xGetter: function (key) {\n            if (this.element.nodeName === 'circle') {\n                if (key === 'x') {\n                    key = 'cx';\n                } else if (key === 'y') {\n                    key = 'cy';\n                }\n            }\n            return this._defaultGetter(key);\n        },\n\n        /**\n         * Get the current value of an attribute or pseudo attribute, used mainly\n         * for animation.\n         */\n        _defaultGetter: function (key) {\n            var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n            if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n                ret = parseFloat(ret);\n            }\n            return ret;\n        },\n\n\n        dSetter: function (value, key, element) {\n            if (value && value.join) { // join path\n                value = value.join(' ');\n            }\n            if (/(NaN| {2}|^$)/.test(value)) {\n                value = 'M 0 0';\n            }\n            element.setAttribute(key, value);\n\n            this[key] = value;\n        },\n        ";
if (build.classic) { 
s += "\n        dashstyleSetter: function (value) {\n            var i;\n            value = value && value.toLowerCase();\n            if (value) {\n                value = value\n                    .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                    .replace('shortdashdot', '3,1,1,1')\n                    .replace('shortdot', '1,1,')\n                    .replace('shortdash', '3,1,')\n                    .replace('longdash', '8,3,')\n                    .replace(/dot/g, '1,3,')\n                    .replace('dash', '4,3,')\n                    .replace(/,$/, '')\n                    .split(','); // ending comma\n\n                i = value.length;\n                while (i--) {\n                    value[i] = pInt(value[i]) * this['stroke-width'];\n                }\n                value = value.join(',')\n                    .replace('NaN', 'none'); // #3226\n                this.element.setAttribute('stroke-dasharray', value);\n            }\n        },\n        ";
} 
s += "\n        alignSetter: function (value) {\n            var convert = { left: 'start', center: 'middle', right: 'end' };\n            this.element.setAttribute('text-anchor', convert[value]);\n        },\n        opacitySetter: function (value, key, element) {\n            this[key] = value;\n            element.setAttribute(key, value);\n        },\n        titleSetter: function (value) {\n            var titleNode = this.element.getElementsByTagName('title')[0];\n            if (!titleNode) {\n                titleNode = doc.createElementNS(this.SVG_NS, 'title');\n                this.element.appendChild(titleNode);\n            }\n            titleNode.appendChild(\n                doc.createTextNode(\n                    (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895\n                )\n            );\n        },\n        textSetter: function (value) {\n            if (value !== this.textStr) {\n                // Delete bBox memo when the text changes\n                delete this.bBox;\n\n                this.textStr = value;\n                if (this.added) {\n                    this.renderer.buildText(this);\n                }\n            }\n        },\n        fillSetter: function (value, key, element) {\n            if (typeof value === 'string') {\n                element.setAttribute(key, value);\n            } else if (value) {\n                this.colorGradient(value, key, element);\n            }\n        },\n        visibilitySetter: function (value, key, element) {\n            // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)\n            if (value === 'inherit') {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        },\n        zIndexSetter: function (value, key) {\n            var renderer = this.renderer,\n                parentGroup = this.parentGroup,\n                parentWrapper = parentGroup || renderer,\n                parentNode = parentWrapper.element || renderer.box,\n                childNodes,\n                otherElement,\n                otherZIndex,\n                element = this.element,\n                inserted,\n                run = this.added,\n                i;\n\n            if (defined(value)) {\n                element.setAttribute(key, value); // So we can read it for other elements in the group\n                value = +value;\n                if (this[key] === value) { // Only update when needed (#3865)\n                    run = false;\n                }\n                this[key] = value;\n            }\n\n            // Insert according to this and other elements' zIndex. Before .add() is called,\n            // nothing is done. Then on add, or by later calls to zIndexSetter, the node\n            // is placed on the right place in the DOM.\n            if (run) {\n                value = this.zIndex;\n\n                if (value && parentGroup) {\n                    parentGroup.handleZ = true;\n                }\n\n                childNodes = parentNode.childNodes;\n                for (i = 0; i < childNodes.length && !inserted; i++) {\n                    otherElement = childNodes[i];\n                    otherZIndex = attr(otherElement, 'zIndex');\n                    if (otherElement !== element && (\n                            // Insert before the first element with a higher zIndex\n                            pInt(otherZIndex) > value ||\n                            // If no zIndex given, insert before the first element with a zIndex\n                            (!defined(value) && defined(otherZIndex))\n\n                        )) {\n                        parentNode.insertBefore(element, otherElement);\n                        inserted = true;\n                    }\n                }\n                if (!inserted) {\n                    parentNode.appendChild(element);\n                }\n            }\n            return inserted;\n        },\n        _defaultSetter: function (value, key, element) {\n            element.setAttribute(key, value);\n        }\n    };\n\n    // Some shared setters and getters\n    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n    SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =\n            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =\n            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n                this[key] = value;\n                this.doTransform = true;\n            };\n\n    ";
if (build.classic) { 
s += "\n    // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n    // stroke attribute altogether. #1270, #1369, #3065, #3072.\n    SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n        this[key] = value;\n        // Only apply the stroke attribute if the stroke width is defined and larger than 0\n        if (this.stroke && this['stroke-width']) {\n            this.strokeWidth = this['stroke-width'];\n            SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n            element.setAttribute('stroke-width', this['stroke-width']);\n            this.hasStroke = true;\n        } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n            element.removeAttribute('stroke');\n            this.hasStroke = false;\n        }\n    };\n    ";
} 
s += "\n\n    /**\n     * The default SVG renderer\n     */\n    SVGRenderer = H.SVGRenderer = function () {\n        this.init.apply(this, arguments);\n    };\n    SVGRenderer.prototype = {\n        Element: SVGElement,\n        SVG_NS: SVG_NS,\n        /**\n         * Initialize the SVGRenderer\n         * @param {Object} container\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Boolean} forExport\n         */\n        init: function (container, width, height, style, forExport, allowHTML) {\n            var renderer = this,\n                boxWrapper,\n                element,\n                desc;\n\n            boxWrapper = renderer.createElement('svg')\n                .attr({\n                    'version': '1.1',\n                    'class': 'highcharts-root'\n                })\n                ";
if (build.classic) { 
s += "\n                .css(this.getStyle(style))\n                ";
} 
s += ";\n            element = boxWrapper.element;\n            container.appendChild(element);\n\n            // For browsers other than IE, add the namespace attribute (#1978)\n            if (container.innerHTML.indexOf('xmlns') === -1) {\n                attr(element, 'xmlns', this.SVG_NS);\n            }\n\n            // object properties\n            renderer.isSVG = true;\n            renderer.box = element;\n            renderer.boxWrapper = boxWrapper;\n            renderer.alignedObjects = [];\n\n            // Page url used for internal references. #24, #672, #1070\n            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n                    win.location.href\n                        .replace(/#.*?$/, '') // remove the hash\n                        .replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n                        .replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n                    '';\n\n            // Add description\n            desc = this.createElement('desc').add();\n            desc.element.appendChild(doc.createTextNode('Created with Highmaps 2.0-dev'));\n\n\n            renderer.defs = this.createElement('defs').add();\n            renderer.allowHTML = allowHTML;\n            renderer.forExport = forExport;\n            renderer.gradients = {}; // Object where gradient SvgElements are stored\n            renderer.cache = {}; // Cache for numerical bounding boxes\n            renderer.cacheKeys = [];\n\n            renderer.setSize(width, height, false);\n\n\n\n            // Issue 110 workaround:\n            // In Firefox, if a div is positioned by percentage, its pixel position may land\n            // between pixels. The container itself doesn't display this, but an SVG element\n            // inside this container will be drawn at subpixel precision. In order to draw\n            // sharp lines, this must be compensated for. This doesn't seem to work inside\n            // iframes though (like in jsFiddle).\n            var subPixelFix, rect;\n            if (isFirefox && container.getBoundingClientRect) {\n                renderer.subPixelFix = subPixelFix = function () {\n                    css(container, { left: 0, top: 0 });\n                    rect = container.getBoundingClientRect();\n                    css(container, {\n                        left: (Math.ceil(rect.left) - rect.left) + 'px',\n                        top: (Math.ceil(rect.top) - rect.top) + 'px'\n                    });\n                };\n\n                // run the fix now\n                subPixelFix();\n\n                // run it on resize\n                addEvent(win, 'resize', subPixelFix);\n            }\n        },\n        ";
if (build.classic) { 
s += "\n        getStyle: function (style) {\n            this.style = extend({\n            \n                fontFamily: '___doublequote___Lucida Grande___doublequote___, ___doublequote___Lucida Sans Unicode___doublequote___, Arial, Helvetica, sans-serif', // default font\n                fontSize: '12px'\n\n            }, style);\n            return this.style;\n        },\n        ";
} 
s += "\n\n        /**\n         * Detect whether the renderer is hidden. This happens when one of the parent elements\n         * has display: none. #608.\n         */\n        isHidden: function () {\n            return !this.boxWrapper.getBBox().width;\n        },\n\n        /**\n         * Destroys the renderer and its allocated members.\n         */\n        destroy: function () {\n            var renderer = this,\n                rendererDefs = renderer.defs;\n            renderer.box = null;\n            renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n            // Call destroy on all gradient elements\n            destroyObjectProperties(renderer.gradients || {});\n            renderer.gradients = null;\n\n            // Defs are null in VMLRenderer\n            // Otherwise, destroy them here.\n            if (rendererDefs) {\n                renderer.defs = rendererDefs.destroy();\n            }\n\n            // Remove sub pixel fix handler\n            // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n            // See issue #982\n            if (renderer.subPixelFix) {\n                removeEvent(win, 'resize', renderer.subPixelFix);\n            }\n\n            renderer.alignedObjects = null;\n\n            return null;\n        },\n\n        /**\n         * Create a wrapper for an SVG element\n         * @param {Object} nodeName\n         */\n        createElement: function (nodeName) {\n            var wrapper = new this.Element();\n            wrapper.init(this, nodeName);\n            return wrapper;\n        },\n\n        /**\n         * Dummy function for use in canvas renderer\n         */\n        draw: noop,\n\n        /**\n         * Get converted radial gradient attributes\n         */\n        getRadialAttr: function (radialReference, gradAttr) {\n            return {\n                cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n                cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n                r: gradAttr.r * radialReference[2]\n            };\n        },\n\n        /**\n         * Parse a simple HTML string into SVG tspans\n         *\n         * @param {Object} textNode The parent text SVG node\n         */\n        buildText: function (wrapper) {\n            var textNode = wrapper.element,\n                renderer = this,\n                forExport = renderer.forExport,\n                textStr = pick(wrapper.textStr, '').toString(),\n                hasMarkup = textStr.indexOf('<') !== -1,\n                lines,\n                childNodes = textNode.childNodes,\n                styleRegex,\n                hrefRegex,\n                parentX = attr(textNode, 'x'),\n                textStyles = wrapper.styles,\n                width = wrapper.textWidth,\n                textLineHeight = textStyles && textStyles.lineHeight,\n                textShadow = textStyles && textStyles.textShadow,\n                ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n                i = childNodes.length,\n                tempParent = width && !wrapper.added && this.box,\n                getLineHeight = function (tspan) {\n                    var fontSizeStyle;\n                    ";
if (build.classic) { 
s += "\n                    fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n                        tspan.style.fontSize :\n                        ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12);\n                    ";
} 
s += "\n\n                    return textLineHeight ? \n                        pInt(textLineHeight) :\n                        renderer.fontMetrics(\n                            fontSizeStyle,\n                            tspan\n                        ).h;\n                },\n                unescapeAngleBrackets = function (inputStr) {\n                    return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n                };\n\n            /// remove old text\n            while (i--) {\n                textNode.removeChild(childNodes[i]);\n            }\n\n            // Skip tspans, add text directly to text node. The forceTSpan is a hook\n            // used in text outline hack.\n            if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {\n                textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\n            // Complex strings, add more logic\n            } else {\n\n                styleRegex = /<.*style=___doublequote___([^___doublequote___]+)___doublequote___.*>/;\n                hrefRegex = /<.*href=___doublequote___(http[^___doublequote___]+)___doublequote___.*>/;\n\n                if (tempParent) {\n                    tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n                }\n\n                if (hasMarkup) {\n                    lines = textStr\n                        .replace(/<(b|strong)>/g, '<span style=___doublequote___font-weight:bold___doublequote___>')\n                        .replace(/<(i|em)>/g, '<span style=___doublequote___font-style:italic___doublequote___>')\n                        .replace(/<a/g, '<span')\n                        .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                        .split(/<br.*?>/g);\n\n                } else {\n                    lines = [textStr];\n                }\n\n\n                // remove empty line at end\n                if (lines[lines.length - 1] === '') {\n                    lines.pop();\n                }\n\n\n                // build the lines\n                each(lines, function (line, lineNo) {\n                    var spans, spanNo = 0;\n\n                    line = line.replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n                    spans = line.split('|||');\n\n                    each(spans, function (span) {\n                        if (span !== '' || spans.length === 1) {\n                            var attributes = {},\n                                tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),\n                                spanStyle; // #390\n                            if (styleRegex.test(span)) {\n                                spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n                                attr(tspan, 'style', spanStyle);\n                            }\n                            if (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n                                attr(tspan, 'onclick', 'location.href=\\___doublequote___' + span.match(hrefRegex)[1] + '\\___doublequote___');\n                                css(tspan, { cursor: 'pointer' });\n                            }\n\n                            span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n                            // Nested tags aren't supported, and cause crash in Safari (#1596)\n                            if (span !== ' ') {\n\n                                // add the text node\n                                tspan.appendChild(doc.createTextNode(span));\n\n                                if (!spanNo) { // first span in a line, align it to the left\n                                    if (lineNo && parentX !== null) {\n                                        attributes.x = parentX;\n                                    }\n                                } else {\n                                    attributes.dx = 0; // #16\n                                }\n\n                                // add attributes\n                                attr(tspan, attributes);\n\n                                // Append it\n                                textNode.appendChild(tspan);\n\n                                // first span on subsequent line, add the line height\n                                if (!spanNo && lineNo) {\n\n                                    // allow getting the right offset height in exporting in IE\n                                    if (!svg && forExport) {\n                                        css(tspan, { display: 'block' });\n                                    }\n\n                                    // Set the line height based on the font size of either\n                                    // the text element or the tspan element\n                                    attr(\n                                        tspan,\n                                        'dy',\n                                        getLineHeight(tspan)\n                                    );\n                                }\n\n                                /*if (width) {\n                                    renderer.breakText(wrapper, width);\n                                }*/\n\n                                // Check width and apply soft breaks or ellipsis\n                                if (width) {\n                                    var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n                                        hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),\n                                        tooLong,\n                                        wasTooLong,\n                                        actualWidth,\n                                        rest = [],\n                                        dy = getLineHeight(tspan),\n                                        rotation = wrapper.rotation,\n                                        wordStr = span, // for ellipsis\n                                        cursor = wordStr.length, // binary search cursor\n                                        bBox;\n\n                                    while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n                                        wrapper.rotation = 0; // discard rotation when computing box\n                                        bBox = wrapper.getBBox(true);\n                                        actualWidth = bBox.width;\n\n                                        // Old IE cannot measure the actualWidth for SVG elements (#2314)\n                                        if (!svg && renderer.forExport) {\n                                            actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n                                        }\n\n                                        tooLong = actualWidth > width;\n\n                                        // For ellipsis, do a binary search for the correct string length\n                                        if (wasTooLong === undefined) {\n                                            wasTooLong = tooLong; // First time\n                                        }\n                                        if (ellipsis && wasTooLong) {\n                                            cursor /= 2;\n\n                                            if (wordStr === '' || (!tooLong && cursor < 0.5)) {\n                                                words = []; // All ok, break out\n                                            } else {\n                                                if (tooLong) {\n                                                    wasTooLong = true;\n                                                }\n\n                                                wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * Math.ceil(cursor));\n                                                words = [wordStr + (width > 3 ? '\\u2026' : '')];\n                                                tspan.removeChild(tspan.firstChild);\n                                            }\n\n                                        // Looping down, this is the first word sequence that is not too long,\n                                        // so we can move on to build the next line.\n                                        } else if (!tooLong || words.length === 1) {\n                                            words = rest;\n                                            rest = [];\n\n                                            if (words.length) {\n                                            \n                                                tspan = doc.createElementNS(renderer.SVG_NS, 'tspan');\n                                                attr(tspan, {\n                                                    dy: dy,\n                                                    x: parentX\n                                                });\n                                                if (spanStyle) { // #390\n                                                    attr(tspan, 'style', spanStyle);\n                                                }\n                                                textNode.appendChild(tspan);\n                                            }\n                                            if (actualWidth > width) { // a single word is pressing it out\n                                                width = actualWidth;\n                                            }\n                                        } else { // append to existing line tspan\n                                            tspan.removeChild(tspan.firstChild);\n                                            rest.unshift(words.pop());\n                                        }\n                                        if (words.length) {\n                                            tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                                        }\n                                    }\n                                    if (wasTooLong) {\n                                        wrapper.attr('title', wrapper.textStr);\n                                    }\n                                    wrapper.rotation = rotation;\n                                }\n\n                                spanNo++;\n                            }\n                        }\n                    });\n                });\n                if (tempParent) {\n                    tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n                }\n\n                // Apply the text shadow\n                if (textShadow && wrapper.applyTextShadow) {\n                    wrapper.applyTextShadow(textShadow);\n                }\n            }\n        },\n\n\n\n        /*\n        breakText: function (wrapper, width) {\n            var bBox = wrapper.getBBox(),\n                node = wrapper.element,\n                textLength = node.textContent.length,\n                pos = Math.round(width * textLength / bBox.width), // try this position first, based on average character width\n                increment = 0,\n                finalPos;\n\n            if (bBox.width > width) {\n                while (finalPos === undefined) {\n                    textLength = node.getSubStringLength(0, pos);\n\n                    if (textLength <= width) {\n                        if (increment === -1) {\n                            finalPos = pos;\n                        } else {\n                            increment = 1;\n                        }\n                    } else {\n                        if (increment === 1) {\n                            finalPos = pos - 1;\n                        } else {\n                            increment = -1;\n                        }\n                    }\n                    pos += increment;\n                }\n            }\n            console.log(finalPos, node.getSubStringLength(0, finalPos))\n        },\n        */\n\n        /**\n         * Returns white for dark colors and black for bright colors\n         */\n        getContrast: function (color) {\n            color = Color(color).rgba;\n            return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';\n        },\n\n        /**\n         * Create a button with preset states\n         * @param {String} text\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Function} callback\n         * @param {Object} normalState\n         * @param {Object} hoverState\n         * @param {Object} pressedState\n         */\n        button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n            var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n                curState = 0,\n                stateOptions,\n                stateStyle,\n                normalStyle,\n                hoverStyle,\n                pressedStyle,\n                disabledStyle,\n                verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n            // Normal state - prepare the attributes\n            normalState = merge({\n                'stroke-width': 1,\n                stroke: '#CCCCCC',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#FEFEFE'],\n                        [1, '#F6F6F6']\n                    ]\n                },\n                r: 2,\n                padding: 5,\n                style: {\n                    color: 'black'\n                }\n            }, normalState);\n            normalStyle = normalState.style;\n            delete normalState.style;\n\n            // Hover state\n            hoverState = merge(normalState, {\n                stroke: '#68A',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#FFF'],\n                        [1, '#ACF']\n                    ]\n                }\n            }, hoverState);\n            hoverStyle = hoverState.style;\n            delete hoverState.style;\n\n            // Pressed state\n            pressedState = merge(normalState, {\n                stroke: '#68A',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#9BD'],\n                        [1, '#CDF']\n                    ]\n                }\n            }, pressedState);\n            pressedStyle = pressedState.style;\n            delete pressedState.style;\n\n            // Disabled state\n            disabledState = merge(normalState, {\n                style: {\n                    color: '#CCC'\n                }\n            }, disabledState);\n            disabledStyle = disabledState.style;\n            delete disabledState.style;\n\n            // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n            addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n                if (curState !== 3) {\n                    label.attr(hoverState)\n                        .css(hoverStyle);\n                }\n            });\n            addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n                if (curState !== 3) {\n                    stateOptions = [normalState, hoverState, pressedState];\n                    stateOptions = stateOptions[curState];\n                    stateStyle = [normalStyle, hoverStyle, pressedStyle];\n                    stateStyle = stateStyle[curState];\n                    label.attr(stateOptions)\n                        .css(stateStyle);\n                }\n            });\n\n            label.setState = function (state) {\n                label.state = curState = state;\n                if (!state) {\n                    label.attr(normalState)\n                        .css(normalStyle);\n                } else if (state === 2) {\n                    label.attr(pressedState)\n                        .css(pressedStyle);\n                } else if (state === 3) {\n                    label.attr(disabledState)\n                        .css(disabledStyle);\n                }\n            };\n\n            return label\n                .on('click', function (e) {\n                    if (curState !== 3) {\n                        callback.call(label, e);\n                    }\n                })\n                .attr(normalState)\n                .css(extend({ cursor: 'default' }, normalStyle));\n        },\n\n        /**\n         * Make a straight line crisper by not spilling out to neighbour pixels\n         * @param {Array} points\n         * @param {Number} width\n         */\n        crispLine: function (points, width) {\n            // points format: ['M', 0, 0, 'L', 100, 0]\n            // normalize to a crisp line\n            if (points[1] === points[4]) {\n                // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n            }\n            if (points[2] === points[5]) {\n                points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n            }\n            return points;\n        },\n\n\n        /**\n         * Draw a path\n         * @param {Array} path An SVG path in array form\n         */\n        path: function (path) {\n            var attribs = {\n                ";
if (build.classic) { 
s += "\n                fill: 'none'\n                ";
} 
s += "\n            };\n            if (isArray(path)) {\n                attribs.d = path;\n            } else if (isObject(path)) { // attributes\n                extend(attribs, path);\n            }\n            return this.createElement('path').attr(attribs);\n        },\n\n        /**\n         * Draw and return an SVG circle\n         * @param {Number} x The x position\n         * @param {Number} y The y position\n         * @param {Number} r The radius\n         */\n        circle: function (x, y, r) {\n            var attribs = isObject(x) ? x : { x: x, y: y, r: r },\n                wrapper = this.createElement('circle');\n\n            // Setting x or y translates to cx and cy\n            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n                element.setAttribute('c' + key, value);\n            };\n\n            return wrapper.attr(attribs);\n        },\n\n        /**\n         * Draw and return an arc\n         * @param {Number} x X position\n         * @param {Number} y Y position\n         * @param {Number} r Radius\n         * @param {Number} innerR Inner radius like used in donut charts\n         * @param {Number} start Starting angle\n         * @param {Number} end Ending angle\n         */\n        arc: function (x, y, r, innerR, start, end) {\n            var arc;\n\n            if (isObject(x)) {\n                y = x.y;\n                r = x.r;\n                innerR = x.innerR;\n                start = x.start;\n                end = x.end;\n                x = x.x;\n            }\n\n            // Arcs are defined as symbols for the ability to set\n            // attributes in attr and animate\n            arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n                innerR: innerR || 0,\n                start: start || 0,\n                end: end || 0\n            });\n            arc.r = r; // #959\n            return arc;\n        },\n\n        /**\n         * Draw and return a rectangle\n         * @param {Number} x Left position\n         * @param {Number} y Top position\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Number} r Border corner radius\n         * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n         */\n        rect: function (x, y, width, height, r, strokeWidth) {\n\n            r = isObject(x) ? x.r : r;\n\n            var wrapper = this.createElement('rect'),\n                attribs = isObject(x) ? x : x === undefined ? {} : {\n                    x: x,\n                    y: y,\n                    width: Math.max(width, 0),\n                    height: Math.max(height, 0)\n                };\n\n            ";
if (build.classic) { 
s += "\n            if (strokeWidth !== undefined) {\n                attribs.strokeWidth = strokeWidth;\n                attribs = wrapper.crisp(attribs);\n            }\n            attribs.fill = 'none';\n            ";
} 
s += "\n\n            if (r) {\n                attribs.r = r;\n            }\n\n            wrapper.rSetter = function (value) {\n                attr(this.element, {\n                    rx: value,\n                    ry: value\n                });\n            };\n\n            return wrapper.attr(attribs);\n        },\n\n        /**\n         * Resize the box and re-align all aligned elements\n         * @param {Object} width\n         * @param {Object} height\n         * @param {Boolean} animate\n         *\n         */\n        setSize: function (width, height, animate) {\n            var renderer = this,\n                alignedObjects = renderer.alignedObjects,\n                i = alignedObjects.length;\n\n            renderer.width = width;\n            renderer.height = height;\n\n            /* = if (build.classic) { = */\n            renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n                width: width,\n                height: height\n            });\n            /* = } = */\n            renderer.boxWrapper.attr({\n                viewBox: '0 0 ' + width + ' ' + height\n            });\n\n            while (i--) {\n                alignedObjects[i].align();\n            }\n        },\n\n        /**\n         * Create a group\n         * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n         *     This can be used for styling and scripting.\n         */\n        g: function (name) {\n            var elem = this.createElement('g');\n            return defined(name) ? elem.attr({ 'class': 'highcharts-' + name }) : elem;\n        },\n\n        /**\n         * Display an image\n         * @param {String} src\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        image: function (src, x, y, width, height) {\n            var attribs = {\n                    preserveAspectRatio: 'none'\n                },\n                elemWrapper;\n\n            // optional properties\n            if (arguments.length > 1) {\n                extend(attribs, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n\n            elemWrapper = this.createElement('image').attr(attribs);\n\n            // set the href in the xlink namespace\n            if (elemWrapper.element.setAttributeNS) {\n                elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n                    'href', src);\n            } else {\n                // could be exporting in IE\n                // using href throws ___doublequote___not supported___doublequote___ in ie7 and under, requries regex shim to fix later\n                elemWrapper.element.setAttribute('hc-svg-href', src);\n            }\n            return elemWrapper;\n        },\n\n        /**\n         * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n         *\n         * @param {Object} symbol\n         * @param {Object} x\n         * @param {Object} y\n         * @param {Object} radius\n         * @param {Object} options\n         */\n        symbol: function (symbol, x, y, width, height, options) {\n\n            var obj,\n\n                // get the symbol definition function\n                symbolFn = this.symbols[symbol],\n\n                // check if there's a path defined for this symbol\n                path = defined(x) && symbolFn && symbolFn(\n                    Math.round(x),\n                    Math.round(y),\n                    width,\n                    height,\n                    options\n                ),\n\n                imageRegex = /^url\\((.*?)\\)$/,\n                imageSrc,\n                centerImage,\n                symbolSizes = {};\n\n            if (symbolFn) {\n                obj = this.path(path);\n\n                ";
if (build.classic) { 
s += "\n                obj.attr('fill', 'none');\n                ";
} 
s += "\n            \n                // expando properties for use in animate and attr\n                extend(obj, {\n                    symbolName: symbol,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n                if (options) {\n                    extend(obj, options);\n                }\n\n\n            // image symbols\n            } else if (imageRegex.test(symbol)) {\n\n            \n                imageSrc = symbol.match(imageRegex)[1];\n\n                // Create the image synchronously, add attribs async\n                obj = this.image(imageSrc);\n\n                // The image width is not always the same as the symbol width. The image may be centered within the symbol,\n                // as is the case when image shapes are used as label backgrounds, for example in flags.\n                obj.imgWidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);\n                obj.imgHeight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);\n\n                /**\n                 * Set the size and position\n                 */\n                centerImage = function () {\n                    obj.attr({\n                        width: obj.width,\n                        height: obj.height\n                    });\n                };\n\n                /**\n                 * Width and height setters that take both the image's physical size and the label size into \n                 * consideration, and translates the image to center within the label.\n                 */\n                each(['width', 'height'], function (key) {\n                    obj[key + 'Setter'] = function (value, key) {\n                        var attribs = {},\n                            imgSize = this['img' + key];\n                        this[key] = value;\n                        if (defined(imgSize)) {\n                            if (this.element) {\n                                this.element.setAttribute(key, imgSize);\n                            }\n                            if (!this.alignByTranslate) {\n                                attribs[key === 'width' ? 'translateX' : 'translateY'] = (this[key] - imgSize) / 2;\n                                this.attr(attribs);\n                            }\n                        }\n                    };\n                });\n            \n\n                if (defined(x)) {\n                    obj.attr({\n                        x: x,\n                        y: y\n                    });\n                }\n                obj.isImg = true;\n\n                if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n                    centerImage();\n                } else {\n                    // Initialize image to be 0 size so export will still function if there's no cached sizes.\n                    obj.attr({ width: 0, height: 0 });\n\n                    // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n                    // the created element must be assigned to a variable in order to load (#292).\n                    createElement('img', {\n                        onload: function () {\n\n                            // Special case for SVGs on IE11, the width is not accessible until the image is \n                            // part of the DOM (#2854).\n                            if (this.width === 0) {\n                                css(this, {\n                                    position: 'absolute',\n                                    top: '-999em'\n                                });\n                                doc.body.appendChild(this);\n                            }\n\n                            // Center the image\n                            centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\n                            // Clean up after #2854 workaround.\n                            if (this.parentNode) {\n                                this.parentNode.removeChild(this);\n                            }\n                        },\n                        src: imageSrc\n                    });\n                }\n            }\n\n            return obj;\n        },\n\n        /**\n         * An extendable collection of functions for defining symbol paths.\n         */\n        symbols: {\n            'circle': function (x, y, w, h) {\n                var cpw = 0.166 * w;\n                return [\n                    'M', x + w / 2, y,\n                    'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n                    'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n                    'Z'\n                ];\n            },\n\n            'square': function (x, y, w, h) {\n                return [\n                    'M', x, y,\n                    'L', x + w, y,\n                    x + w, y + h,\n                    x, y + h,\n                    'Z'\n                ];\n            },\n\n            'triangle': function (x, y, w, h) {\n                return [\n                    'M', x + w / 2, y,\n                    'L', x + w, y + h,\n                    x, y + h,\n                    'Z'\n                ];\n            },\n\n            'triangle-down': function (x, y, w, h) {\n                return [\n                    'M', x, y,\n                    'L', x + w, y,\n                    x + w / 2, y + h,\n                    'Z'\n                ];\n            },\n            'diamond': function (x, y, w, h) {\n                return [\n                    'M', x + w / 2, y,\n                    'L', x + w, y + h / 2,\n                    x + w / 2, y + h,\n                    x, y + h / 2,\n                    'Z'\n                ];\n            },\n            'arc': function (x, y, w, h, options) {\n                var start = options.start,\n                    radius = options.r || w || h,\n                    end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n                    innerRadius = options.innerR,\n                    open = options.open,\n                    cosStart = Math.cos(start),\n                    sinStart = Math.sin(start),\n                    cosEnd = Math.cos(end),\n                    sinEnd = Math.sin(end),\n                    longArc = options.end - start < Math.PI ? 0 : 1;\n\n                return [\n                    'M',\n                    x + radius * cosStart,\n                    y + radius * sinStart,\n                    'A', // arcTo\n                    radius, // x radius\n                    radius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    1, // clockwise\n                    x + radius * cosEnd,\n                    y + radius * sinEnd,\n                    open ? 'M' : 'L',\n                    x + innerRadius * cosEnd,\n                    y + innerRadius * sinEnd,\n                    'A', // arcTo\n                    innerRadius, // x radius\n                    innerRadius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    0, // clockwise\n                    x + innerRadius * cosStart,\n                    y + innerRadius * sinStart,\n\n                    open ? '' : 'Z' // close\n                ];\n            },\n\n            /**\n             * Callout shape used for default tooltips, also used for rounded rectangles in VML\n             */\n            callout: function (x, y, w, h, options) {\n                var arrowLength = 6,\n                    halfDistance = 6,\n                    r = Math.min((options && options.r) || 0, w, h),\n                    safeDistance = r + halfDistance,\n                    anchorX = options && options.anchorX,\n                    anchorY = options && options.anchorY,\n                    path;\n\n                path = [\n                    'M', x + r, y,\n                    'L', x + w - r, y, // top side\n                    'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                    'L', x + w, y + h - r, // right side\n                    'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n                    'L', x + r, y + h, // bottom side\n                    'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                    'L', x, y + r, // left side\n                    'C', x, y, x, y, x + r, y // top-right corner\n                ];\n\n                if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n                    path.splice(13, 3,\n                        'L', x + w, anchorY - halfDistance,\n                        x + w + arrowLength, anchorY,\n                        x + w, anchorY + halfDistance,\n                        x + w, y + h - r\n                        );\n                } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n                    path.splice(33, 3,\n                        'L', x, anchorY + halfDistance,\n                        x - arrowLength, anchorY,\n                        x, anchorY - halfDistance,\n                        x, y + r\n                        );\n                } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n                    path.splice(23, 3,\n                        'L', anchorX + halfDistance, y + h,\n                        anchorX, y + h + arrowLength,\n                        anchorX - halfDistance, y + h,\n                        x + r, y + h\n                        );\n                } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n                    path.splice(3, 3,\n                        'L', anchorX - halfDistance, y,\n                        anchorX, y - arrowLength,\n                        anchorX + halfDistance, y,\n                        w - r, y\n                        );\n                }\n                return path;\n            }\n        },\n\n        /**\n         * Define a clipping rectangle\n         * @param {String} id\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        clipRect: function (x, y, width, height) {\n            var wrapper,\n                id = 'highcharts-' + H.idCounter++,\n\n                clipPath = this.createElement('clipPath').attr({\n                    id: id\n                }).add(this.defs);\n\n            wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n            wrapper.id = id;\n            wrapper.clipPath = clipPath;\n            wrapper.count = 0;\n\n            return wrapper;\n        },\n\n\n\n\n\n        /**\n         * Add text to the SVG object\n         * @param {String} str\n         * @param {Number} x Left position\n         * @param {Number} y Top position\n         * @param {Boolean} useHTML Use HTML to render the text\n         */\n        text: function (str, x, y, useHTML) {\n\n            // declare variables\n            var renderer = this,\n                fakeSVG = useCanVG || (!svg && renderer.forExport),\n                wrapper,\n                attribs = {};\n\n            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n                return renderer.html(str, x, y);\n            }\n\n            attribs.x = Math.round(x || 0); // X is always needed for line-wrap logic\n            if (y) {\n                attribs.y = Math.round(y);\n            }\n            if (str || str === 0) {\n                attribs.text = str;\n            }\n\n            wrapper = renderer.createElement('text')\n                .attr(attribs);\n\n            // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n            if (fakeSVG) {\n                wrapper.css({\n                    position: 'absolute'\n                });\n            }\n\n            if (!useHTML) {\n                wrapper.xSetter = function (value, key, element) {\n                    var tspans = element.getElementsByTagName('tspan'),\n                        tspan,\n                        parentVal = element.getAttribute(key),\n                        i;\n                    for (i = 0; i < tspans.length; i++) {\n                        tspan = tspans[i];\n                        // If the x values are equal, the tspan represents a linebreak\n                        if (tspan.getAttribute(key) === parentVal) {\n                            tspan.setAttribute(key, value);\n                        }\n                    }\n                    element.setAttribute(key, value);\n                };\n            }\n\n            return wrapper;\n        },\n\n        /**\n         * Utility to return the baseline offset and total line height from the font size\n         */\n        fontMetrics: function (fontSize, elem) { // eslint-disable-line no-unused-vars\n            var lineHeight,\n                baseline;\n\n            ";
if (build.classic) { 
s += "\n            fontSize = fontSize || (this.style && this.style.fontSize);\n            ";
} else { 
s += "\n            fontSize = elem && SVGElement.prototype.getStyle.call(elem, 'font-size');\n            ";
} 
s += "\n\n            fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n            // Empirical values found by comparing font size and bounding box height.\n            // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n            lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n            baseline = Math.round(lineHeight * 0.8);\n\n            return {\n                h: lineHeight,\n                b: baseline,\n                f: fontSize\n            };\n        },\n\n        /**\n         * Correct X and Y positioning of a label for rotation (#1764)\n         */\n        rotCorr: function (baseline, rotation, alterY) {\n            var y = baseline;\n            if (rotation && alterY) {\n                y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n            }\n            return {\n                x: (-baseline / 3) * Math.sin(rotation * deg2rad),\n                y: y\n            };\n        },\n\n        /**\n         * Add a label, a text item that can hold a colored or gradient background\n         * as well as a border and shadow.\n         * @param {string} str\n         * @param {Number} x\n         * @param {Number} y\n         * @param {String} shape\n         * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n         *    coordinates it should be pinned to\n         * @param {Number} anchorY\n         * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n         *    like renderer.text, or to the upper border of the rectangle.\n         * @param {String} className Class name for the group\n         */\n        label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n            var renderer = this,\n                wrapper = renderer.g(className),\n                text = renderer.text('', 0, 0, useHTML)\n                    .attr({\n                        zIndex: 1\n                    }),\n                box,\n                bBox,\n                alignFactor = 0,\n                padding = 3,\n                paddingLeft = 0,\n                width,\n                height,\n                wrapperX,\n                wrapperY,\n                deferredAttr = {},\n                strokeWidth,\n                baselineOffset,\n                needsBox,\n                getCrispAdjust,\n                updateBoxSize,\n                updateTextPadding,\n                boxAttr;\n\n            ";
if (!build.classic) { 
s += "\n            needsBox = true; // for styling\n            getCrispAdjust = function () {\n                return box.pxStyle('stroke-width') % 2 / 2;\n            };\n            ";
} else { 
s += "\n            needsBox = false;\n            getCrispAdjust = function () {\n                return (strokeWidth || 0) % 2 / 2;\n            };\n\n            ";
} 
s += "\n\n            /**\n             * This function runs after the label is added to the DOM (when the bounding box is\n             * available), and after the text of the label is updated to detect the new bounding\n             * box and reflect it in the border box.\n             */\n            updateBoxSize = function () {\n                var style = text.element.style,\n                    crispAdjust,\n                    attribs = {};\n\n                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) &&\n                    text.getBBox(); //#3295 && 3514 box failure when string equals 0\n                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n                wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n                // Update the label-scoped y offset\n                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\n                if (needsBox) {\n\n                    // Create the border box if it is not already present\n                    if (!box) {\n                        wrapper.box = box = shape ?\n                            renderer.symbol(shape) :\n                            renderer.rect();\n                        if (className) {\n                            box.addClass('highcharts-' + className + '-box');\n                        }\n\n                        box.add(wrapper);\n\n                        crispAdjust = getCrispAdjust();\n                        attribs.x = Math.round(-alignFactor * padding) + crispAdjust;\n                        attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n                    }\n\n                    // Apply the box attributes\n                    attribs.width = Math.round(wrapper.width);\n                    attribs.height = Math.round(wrapper.height);\n                \n                    box.attr(extend(attribs, deferredAttr));\n                    deferredAttr = {};\n                }\n            };\n\n            /**\n             * This function runs after setting text or padding, but only if padding is changed\n             */\n            updateTextPadding = function () {\n                var styles = wrapper.styles,\n                    textAlign = styles && styles.textAlign,\n                    textX = paddingLeft + padding,\n                    textY;\n\n                // determin y based on the baseline\n                textY = baseline ? 0 : baselineOffset;\n\n                // compensate for alignment\n                if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n                    textX += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n                }\n\n                // update if anything changed\n                if (textX !== text.x || textY !== text.y) {\n                    text.attr('x', textX);\n                    if (textY !== undefined) {\n                        text.attr('y', textY);\n                    }\n                }\n\n                // record current values\n                text.x = textX;\n                text.y = textY;\n            };\n\n            /**\n             * Set a box attribute, or defer it if the box is not yet created\n             * @param {Object} key\n             * @param {Object} value\n             */\n            boxAttr = function (key, value) {\n                if (box) {\n                    box.attr(key, value);\n                } else {\n                    deferredAttr[key] = value;\n                }\n            };\n\n            /**\n             * After the text element is added, get the desired size of the border box\n             * and add it before the text in the DOM.\n             */\n            wrapper.onAdd = function () {\n                text.add(wrapper);\n                wrapper.attr({\n                    text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n                    x: x,\n                    y: y\n                });\n\n                if (box && defined(anchorX)) {\n                    wrapper.attr({\n                        anchorX: anchorX,\n                        anchorY: anchorY\n                    });\n                }\n            };\n\n            /*\n             * Add specific attribute setters.\n             */\n\n            // only change local variables\n            wrapper.widthSetter = function (value) {\n                width = value;\n            };\n            wrapper.heightSetter = function (value) {\n                height = value;\n            };\n            wrapper.paddingSetter =  function (value) {\n                if (defined(value) && value !== padding) {\n                    padding = wrapper.padding = value;\n                    updateTextPadding();\n                }\n            };\n            wrapper.paddingLeftSetter =  function (value) {\n                if (defined(value) && value !== paddingLeft) {\n                    paddingLeft = value;\n                    updateTextPadding();\n                }\n            };\n\n\n            // change local variable and prevent setting attribute on the group\n            wrapper.alignSetter = function (value) {\n                value = { left: 0, center: 0.5, right: 1 }[value];\n                if (value !== alignFactor) {\n                    alignFactor = value;\n                    if (bBox) { // Bounding box exists, means we're dynamically changing\n                        wrapper.attr({ x: x });\n                    }\n                }\n            };\n\n            // apply these to the box and the text alike\n            wrapper.textSetter = function (value) {\n                if (value !== undefined) {\n                    text.textSetter(value);\n                }\n                updateBoxSize();\n                updateTextPadding();\n            };\n\n            // apply these to the box but not to the text\n            wrapper['stroke-widthSetter'] = function (value, key) {\n                if (value) {\n                    needsBox = true;\n                }\n                strokeWidth = value;\n                boxAttr(key, value);\n            };\n            ";
if (!build.classic) { 
s += "\n            wrapper.rSetter = function (value, key) {\n                boxAttr(key, value);\n            };\n            ";
} else { 
s += "\n            wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n                if (key === 'fill' && value) {\n                    needsBox = true;\n                }\n                boxAttr(key, value);\n            };\n            ";
} 
s += "\n            wrapper.anchorXSetter = function (value, key) {\n                anchorX = value;\n                boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n            };\n            wrapper.anchorYSetter = function (value, key) {\n                anchorY = value;\n                boxAttr(key, value - wrapperY);\n            };\n\n            // rename attributes\n            wrapper.xSetter = function (value) {\n                wrapper.x = value; // for animation getter\n                if (alignFactor) {\n                    value -= alignFactor * ((width || bBox.width) + 2 * padding);\n                }\n                wrapperX = Math.round(value);\n                wrapper.attr('translateX', wrapperX);\n            };\n            wrapper.ySetter = function (value) {\n                wrapperY = wrapper.y = Math.round(value);\n                wrapper.attr('translateY', wrapperY);\n            };\n\n            // Redirect certain methods to either the box or the text\n            var baseCss = wrapper.css;\n            return extend(wrapper, {\n                /**\n                 * Pick up some properties and apply them to the text instead of the wrapper\n                 */\n                css: function (styles) {\n                    if (styles) {\n                        var textStyles = {};\n                        styles = merge(styles); // create a copy to avoid altering the original object (#537)\n                        each(wrapper.textProps, function (prop) {\n                            if (styles[prop] !== undefined) {\n                                textStyles[prop] = styles[prop];\n                                delete styles[prop];\n                            }\n                        });\n                        text.css(textStyles);\n                    }\n                    return baseCss.call(wrapper, styles);\n                },\n                /**\n                 * Return the bounding box of the box, not the group\n                 */\n                getBBox: function () {\n                    return {\n                        width: bBox.width + 2 * padding,\n                        height: bBox.height + 2 * padding,\n                        x: bBox.x - padding,\n                        y: bBox.y - padding\n                    };\n                },\n                /**\n                 * Apply the shadow to the box\n                 */\n                shadow: function (b) {\n                    updateBoxSize();\n                    if (box) {\n                        box.shadow(b);\n                    }\n                    return wrapper;\n                },\n                /**\n                 * Destroy and release memory.\n                 */\n                destroy: function () {\n                \n                    // Added by button implementation\n                    removeEvent(wrapper.element, 'mouseenter');\n                    removeEvent(wrapper.element, 'mouseleave');\n\n                    if (text) {\n                        text = text.destroy();\n                    }\n                    if (box) {\n                        box = box.destroy();\n                    }\n                    // Call base implementation to destroy the rest\n                    SVGElement.prototype.destroy.call(wrapper);\n\n                    // Release local pointers (#1298)\n                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n                }\n            });\n        }\n    }; // end SVGRenderer\n\n\n    // general renderer\n    H.Renderer = SVGRenderer;\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var attr = H.attr,\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            isFirefox = H.isFirefox,\n            isMS = H.isMS,\n            isWebKit = H.isWebKit,\n            pick = H.pick,\n            pInt = H.pInt,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer,\n            win = H.win,\n            wrap = H.wrap;\n\n    // extend SvgElement for useHTML option\n    extend(SVGElement.prototype, {\n        /**\n         * Apply CSS to HTML elements. This is used in text within SVG rendering and\n         * by the VML renderer\n         */\n        htmlCss: function (styles) {\n            var wrapper = this,\n                element = wrapper.element,\n                textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n            if (textWidth) {\n                delete styles.width;\n                wrapper.textWidth = textWidth;\n                wrapper.updateTransform();\n            }\n            if (styles && styles.textOverflow === 'ellipsis') {\n                styles.whiteSpace = 'nowrap';\n                styles.overflow = 'hidden';\n            }\n            wrapper.styles = extend(wrapper.styles, styles);\n            css(wrapper.element, styles);\n\n            return wrapper;\n        },\n\n        /**\n         * VML and useHTML method for calculating the bounding box based on offsets\n         * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n         * use the cached value\n         *\n         * @return {Object} A hash containing values for x, y, width and height\n         */\n\n        htmlGetBBox: function () {\n            var wrapper = this,\n                element = wrapper.element;\n\n            // faking getBBox in exported SVG in legacy IE\n            // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n            if (element.nodeName === 'text') {\n                element.style.position = 'absolute';\n            }\n\n            return {\n                x: element.offsetLeft,\n                y: element.offsetTop,\n                width: element.offsetWidth,\n                height: element.offsetHeight\n            };\n        },\n\n        /**\n         * VML override private method to update elements based on internal\n         * properties based on SVG transform\n         */\n        htmlUpdateTransform: function () {\n            // aligning non added elements is expensive\n            if (!this.added) {\n                this.alignOnAdd = true;\n                return;\n            }\n\n            var wrapper = this,\n                renderer = wrapper.renderer,\n                elem = wrapper.element,\n                translateX = wrapper.translateX || 0,\n                translateY = wrapper.translateY || 0,\n                x = wrapper.x || 0,\n                y = wrapper.y || 0,\n                align = wrapper.textAlign || 'left',\n                alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n                shadows = wrapper.shadows,\n                styles = wrapper.styles;\n\n            // apply translate\n            css(elem, {\n                marginLeft: translateX,\n                marginTop: translateY\n            });\n            if (shadows) { // used in labels/tooltip\n                each(shadows, function (shadow) {\n                    css(shadow, {\n                        marginLeft: translateX + 1,\n                        marginTop: translateY + 1\n                    });\n                });\n            }\n\n            // apply inversion\n            if (wrapper.inverted) { // wrapper is a group\n                each(elem.childNodes, function (child) {\n                    renderer.invertChild(child, elem);\n                });\n            }\n\n            if (elem.tagName === 'SPAN') {\n\n                var width,\n                    rotation = wrapper.rotation,\n                    baseline,\n                    textWidth = pInt(wrapper.textWidth),\n                    currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n\n                if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n                    baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                    // Renderer specific handling of span rotation\n                    if (defined(rotation)) {\n                        wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                    }\n\n                    width = pick(wrapper.elemWidth, elem.offsetWidth);\n\n                    // Update textWidth\n                    if (width > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n                        css(elem, {\n                            width: textWidth + 'px',\n                            display: 'block',\n                            whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331\n                        });\n                        width = textWidth;\n                    }\n\n                    wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);\n                }\n\n                // apply position with correction\n                css(elem, {\n                    left: (x + (wrapper.xCorr || 0)) + 'px',\n                    top: (y + (wrapper.yCorr || 0)) + 'px'\n                });\n\n                // force reflow in webkit to apply the left and top on useHTML element (#1249)\n                if (isWebKit) {\n                    baseline = elem.offsetHeight; // assigned to baseline for lint purpose\n                }\n\n                // record current text transform\n                wrapper.cTT = currentTextTransform;\n            }\n        },\n\n        /**\n         * Set the rotation of an individual HTML span\n         */\n        setSpanRotation: function (rotation, alignCorrection, baseline) {\n            var rotationStyle = {},\n                cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : '';\n\n            rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n            rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n            css(this.element, rotationStyle);\n        },\n\n        /**\n         * Get the correction in X and Y positioning as the element is rotated.\n         */\n        getSpanCorrection: function (width, baseline, alignCorrection) {\n            this.xCorr = -width * alignCorrection;\n            this.yCorr = -baseline;\n        }\n    });\n\n    // Extend SvgRenderer for useHTML option.\n    extend(SVGRenderer.prototype, {\n        /**\n         * Create HTML text node. This is used by the VML renderer as well as the SVG\n         * renderer through the useHTML option.\n         *\n         * @param {String} str\n         * @param {Number} x\n         * @param {Number} y\n         */\n        html: function (str, x, y) {\n            var wrapper = this.createElement('span'),\n                element = wrapper.element,\n                renderer = wrapper.renderer;\n\n            // Text setter\n            wrapper.textSetter = function (value) {\n                if (value !== element.innerHTML) {\n                    delete this.bBox;\n                }\n                element.innerHTML = this.textStr = value;\n                wrapper.htmlUpdateTransform();\n            };\n\n            // Various setters which rely on update transform\n            wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n                if (key === 'align') {\n                    key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n                }\n                wrapper[key] = value;\n                wrapper.htmlUpdateTransform();\n            };\n\n            // Set the default attributes\n            wrapper\n                .attr({\n                    text: str,\n                    x: Math.round(x),\n                    y: Math.round(y)\n                })\n                .css({\n                    ";
if (build.classic) { 
s += "\n                    fontFamily: this.style.fontFamily,\n                    fontSize: this.style.fontSize,\n                    ";
} 
s += "\n                    position: 'absolute'\n                });\n\n            // Keep the whiteSpace style outside the wrapper.styles collection\n            element.style.whiteSpace = 'nowrap';\n\n            // Use the HTML specific .css method\n            wrapper.css = wrapper.htmlCss;\n\n            // This is specific for HTML within SVG\n            if (renderer.isSVG) {\n                wrapper.add = function (svgGroupWrapper) {\n\n                    var htmlGroup,\n                        container = renderer.box.parentNode,\n                        parentGroup,\n                        parents = [];\n\n                    this.parentGroup = svgGroupWrapper;\n\n                    // Create a mock group to hold the HTML elements\n                    if (svgGroupWrapper) {\n                        htmlGroup = svgGroupWrapper.div;\n                        if (!htmlGroup) {\n\n                            // Read the parent chain into an array and read from top down\n                            parentGroup = svgGroupWrapper;\n                            while (parentGroup) {\n\n                                parents.push(parentGroup);\n\n                                // Move up to the next parent group\n                                parentGroup = parentGroup.parentGroup;\n                            }\n\n                            // Ensure dynamically updating position when any parent is translated\n                            each(parents.reverse(), function (parentGroup) {\n                                var htmlGroupStyle,\n                                    cls = attr(parentGroup.element, 'class');\n\n                                if (cls) {\n                                    cls = { className: cls };\n                                } // else null\n\n                                // Create a HTML div and append it to the parent div to emulate\n                                // the SVG group structure\n                                htmlGroup = parentGroup.div = parentGroup.div || createElement('div', cls, {\n                                    position: 'absolute',\n                                    left: (parentGroup.translateX || 0) + 'px',\n                                    top: (parentGroup.translateY || 0) + 'px'\n                                }, htmlGroup || container); // the top group is appended to container\n\n                                // Shortcut\n                                htmlGroupStyle = htmlGroup.style;\n\n                                // Set listeners to update the HTML div's position whenever the SVG group\n                                // position is changed\n                                extend(parentGroup, {\n                                    translateXSetter: function (value, key) {\n                                        htmlGroupStyle.left = value + 'px';\n                                        parentGroup[key] = value;\n                                        parentGroup.doTransform = true;\n                                    },\n                                    translateYSetter: function (value, key) {\n                                        htmlGroupStyle.top = value + 'px';\n                                        parentGroup[key] = value;\n                                        parentGroup.doTransform = true;\n                                    }\n                                });\n\n                                // These properties are set as attributes on the SVG group, and as\n                                // identical CSS properties on the div. (#3542)\n                                each(['opacity', 'visibility'], function (prop) {\n                                    wrap(parentGroup, prop + 'Setter', function (proceed, value, key, elem) {\n                                        proceed.call(this, value, key, elem);\n                                        htmlGroupStyle[key] = value;\n                                    });\n                                });\n                            });\n\n                        }\n                    } else {\n                        htmlGroup = container;\n                    }\n\n                    htmlGroup.appendChild(element);\n\n                    // Shared with VML:\n                    wrapper.added = true;\n                    if (wrapper.alignOnAdd) {\n                        wrapper.htmlUpdateTransform();\n                    }\n\n                    return wrapper;\n                };\n            }\n            return wrapper;\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var VMLRenderer,\n            VMLRendererExtension,\n            VMLElement,\n\n            Color = H.Color,\n            createElement = H.createElement,\n            css = H.css,\n            defaultOptions = H.defaultOptions,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            discardElement = H.discardElement,\n            doc = H.doc,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            pInt = H.pInt,\n            svg = H.svg,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer,\n            useCanVG = H.useCanVG,\n            win = H.win;\n\n    /* ****************************************************************************\n     *                                                                            *\n     * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n     *                                                                            *\n     * For applications and websites that don't need IE support, like platform    *\n     * targeted mobile apps and web apps, this code can be removed.               *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * @constructor\n     */\n    if (!svg && !useCanVG) {\n\n    /**\n     * The VML element wrapper.\n     */\n    VMLElement = {\n\n        docMode8: doc && doc.documentMode === 8,\n\n        /**\n         * Initialize a new VML element wrapper. It builds the markup as a string\n         * to minimize DOM traffic.\n         * @param {Object} renderer\n         * @param {Object} nodeName\n         */\n        init: function (renderer, nodeName) {\n            var wrapper = this,\n                markup =  ['<', nodeName, ' filled=___doublequote___f___doublequote___ stroked=___doublequote___f___doublequote___'],\n                style = ['position: ', 'absolute', ';'],\n                isDiv = nodeName === 'div';\n\n            // divs and shapes need size\n            if (nodeName === 'shape' || isDiv) {\n                style.push('left:0;top:0;width:1px;height:1px;');\n            }\n            style.push('visibility: ', isDiv ? 'hidden' : 'visible');\n\n            markup.push(' style=___doublequote___', style.join(''), '___doublequote___/>');\n\n            // create element with default attributes and style\n            if (nodeName) {\n                markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n                    markup.join('')    :\n                    renderer.prepVML(markup);\n                wrapper.element = createElement(markup);\n            }\n\n            wrapper.renderer = renderer;\n        },\n\n        /**\n         * Add the node to the given parent\n         * @param {Object} parent\n         */\n        add: function (parent) {\n            var wrapper = this,\n                renderer = wrapper.renderer,\n                element = wrapper.element,\n                box = renderer.box,\n                inverted = parent && parent.inverted,\n\n                // get the parent node\n                parentNode = parent ?\n                    parent.element || parent :\n                    box;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // if the parent group is inverted, apply inversion on all children\n            if (inverted) { // only on groups\n                renderer.invertChild(element, parentNode);\n            }\n\n            // append it\n            parentNode.appendChild(element);\n\n            // align text after adding to be able to read offset\n            wrapper.added = true;\n            if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n                wrapper.updateTransform();\n            }\n\n            // fire an event for internal hooks\n            if (wrapper.onAdd) {\n                wrapper.onAdd();\n            }\n\n            return wrapper;\n        },\n\n        /**\n         * VML always uses htmlUpdateTransform\n         */\n        updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n        /**\n         * Set the rotation of a span with oldIE's filter\n         */\n        setSpanRotation: function () {\n            // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n            // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n            // has support for CSS3 transform. The getBBox method also needs to be updated\n            // to compensate for the rotation, like it currently does for SVG.\n            // Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n            var rotation = this.rotation,\n                costheta = Math.cos(rotation * deg2rad),\n                sintheta = Math.sin(rotation * deg2rad);\n                    \n            css(this.element, {\n                filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n                    ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n                    ', sizingMethod=\\'auto expand\\')'].join('') : 'none'\n            });\n        },\n\n        /**\n         * Get the positioning correction for the span after rotating.\n         */\n        getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n            var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,\n                sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,\n                height = pick(this.elemHeight, this.element.offsetHeight),\n                quad,\n                nonLeft = align && align !== 'left';\n\n            // correct x and y\n            this.xCorr = costheta < 0 && -width;\n            this.yCorr = sintheta < 0 && -height;\n\n            // correct for baseline and corners spilling out after rotation\n            quad = costheta * sintheta < 0;\n            this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n            this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n            // correct for the length/height of the text\n            if (nonLeft) {\n                this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n                if (rotation) {\n                    this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n                }\n                css(this.element, {\n                    textAlign: align\n                });\n            }\n        },\n\n        /**\n         * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n         * as the parameter and returns a string.\n         */\n        pathToVML: function (value) {\n            // convert paths\n            var i = value.length,\n                path = [];\n\n            while (i--) {\n\n                // Multiply by 10 to allow subpixel precision.\n                // Substracting half a pixel seems to make the coordinates\n                // align with SVG, but this hasn't been tested thoroughly\n                if (isNumber(value[i])) {\n                    path[i] = Math.round(value[i] * 10) - 5;\n                } else if (value[i] === 'Z') { // close the path\n                    path[i] = 'x';\n                } else {\n                    path[i] = value[i];\n\n                    // When the start X and end X coordinates of an arc are too close,\n                    // they are rounded to the same value above. In this case, substract or\n                    // add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n                    if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n                        // Start and end X\n                        if (path[i + 5] === path[i + 7]) {\n                            path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n                        }\n                        // Start and end Y\n                        if (path[i + 6] === path[i + 8]) {\n                            path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n                        }\n                    }\n                }\n            }\n\n\n            // Loop up again to handle path shortcuts (#2132)\n            /*while (i++ < path.length) {\n                if (path[i] === 'H') { // horizontal line to\n                    path[i] = 'L';\n                    path.splice(i + 2, 0, path[i - 1]);\n                } else if (path[i] === 'V') { // vertical line to\n                    path[i] = 'L';\n                    path.splice(i + 1, 0, path[i - 2]);\n                }\n            }*/\n            return path.join(' ') || 'x';\n        },\n\n        /**\n         * Set the element's clipping to a predefined rectangle\n         *\n         * @param {String} id The id of the clip rectangle\n         */\n        clip: function (clipRect) {\n            var wrapper = this,\n                clipMembers,\n                cssRet;\n\n            if (clipRect) {\n                clipMembers = clipRect.members;\n                erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n                clipMembers.push(wrapper);\n                wrapper.destroyClip = function () {\n                    erase(clipMembers, wrapper);\n                };\n                cssRet = clipRect.getCSS(wrapper);\n\n            } else {\n                if (wrapper.destroyClip) {\n                    wrapper.destroyClip();\n                }\n                cssRet = { clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n            }\n\n            return wrapper.css(cssRet);\n\n        },\n\n        /**\n         * Set styles for the element\n         * @param {Object} styles\n         */\n        css: SVGElement.prototype.htmlCss,\n\n        /**\n         * Removes a child either by removeChild or move to garbageBin.\n         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n         */\n        safeRemoveChild: function (element) {\n            // discardElement will detach the node from its parent before attaching it\n            // to the garbage bin. Therefore it is important that the node is attached and have parent.\n            if (element.parentNode) {\n                discardElement(element);\n            }\n        },\n\n        /**\n         * Extend element.destroy by removing it from the clip members array\n         */\n        destroy: function () {\n            if (this.destroyClip) {\n                this.destroyClip();\n            }\n\n            return SVGElement.prototype.destroy.apply(this);\n        },\n\n        /**\n         * Add an event listener. VML override for normalizing event parameters.\n         * @param {String} eventType\n         * @param {Function} handler\n         */\n        on: function (eventType, handler) {\n            // simplest possible event model for internal use\n            this.element['on' + eventType] = function () {\n                var evt = win.event;\n                evt.target = evt.srcElement;\n                handler(evt);\n            };\n            return this;\n        },\n\n        /**\n         * In stacked columns, cut off the shadows so that they don't overlap\n         */\n        cutOffPath: function (path, length) {\n\n            var len;\n\n            path = path.split(/[ ,,]/); // The extra comma tricks the trailing comma remover in ___doublequote___gulp scripts___doublequote___ task\n            len = path.length;\n\n            if (len === 9 || len === 11) {\n                path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n            }\n            return path.join(' ');\n        },\n\n        /**\n         * Apply a drop shadow by copying elements and giving them different strokes\n         * @param {Boolean|Object} shadowOptions\n         */\n        shadow: function (shadowOptions, group, cutOff) {\n            var shadows = [],\n                i,\n                element = this.element,\n                renderer = this.renderer,\n                shadow,\n                elemStyle = element.style,\n                markup,\n                path = element.path,\n                strokeWidth,\n                modifiedPath,\n                shadowWidth,\n                shadowElementOpacity;\n\n            // some times empty paths are not strings\n            if (path && typeof path.value !== 'string') {\n                path = 'x';\n            }\n            modifiedPath = path;\n\n            if (shadowOptions) {\n                shadowWidth = pick(shadowOptions.width, 3);\n                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                for (i = 1; i <= 3; i++) {\n\n                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n                    // Cut off shadows for stacked column items\n                    if (cutOff) {\n                        modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n                    }\n\n                    markup = ['<shape isShadow=___doublequote___true___doublequote___ strokeweight=___doublequote___', strokeWidth,\n                        '___doublequote___ filled=___doublequote___false___doublequote___ path=___doublequote___', modifiedPath,\n                        '___doublequote___ coordsize=___doublequote___10 10___doublequote___ style=___doublequote___', element.style.cssText, '___doublequote___ />'];\n\n                    shadow = createElement(renderer.prepVML(markup),\n                        null, {\n                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n                        }\n                    );\n                    if (cutOff) {\n                        shadow.cutOff = strokeWidth + 1;\n                    }\n\n                    // apply the opacity\n                    markup = ['<stroke color=___doublequote___', shadowOptions.color || 'black', '___doublequote___ opacity=___doublequote___', shadowElementOpacity * i, '___doublequote___/>'];\n                    createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n                    // insert it\n                    if (group) {\n                        group.element.appendChild(shadow);\n                    } else {\n                        element.parentNode.insertBefore(shadow, element);\n                    }\n\n                    // record it\n                    shadows.push(shadow);\n\n                }\n\n                this.shadows = shadows;\n            }\n            return this;\n        },\n        updateShadows: noop, // Used in SVG only\n\n        setAttr: function (key, value) {\n            if (this.docMode8) { // IE8 setAttribute bug\n                this.element[key] = value;\n            } else {\n                this.element.setAttribute(key, value);\n            }\n        },\n        classSetter: function (value) {\n            // IE8 Standards mode has problems retrieving the className unless set like this\n            this.element.className = value;\n        },\n        dashstyleSetter: function (value, key, element) {\n            var strokeElem = element.getElementsByTagName('stroke')[0] ||\n                createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n            strokeElem[key] = value || 'solid';\n            this[key] = value; /* because changing stroke-width will change the dash length\n                and cause an epileptic effect */\n        },\n        dSetter: function (value, key, element) {\n            var i,\n                shadows = this.shadows;\n            value = value || [];\n            this.d = value.join && value.join(' '); // used in getter for animation\n\n            element.path = value = this.pathToVML(value);\n\n            // update shadows\n            if (shadows) {\n                i = shadows.length;\n                while (i--) {\n                    shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n                }\n            }\n            this.setAttr(key, value);\n        },\n        fillSetter: function (value, key, element) {\n            var nodeName = element.nodeName;\n            if (nodeName === 'SPAN') { // text color\n                element.style.color = value;\n            } else if (nodeName !== 'IMG') { // #1336\n                element.filled = value !== 'none';\n                this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n            }\n        },\n        'fill-opacitySetter': function (value, key, element) {\n            createElement(\n                this.renderer.prepVML(['<', key.split('-')[0], ' opacity=___doublequote___', value, '___doublequote___/>']),\n                null,\n                null,\n                element\n            );\n        },\n        opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n        rotationSetter: function (value, key, element) {\n            var style = element.style;\n            this[key] = style[key] = value; // style is for #1873\n\n            // Correction for the 1x1 size of the shape container. Used in gauge needles.\n            style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';\n            style.top = Math.round(Math.cos(value * deg2rad)) + 'px';\n        },\n        strokeSetter: function (value, key, element) {\n            this.setAttr('strokecolor', this.renderer.color(value, element, key, this));\n        },\n        'stroke-widthSetter': function (value, key, element) {\n            element.stroked = !!value; // VML ___doublequote___stroked___doublequote___ attribute\n            this[key] = value; // used in getter, issue #113\n            if (isNumber(value)) {\n                value += 'px';\n            }\n            this.setAttr('strokeweight', value);\n        },\n        titleSetter: function (value, key) {\n            this.setAttr(key, value);\n        },\n        visibilitySetter: function (value, key, element) {\n\n            // Handle inherited visibility\n            if (value === 'inherit') {\n                value = 'visible';\n            }\n\n            // Let the shadow follow the main element\n            if (this.shadows) {\n                each(this.shadows, function (shadow) {\n                    shadow.style[key] = value;\n                });\n            }\n\n            // Instead of toggling the visibility CSS property, move the div out of the viewport.\n            // This works around #61 and #586\n            if (element.nodeName === 'DIV') {\n                value = value === 'hidden' ? '-999em' : 0;\n\n                // In order to redraw, IE7 needs the div to be visible when tucked away\n                // outside the viewport. So the visibility is actually opposite of\n                // the expected value. This applies to the tooltip only.\n                if (!this.docMode8) {\n                    element.style[key] = value ? 'visible' : 'hidden';\n                }\n                key = 'top';\n            }\n            element.style[key] = value;\n        },\n        xSetter: function (value, key, element) {\n            this[key] = value; // used in getter\n\n            if (key === 'x') {\n                key = 'left';\n            } else if (key === 'y') {\n                key = 'top';\n            }/* else {\n                value = Math.max(0, value); // don't set width or height below zero (#311)\n            }*/\n\n            // clipping rectangle special\n            if (this.updateClipping) {\n                this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n                this.updateClipping();\n            } else {\n                // normal\n                element.style[key] = value;\n            }\n        },\n        zIndexSetter: function (value, key, element) {\n            element.style[key] = value;\n        }\n    };\n    H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n    VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];\n\n    // Some shared setters\n    VMLElement.prototype.ySetter =\n        VMLElement.prototype.widthSetter =\n        VMLElement.prototype.heightSetter =\n        VMLElement.prototype.xSetter;\n\n\n    /**\n     * The VML renderer\n     */\n    VMLRendererExtension = { // inherit SVGRenderer\n\n        Element: VMLElement,\n        isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,\n\n\n        /**\n         * Initialize the VMLRenderer\n         * @param {Object} container\n         * @param {Number} width\n         * @param {Number} height\n         */\n        init: function (container, width, height, style) {\n            var renderer = this,\n                boxWrapper,\n                box,\n                css;\n\n            renderer.alignedObjects = [];\n\n            boxWrapper = renderer.createElement('div')\n                .css(extend(this.getStyle(style), { position: 'relative' }));\n            box = boxWrapper.element;\n            container.appendChild(boxWrapper.element);\n\n\n            // generate the containing box\n            renderer.isVML = true;\n            renderer.box = box;\n            renderer.boxWrapper = boxWrapper;\n            renderer.gradients = {};\n            renderer.cache = {}; // Cache for numerical bounding boxes\n            renderer.cacheKeys = [];\n\n\n            renderer.setSize(width, height, false);\n\n            // The only way to make IE6 and IE7 print is to use a global namespace. However,\n            // with IE8 the only way to make the dynamic shapes visible in screen and print mode\n            // seems to be to add the xmlns attribute and the behaviour style inline.\n            if (!doc.namespaces.hcv) {\n\n                doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n                // Setup default CSS (#2153, #2368, #2384)\n                css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n                    '{ behavior:url(#default#VML); display: inline-block; } ';\n                try {\n                    doc.createStyleSheet().cssText = css;\n                } catch (e) {\n                    doc.styleSheets[0].cssText += css;\n                }\n\n            }\n        },\n\n\n        /**\n         * Detect whether the renderer is hidden. This happens when one of the parent elements\n         * has display: none\n         */\n        isHidden: function () {\n            return !this.box.offsetWidth;\n        },\n\n        /**\n         * Define a clipping rectangle. In VML it is accomplished by storing the values\n         * for setting the CSS style to all associated members.\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        clipRect: function (x, y, width, height) {\n\n            // create a dummy element\n            var clipRect = this.createElement(),\n                isObj = isObject(x);\n\n            // mimic a rectangle with its style object for automatic updating in attr\n            return extend(clipRect, {\n                members: [],\n                count: 0,\n                left: (isObj ? x.x : x) + 1,\n                top: (isObj ? x.y : y) + 1,\n                width: (isObj ? x.width : width) - 1,\n                height: (isObj ? x.height : height) - 1,\n                getCSS: function (wrapper) {\n                    var element = wrapper.element,\n                        nodeName = element.nodeName,\n                        isShape = nodeName === 'shape',\n                        inverted = wrapper.inverted,\n                        rect = this,\n                        top = rect.top - (isShape ? element.offsetTop : 0),\n                        left = rect.left,\n                        right = left + rect.width,\n                        bottom = top + rect.height,\n                        ret = {\n                            clip: 'rect(' +\n                                Math.round(inverted ? left : top) + 'px,' +\n                                Math.round(inverted ? bottom : right) + 'px,' +\n                                Math.round(inverted ? right : bottom) + 'px,' +\n                                Math.round(inverted ? top : left) + 'px)'\n                        };\n\n                    // issue 74 workaround\n                    if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {\n                        extend(ret, {\n                            width: right + 'px',\n                            height: bottom + 'px'\n                        });\n                    }\n                    return ret;\n                },\n\n                // used in attr and animation to update the clipping of all members\n                updateClipping: function () {\n                    each(clipRect.members, function (member) {\n                        if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n                            member.css(clipRect.getCSS(member));\n                        }\n                    });\n                }\n            });\n\n        },\n\n\n        /**\n         * Take a color and return it if it's a string, make it a gradient if it's a\n         * gradient configuration object, and apply opacity.\n         *\n         * @param {Object} color The color or config object\n         */\n        color: function (color, elem, prop, wrapper) {\n            var renderer = this,\n                colorObject,\n                regexRgba = /^rgba/,\n                markup,\n                fillType,\n                ret = 'none';\n\n            // Check for linear or radial gradient\n            if (color && color.linearGradient) {\n                fillType = 'gradient';\n            } else if (color && color.radialGradient) {\n                fillType = 'pattern';\n            }\n\n\n            if (fillType) {\n\n                var stopColor,\n                    stopOpacity,\n                    gradient = color.linearGradient || color.radialGradient,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    opacity1,\n                    opacity2,\n                    color1,\n                    color2,\n                    fillAttr = '',\n                    stops = color.stops,\n                    firstStop,\n                    lastStop,\n                    colors = [],\n                    addFillNode = function () {\n                        // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n                        // are reversed.\n                        markup = ['<fill colors=___doublequote___' + colors.join(',') + '___doublequote___ opacity=___doublequote___', opacity2, '___doublequote___ o:opacity2=___doublequote___', opacity1,\n                            '___doublequote___ type=___doublequote___', fillType, '___doublequote___ ', fillAttr, 'focus=___doublequote___100%___doublequote___ method=___doublequote___any___doublequote___ />'];\n                        createElement(renderer.prepVML(markup), null, null, elem);\n                    };\n\n                // Extend from 0 to 1\n                firstStop = stops[0];\n                lastStop = stops[stops.length - 1];\n                if (firstStop[0] > 0) {\n                    stops.unshift([\n                        0,\n                        firstStop[1]\n                    ]);\n                }\n                if (lastStop[0] < 1) {\n                    stops.push([\n                        1,\n                        lastStop[1]\n                    ]);\n                }\n\n                // Compute the stops\n                each(stops, function (stop, i) {\n                    if (regexRgba.test(stop[1])) {\n                        colorObject = Color(stop[1]);\n                        stopColor = colorObject.get('rgb');\n                        stopOpacity = colorObject.get('a');\n                    } else {\n                        stopColor = stop[1];\n                        stopOpacity = 1;\n                    }\n\n                    // Build the color attribute\n                    colors.push((stop[0] * 100) + '% ' + stopColor);\n\n                    // Only start and end opacities are allowed, so we use the first and the last\n                    if (!i) {\n                        opacity1 = stopOpacity;\n                        color2 = stopColor;\n                    } else {\n                        opacity2 = stopOpacity;\n                        color1 = stopColor;\n                    }\n                });\n\n                // Apply the gradient to fills only.\n                if (prop === 'fill') {\n\n                    // Handle linear gradient angle\n                    if (fillType === 'gradient') {\n                        x1 = gradient.x1 || gradient[0] || 0;\n                        y1 = gradient.y1 || gradient[1] || 0;\n                        x2 = gradient.x2 || gradient[2] || 0;\n                        y2 = gradient.y2 || gradient[3] || 0;\n                        fillAttr = 'angle=___doublequote___' + (90  - Math.atan(\n                            (y2 - y1) / // y vector\n                            (x2 - x1) // x vector\n                            ) * 180 / Math.PI) + '___doublequote___';\n\n                        addFillNode();\n\n                    // Radial (circular) gradient\n                    } else {\n\n                        var r = gradient.r,\n                            sizex = r * 2,\n                            sizey = r * 2,\n                            cx = gradient.cx,\n                            cy = gradient.cy,\n                            radialReference = elem.radialReference,\n                            bBox,\n                            applyRadialGradient = function () {\n                                if (radialReference) {\n                                    bBox = wrapper.getBBox();\n                                    cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n                                    cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n                                    sizex *= radialReference[2] / bBox.width;\n                                    sizey *= radialReference[2] / bBox.height;\n                                }\n                                fillAttr = 'src=___doublequote___' + defaultOptions.global.VMLRadialGradientURL + '___doublequote___ ' +\n                                    'size=___doublequote___' + sizex + ',' + sizey + '___doublequote___ ' +\n                                    'origin=___doublequote___0.5,0.5___doublequote___ ' +\n                                    'position=___doublequote___' + cx + ',' + cy + '___doublequote___ ' +\n                                    'color2=___doublequote___' + color2 + '___doublequote___ ';\n\n                                addFillNode();\n                            };\n\n                        // Apply radial gradient\n                        if (wrapper.added) {\n                            applyRadialGradient();\n                        } else {\n                            // We need to know the bounding box to get the size and position right\n                            wrapper.onAdd = applyRadialGradient;\n                        }\n\n                        // The fill element's color attribute is broken in IE8 standards mode, so we\n                        // need to set the parent shape's fillcolor attribute instead.\n                        ret = color1;\n                    }\n\n                // Gradients are not supported for VML stroke, return the first color. #722.\n                } else {\n                    ret = stopColor;\n                }\n\n            // If the color is an rgba color, split it and add a fill node\n            // to hold the opacity component\n            } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n                colorObject = Color(color);\n\n                wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);\n\n                ret = colorObject.get('rgb');\n\n\n            } else {\n                var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n                if (propNodes.length) {\n                    propNodes[0].opacity = 1;\n                    propNodes[0].type = 'solid';\n                }\n                ret = color;\n            }\n\n            return ret;\n        },\n\n        /**\n         * Take a VML string and prepare it for either IE8 or IE6/IE7.\n         * @param {Array} markup A string array of the VML markup to prepare\n         */\n        prepVML: function (markup) {\n            var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n                isIE8 = this.isIE8;\n\n            markup = markup.join('');\n\n            if (isIE8) { // add xmlns and style inline\n                markup = markup.replace('/>', ' xmlns=___doublequote___urn:schemas-microsoft-com:vml___doublequote___ />');\n                if (markup.indexOf('style=___doublequote___') === -1) {\n                    markup = markup.replace('/>', ' style=___doublequote___' + vmlStyle + '___doublequote___ />');\n                } else {\n                    markup = markup.replace('style=___doublequote___', 'style=___doublequote___' + vmlStyle);\n                }\n\n            } else { // add namespace\n                markup = markup.replace('<', '<hcv:');\n            }\n\n            return markup;\n        },\n\n        /**\n         * Create rotated and aligned text\n         * @param {String} str\n         * @param {Number} x\n         * @param {Number} y\n         */\n        text: SVGRenderer.prototype.html,\n\n        /**\n         * Create and return a path element\n         * @param {Array} path\n         */\n        path: function (path) {\n            var attr = {\n                // subpixel precision down to 0.1 (width and height = 1px)\n                coordsize: '10 10'\n            };\n            if (isArray(path)) {\n                attr.d = path;\n            } else if (isObject(path)) { // attributes\n                extend(attr, path);\n            }\n            // create the shape\n            return this.createElement('shape').attr(attr);\n        },\n\n        /**\n         * Create and return a circle element. In VML circles are implemented as\n         * shapes, which is faster than v:oval\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} r\n         */\n        circle: function (x, y, r) {\n            var circle = this.symbol('circle');\n            if (isObject(x)) {\n                r = x.r;\n                y = x.y;\n                x = x.x;\n            }\n            circle.isCircle = true; // Causes x and y to mean center (#1682)\n            circle.r = r;\n            return circle.attr({ x: x, y: y });\n        },\n\n        /**\n         * Create a group using an outer div and an inner v:group to allow rotating\n         * and flipping. A simple v:group would have problems with positioning\n         * child HTML elements and CSS clip.\n         *\n         * @param {String} name The name of the group\n         */\n        g: function (name) {\n            var wrapper,\n                attribs;\n\n            // set the class name\n            if (name) {\n                attribs = { 'className': 'highcharts-' + name, 'class': 'highcharts-' + name };\n            }\n\n            // the div to hold HTML and clipping\n            wrapper = this.createElement('div').attr(attribs);\n\n            return wrapper;\n        },\n\n        /**\n         * VML override to create a regular HTML image\n         * @param {String} src\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        image: function (src, x, y, width, height) {\n            var obj = this.createElement('img')\n                .attr({ src: src });\n\n            if (arguments.length > 1) {\n                obj.attr({\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n            return obj;\n        },\n\n        /**\n         * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n         */\n        createElement: function (nodeName) {\n            return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);\n        },\n\n        /**\n         * In the VML renderer, each child of an inverted div (group) is inverted\n         * @param {Object} element\n         * @param {Object} parentNode\n         */\n        invertChild: function (element, parentNode) {\n            var ren = this,\n                parentStyle = parentNode.style,\n                imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n            css(element, {\n                flip: 'x',\n                left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n                top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n                rotation: -90\n            });\n\n            // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n            each(element.childNodes, function (child) {\n                ren.invertChild(child, element);\n            });\n        },\n\n        /**\n         * Symbol definitions that override the parent SVG renderer's symbols\n         *\n         */\n        symbols: {\n            // VML specific arc function\n            arc: function (x, y, w, h, options) {\n                var start = options.start,\n                    end = options.end,\n                    radius = options.r || w || h,\n                    innerRadius = options.innerR,\n                    cosStart = Math.cos(start),\n                    sinStart = Math.sin(start),\n                    cosEnd = Math.cos(end),\n                    sinEnd = Math.sin(end),\n                    ret;\n\n                if (end - start === 0) { // no angle, don't show it.\n                    return ['x'];\n                }\n\n                ret = [\n                    'wa', // clockwise arc to\n                    x - radius, // left\n                    y - radius, // top\n                    x + radius, // right\n                    y + radius, // bottom\n                    x + radius * cosStart, // start x\n                    y + radius * sinStart, // start y\n                    x + radius * cosEnd, // end x\n                    y + radius * sinEnd  // end y\n                ];\n\n                if (options.open && !innerRadius) {\n                    ret.push(\n                        'e',\n                        'M',\n                        x,// - innerRadius,\n                        y// - innerRadius\n                    );\n                }\n\n                ret.push(\n                    'at', // anti clockwise arc to\n                    x - innerRadius, // left\n                    y - innerRadius, // top\n                    x + innerRadius, // right\n                    y + innerRadius, // bottom\n                    x + innerRadius * cosEnd, // start x\n                    y + innerRadius * sinEnd, // start y\n                    x + innerRadius * cosStart, // end x\n                    y + innerRadius * sinStart, // end y\n                    'x', // finish path\n                    'e' // close\n                );\n\n                ret.isArc = true;\n                return ret;\n\n            },\n            // Add circle symbol path. This performs significantly faster than v:oval.\n            circle: function (x, y, w, h, wrapper) {\n\n                if (wrapper) {\n                    w = h = 2 * wrapper.r;\n                }\n\n                // Center correction, #1682\n                if (wrapper && wrapper.isCircle) {\n                    x -= w / 2;\n                    y -= h / 2;\n                }\n\n                // Return the path\n                return [\n                    'wa', // clockwisearcto\n                    x, // left\n                    y, // top\n                    x + w, // right\n                    y + h, // bottom\n                    x + w, // start x\n                    y + h / 2,     // start y\n                    x + w, // end x\n                    y + h / 2,     // end y\n                    //'x', // finish path\n                    'e' // close\n                ];\n            },\n            /**\n             * Add rectangle symbol path which eases rotation and omits arcsize problems\n             * compared to the built-in VML roundrect shape. When borders are not rounded,\n             * use the simpler square path, else use the callout path without the arrow.\n             */\n            rect: function (x, y, w, h, options) {\n                return SVGRenderer.prototype.symbols[\n                    !defined(options) || !options.r ? 'square' : 'callout'\n                ].call(0, x, y, w, h, options);\n            }\n        }\n    };\n    H.VMLRenderer = VMLRenderer = function () {\n        this.init.apply(this, arguments);\n    };\n    VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n        // general renderer\n        H.Renderer = VMLRenderer;\n    }\n\n    // This method is used with exporting in old IE, when emulating SVG (see #2314)\n    SVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n        var measuringSpan = doc.createElement('span'),\n            offsetWidth,\n            textNode = doc.createTextNode(text);\n\n        measuringSpan.appendChild(textNode);\n        css(measuringSpan, styles);\n        this.box.appendChild(measuringSpan);\n        offsetWidth = measuringSpan.offsetWidth;\n        discardElement(measuringSpan); // #2463\n        return offsetWidth;\n    };\n\n\n    /* ****************************************************************************\n     *                                                                            *\n     * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n     *                                                                            *\n     *****************************************************************************/\n    \n        return H;\n    }(Highcharts));\n    (function (H) {\n        var CanVGRenderer,\n            doc = H.win.doc,\n            useCanVG = H.useCanVG;\n\n    /* ****************************************************************************\n     *                                                                            *\n     * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n     * TARGETING THAT SYSTEM.                                                     *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * Downloads a script and executes a callback when done.\n     * @param {String} scriptLocation\n     * @param {Function} callback\n     */\n    function getScript(scriptLocation, callback) {\n        var head = doc.getElementsByTagName('head')[0],\n            script = doc.createElement('script');\n\n        script.type = 'text/javascript';\n        script.src = scriptLocation;\n        script.onload = callback;\n\n        head.appendChild(script);\n    }\n\n    if (useCanVG) {\n        /**\n         * The CanVGRenderer is empty from start to keep the source footprint small.\n         * When requested, the CanVGController downloads the rest of the source packaged\n         * together with the canvg library.\n         */\n        H.Renderer = CanVGRenderer = function () {\n            // Override the global SVG namespace to fake SVG/HTML that accepts CSS\n            H.SVG_NS = 'http://www.w3.org/1999/xhtml';\n        };\n\n        /**\n         * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but\n         * the implementation from SvgRenderer will not be merged in until first render.\n         */\n        CanVGRenderer.prototype.symbols = {};\n\n        /**\n         * Handles on demand download of canvg rendering support.\n         */\n        H.CanVGController = (function () {\n            // List of renderering calls\n            var deferredRenderCalls = [];\n\n            /**\n             * When downloaded, we are ready to draw deferred charts.\n             */\n            function drawDeferred() {\n                var callLength = deferredRenderCalls.length,\n                    callIndex;\n\n                // Draw all pending render calls\n                for (callIndex = 0; callIndex < callLength; callIndex++) {\n                    deferredRenderCalls[callIndex]();\n                }\n                // Clear the list\n                deferredRenderCalls = [];\n            }\n\n            return {\n                push: function (func, scriptLocation) {\n                    // Only get the script once\n                    if (deferredRenderCalls.length === 0) {\n                        getScript(scriptLocation, drawDeferred);\n                    }\n                    // Register render call\n                    deferredRenderCalls.push(func);\n                }\n            };\n        }());\n    } // end CanVGRenderer\n\n    /* ****************************************************************************\n     *                                                                            *\n     * END OF ANDROID < 3 SPECIFIC CODE                                           *\n     *                                                                            *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var correctFloat = H.correctFloat,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            lin2log = H.lin2log,\n            merge = H.merge,\n            pick = H.pick,\n            deg2rad = H.deg2rad;\n\n    /**\n     * The Tick class\n     */\n    H.Tick = function (axis, pos, type, noLabel) {\n        this.axis = axis;\n        this.pos = pos;\n        this.type = type || '';\n        this.isNew = true;\n\n        if (!type && !noLabel) {\n            this.addLabel();\n        }\n    };\n\n    H.Tick.prototype = {\n        /**\n         * Write the tick label\n         */\n        addLabel: function () {\n            var tick = this,\n                axis = tick.axis,\n                options = axis.options,\n                chart = axis.chart,\n                categories = axis.categories,\n                names = axis.names,\n                pos = tick.pos,\n                labelOptions = options.labels,\n                str,\n                tickPositions = axis.tickPositions,\n                isFirst = pos === tickPositions[0],\n                isLast = pos === tickPositions[tickPositions.length - 1],\n                value = categories ?\n                    pick(categories[pos], names[pos], pos) :\n                    pos,\n                label = tick.label,\n                tickPositionInfo = tickPositions.info,\n                dateTimeLabelFormat;\n\n            // Set the datetime label format. If a higher rank is set for this position, use that. If not,\n            // use the general format.\n            if (axis.isDatetimeAxis && tickPositionInfo) {\n                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n            }\n            // set properties for access in render method\n            tick.isFirst = isFirst;\n            tick.isLast = isLast;\n\n            // get the string\n            str = axis.labelFormatter.call({\n                axis: axis,\n                chart: chart,\n                isFirst: isFirst,\n                isLast: isLast,\n                dateTimeLabelFormat: dateTimeLabelFormat,\n                value: axis.isLog ? correctFloat(lin2log(value)) : value\n            });\n\n            // prepare CSS\n            //css = width && { width: Math.max(1, Math.round(width - 2 * (labelOptions.padding || 10))) + 'px' };\n        \n            // first call\n            if (!defined(label)) {\n\n                tick.label = label =\n                    defined(str) && labelOptions.enabled ?\n                        chart.renderer.text(\n                                str,\n                                0,\n                                0,\n                                labelOptions.useHTML\n                            )\n                            ";
if (build.classic) { 
s += "\n                            // without position absolute, IE export sometimes is wrong\n                            .css(merge(labelOptions.style))\n                            ";
} 
s += "\n                            .add(axis.labelGroup) :\n                        null;\n                tick.labelLength = label && label.getBBox().width; // Un-rotated length\n                tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n            // update\n            } else if (label) {\n                label.attr({ text: str });\n            }\n        },\n\n        /**\n         * Get the offset height or width of the label\n         */\n        getLabelSize: function () {\n            return this.label ?\n                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n                0;\n        },\n\n        /**\n         * Handle the label overflow by adjusting the labels to the left and right edge, or\n         * hide them if they collide into the neighbour label.\n         */\n        handleOverflow: function (xy) {\n            var axis = this.axis,\n                pxPos = xy.x,\n                chartWidth = axis.chart.chartWidth,\n                spacing = axis.chart.spacing,\n                leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n                rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),\n                label = this.label,\n                rotation = this.rotation,\n                factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n                labelWidth = label.getBBox().width,\n                slotWidth = axis.slotWidth,\n                xCorrection = factor,\n                goRight = 1,\n                leftPos,\n                rightPos,\n                textWidth,\n                css = {};\n\n            // Check if the label overshoots the chart spacing box. If it does, move it.\n            // If it now overshoots the slotWidth, add ellipsis.\n            if (!rotation) {\n                leftPos = pxPos - factor * labelWidth;\n                rightPos = pxPos + (1 - factor) * labelWidth;\n\n                if (leftPos < leftBound) {\n                    slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;\n                } else if (rightPos > rightBound) {\n                    slotWidth = rightBound - xy.x + slotWidth * factor;\n                    goRight = -1;\n                }\n\n                slotWidth = Math.min(axis.slotWidth, slotWidth); // #4177\n                if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {\n                    xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - Math.min(labelWidth, slotWidth)));            \n                }\n                // If the label width exceeds the available space, set a text width to be\n                // picked up below. Also, if a width has been set before, we need to set a new\n                // one because the reported labelWidth will be limited by the box (#3938).\n                if (labelWidth > slotWidth || (axis.autoRotation && label.styles && label.styles.width)) {\n                    textWidth = slotWidth;\n                }\n\n            // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n            } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n                textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n            } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n                textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n            }\n\n            if (textWidth) {\n                css.width = textWidth;\n                if (!axis.options.labels.style.textOverflow) {\n                    css.textOverflow = 'ellipsis';\n                }\n                label.css(css);\n            }\n        },\n\n        /**\n         * Get the x and y position for ticks and labels\n         */\n        getPosition: function (horiz, pos, tickmarkOffset, old) {\n            var axis = this.axis,\n                chart = axis.chart,\n                cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n            return {\n                x: horiz ?\n                    axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n                    axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n                y: horiz ?\n                    cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n                    cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n            };\n\n        },\n\n        /**\n         * Get the x, y position of the tick label\n         */\n        getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n            var axis = this.axis,\n                transA = axis.transA,\n                reversed = axis.reversed,\n                staggerLines = axis.staggerLines,\n                rotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n                yOffset = labelOptions.y,\n                line;\n\n            if (!defined(yOffset)) {\n                yOffset = axis.side === 2 ? \n                    rotCorr.y + 8 :\n                    // #3140, #3140\n                    yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n            }\n\n            x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n                tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n            y = y + yOffset - (tickmarkOffset && !horiz ?\n                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n            // Correct for staggered labels\n            if (staggerLines) {\n                line = (index / (step || 1) % staggerLines);\n                if (axis.opposite) {\n                    line = staggerLines - line - 1;\n                }\n                y += line * (axis.labelOffset / staggerLines);\n            }\n\n            return {\n                x: x,\n                y: Math.round(y)\n            };\n        },\n\n        /**\n         * Extendible method to return the path of the marker\n         */\n        getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n            return renderer.crispLine([\n                'M',\n                x,\n                y,\n                'L',\n                x + (horiz ? 0 : -tickLength),\n                y + (horiz ? tickLength : 0)\n            ], tickWidth);\n        },\n\n        /**\n         * Put everything in place\n         *\n         * @param index {Number}\n         * @param old {Boolean} Use old coordinates to prepare an animation into new position\n         */\n        render: function (index, old, opacity) {\n            var tick = this,\n                axis = tick.axis,\n                options = axis.options,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                horiz = axis.horiz,\n                type = tick.type,\n                label = tick.label,\n                pos = tick.pos,\n                labelOptions = options.labels,\n                gridLine = tick.gridLine,\n                gridPrefix = type ? type + 'Grid' : 'grid',\n                tickPrefix = type ? type + 'Tick' : 'tick',\n                gridLineWidth = options[gridPrefix + 'LineWidth'],\n                gridLineColor = options[gridPrefix + 'LineColor'],\n                ";
if (build.classic) { 
s += "\n                dashStyle = options[gridPrefix + 'LineDashStyle'],\n                ";
} 
s += "\n                tickLength = options[tickPrefix + 'Length'],\n                tickWidth = pick(options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1\n                tickColor = options[tickPrefix + 'Color'],\n                tickPosition = options[tickPrefix + 'Position'],\n                gridLinePath,\n                mark = tick.mark,\n                markPath,\n                step = /*axis.labelStep || */labelOptions.step,\n                attribs,\n                show = true,\n                tickmarkOffset = axis.tickmarkOffset,\n                xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n                x = xy.x,\n                y = xy.y,\n                reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n            opacity = pick(opacity, 1);\n            this.isActive = true;\n\n            // create the grid line\n            if (gridLineWidth) {\n                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);\n\n                if (gridLine === undefined) {\n                    attribs = {\n                        stroke: gridLineColor,\n                        'stroke-width': gridLineWidth\n                    };\n                    ";
if (build.classic) { 
s += "\n                    if (dashStyle) {\n                        attribs.dashstyle = dashStyle;\n                    }\n                    ";
} 
s += "\n                    if (!type) {\n                        attribs.zIndex = 1;\n                    }\n                    if (old) {\n                        attribs.opacity = 0;\n                    }\n                    tick.gridLine = gridLine =\n                        gridLineWidth ?\n                            renderer.path(gridLinePath)\n                                .attr(attribs).add(axis.gridGroup) :\n                            null;\n                }\n\n                // If the parameter 'old' is set, the current call will be followed\n                // by another call, therefore do not do any animations this time\n                if (!old && gridLine && gridLinePath) {\n                    gridLine[tick.isNew ? 'attr' : 'animate']({\n                        d: gridLinePath,\n                        opacity: opacity\n                    });\n                }\n            }\n\n            // create the tick mark\n            if (tickWidth && tickLength) {\n\n                // negate the length\n                if (tickPosition === 'inside') {\n                    tickLength = -tickLength;\n                }\n                if (axis.opposite) {\n                    tickLength = -tickLength;\n                }\n\n                markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);\n                if (mark) { // updating\n                    mark.animate({\n                        d: markPath,\n                        opacity: opacity\n                    });\n                } else { // first time\n                    tick.mark = renderer.path(\n                        markPath\n                    ).attr({\n                        stroke: tickColor,\n                        'stroke-width': tickWidth,\n                        opacity: opacity\n                    }).add(axis.axisGroup);\n                }\n            }\n\n            // the label is created on init - now move it into place\n            if (label && !isNaN(x)) {\n                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n                // Apply show first and show last. If the tick is both first and last, it is\n                // a single centered tick, in which case we show the label anyway (#2100).\n                if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n                        (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n                    show = false;\n\n                // Handle label overflow and show or hide accordingly\n                } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n                    tick.handleOverflow(xy);\n                }\n\n                // apply step\n                if (step && index % step) {\n                    // show those indices dividable by step\n                    show = false;\n                }\n\n                // Set the new position, and show or hide\n                if (show && !isNaN(xy.y)) {\n                    xy.opacity = opacity;\n                    label[tick.isNew ? 'attr' : 'animate'](xy);\n                    tick.isNew = false;\n                } else {\n                    label.attr('y', -9999); // #1338\n                }\n            }\n        },\n\n        /**\n         * Destructor for the tick prototype\n         */\n        destroy: function () {\n            destroyObjectProperties(this, this.axis);\n        }\n    };\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            AxisPlotLineOrBandExtension = H.AxisPlotLineOrBandExtension,\n            correctFloat = H.correctFloat,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            error = H.error,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            getMagnitude = H.getMagnitude,\n            inArray = H.inArray,\n            isNumber = H.isNumber,\n            isString = H.isString,\n            lin2log = H.lin2log,\n            log2lin = H.log2lin,\n            merge = H.merge,\n            normalizeTickInterval = H.normalizeTickInterval,\n            pick = H.pick,\n            PlotLineOrBand = H.PlotLineOrBand,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            syncTimeout = H.syncTimeout,\n            Tick = H.Tick;\n    /**\n     * Create a new axis object\n     * @param {Object} chart\n     * @param {Object} options\n     */\n    H.Axis = function () {\n        this.init.apply(this, arguments);\n    };\n\n    H.Axis.prototype = {\n\n        /**\n         * Default options for the X axis - the Y axis has extended defaults\n         */\n        defaultOptions: {\n            // allowDecimals: null,\n            // alternateGridColor: null,\n            // categories: [],\n            dateTimeLabelFormats: {\n                millisecond: '%H:%M:%S.%L',\n                second: '%H:%M:%S',\n                minute: '%H:%M',\n                hour: '%H:%M',\n                day: '%e. %b',\n                week: '%e. %b',\n                month: '%b \\'%y',\n                year: '%Y'\n            },\n            endOnTick: false,\n            gridLineColor: '#D8D8D8',\n            // gridLineDashStyle: 'solid',\n            // gridLineWidth: 0,\n            // reversed: false,\n\n            labels: {\n                enabled: true,\n                // rotation: 0,\n                // align: 'center',\n                // step: null,\n                ";
if (build.classic) { 
s += "\n                style: {\n                    color: '#606060',\n                    cursor: 'default',\n                    fontSize: '11px'\n                },\n                ";
} 
s += "\n                x: 0,\n                y: 15\n                /*formatter: function () {\n                    return this.value;\n                },*/\n            },\n            lineColor: '#C0D0E0',\n            lineWidth: 1,\n            //linkedTo: null,\n            //max: undefined,\n            //min: undefined,\n            minPadding: 0.01,\n            maxPadding: 0.01,\n            //minRange: null,\n            minorGridLineColor: '#E0E0E0',\n            // minorGridLineDashStyle: null,\n            minorGridLineWidth: 1,\n            minorTickColor: '#A0A0A0',\n            //minorTickInterval: null,\n            minorTickLength: 2,\n            minorTickPosition: 'outside', // inside or outside\n            //minorTickWidth: 0,\n            //opposite: false,\n            //offset: 0,\n            //plotBands: [{\n            //    events: {},\n            //    zIndex: 1,\n            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n            //}],\n            //plotLines: [{\n            //    events: {}\n            //  dashStyle: {}\n            //    zIndex:\n            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n            //}],\n            //reversed: false,\n            // showFirstLabel: true,\n            // showLastLabel: true,\n            startOfWeek: 1,\n            startOnTick: false,\n            tickColor: '#C0D0E0',\n            //tickInterval: null,\n            tickLength: 10,\n            tickmarkPlacement: 'between', // on or between\n            tickPixelInterval: 100,\n            tickPosition: 'outside',\n            //tickWidth: 1,\n            title: {\n                //text: null,\n                align: 'middle', // low, middle or high\n                //margin: 0 for horizontal, 10 for vertical axes,\n                //rotation: 0,\n                //side: 'outside',\n                ";
if (build.classic) { 
s += "\n                style: {\n                    color: '#707070'\n                }\n                ";
} 
s += "\n                //x: 0,\n                //y: 0\n            },\n            type: 'linear' // linear, logarithmic or datetime\n            //visible: true\n        },\n\n        /**\n         * This options set extends the defaultOptions for Y axes\n         */\n        defaultYAxisOptions: {\n            endOnTick: true,\n            gridLineWidth: 1,\n            tickPixelInterval: 72,\n            showLastLabel: true,\n            labels: {\n                x: -8,\n                y: 3\n            },\n            lineWidth: 0,\n            maxPadding: 0.05,\n            minPadding: 0.05,\n            startOnTick: true,\n            //tickWidth: 0,\n            title: {\n                rotation: 270,\n                text: 'Values'\n            },\n            stackLabels: {\n                enabled: false,\n                //align: dynamic,\n                //y: dynamic,\n                //x: dynamic,\n                //verticalAlign: dynamic,\n                //textAlign: dynamic,\n                //rotation: 0,\n                formatter: function () {\n                    return H.numberFormat(this.total, -1);\n                },\n                style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for left axes\n         */\n        defaultLeftAxisOptions: {\n            labels: {\n                x: -15,\n                y: null\n            },\n            title: {\n                rotation: 270\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for right axes\n         */\n        defaultRightAxisOptions: {\n            labels: {\n                x: 15,\n                y: null\n            },\n            title: {\n                rotation: 90\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for bottom axes\n         */\n        defaultBottomAxisOptions: {\n            labels: {\n                autoRotation: [-45],\n                x: 0,\n                y: null // based on font size\n                // overflow: undefined,\n                // staggerLines: null\n            },\n            title: {\n                rotation: 0\n            }\n        },\n        /**\n         * These options extend the defaultOptions for top axes\n         */\n        defaultTopAxisOptions: {\n            labels: {\n                autoRotation: [-45],\n                x: 0,\n                y: -15\n                // overflow: undefined\n                // staggerLines: null\n            },\n            title: {\n                rotation: 0\n            }\n        },\n\n        /**\n         * Initialize the axis\n         */\n        init: function (chart, userOptions) {\n\n\n            var isXAxis = userOptions.isX,\n                axis = this;\n\n            axis.chart = chart;\n\n            // Flag, is the axis horizontal\n            axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n            // Flag, isXAxis\n            axis.isXAxis = isXAxis;\n            axis.coll = isXAxis ? 'xAxis' : 'yAxis';\n\n            axis.opposite = userOptions.opposite; // needed in setOptions\n            axis.side = userOptions.side || (axis.horiz ?\n                    (axis.opposite ? 0 : 2) : // top : bottom\n                    (axis.opposite ? 1 : 3));  // right : left\n\n            axis.setOptions(userOptions);\n\n\n            var options = this.options,\n                type = options.type,\n                isDatetimeAxis = type === 'datetime';\n\n            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n            // Flag, stagger lines or not\n            axis.userOptions = userOptions;\n\n            //axis.axisTitleMargin = undefined,// = options.title.margin,\n            axis.minPixelPadding = 0;\n\n            axis.reversed = options.reversed;\n            axis.visible = options.visible !== false;\n            axis.zoomEnabled = options.zoomEnabled !== false;\n\n            // Initial categories\n            axis.categories = options.categories || type === 'category';\n            axis.names = axis.names || []; // Preserve on update (#3830)\n\n            // Elements\n            //axis.axisGroup = undefined;\n            //axis.gridGroup = undefined;\n            //axis.axisTitle = undefined;\n            //axis.axisLine = undefined;\n\n            // Shorthand types\n            axis.isLog = type === 'logarithmic';\n            axis.isDatetimeAxis = isDatetimeAxis;\n\n            // Flag, if axis is linked to another axis\n            axis.isLinked = defined(options.linkedTo);\n            // Linked axis.\n            //axis.linkedParent = undefined;\n\n            // Tick positions\n            //axis.tickPositions = undefined; // array containing predefined positions\n            // Tick intervals\n            //axis.tickInterval = undefined;\n            //axis.minorTickInterval = undefined;\n\n\n            // Major ticks\n            axis.ticks = {};\n            axis.labelEdge = [];\n            // Minor ticks\n            axis.minorTicks = {};\n\n            // List of plotLines/Bands\n            axis.plotLinesAndBands = [];\n\n            // Alternate bands\n            axis.alternateBands = {};\n\n            // Axis metrics\n            //axis.left = undefined;\n            //axis.top = undefined;\n            //axis.width = undefined;\n            //axis.height = undefined;\n            //axis.bottom = undefined;\n            //axis.right = undefined;\n            //axis.transA = undefined;\n            //axis.transB = undefined;\n            //axis.oldTransA = undefined;\n            axis.len = 0;\n            //axis.oldMin = undefined;\n            //axis.oldMax = undefined;\n            //axis.oldUserMin = undefined;\n            //axis.oldUserMax = undefined;\n            //axis.oldAxisLength = undefined;\n            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n            axis.range = options.range;\n            axis.offset = options.offset || 0;\n\n\n            // Dictionary for stacks\n            axis.stacks = {};\n            axis.oldStacks = {};\n            axis.stacksTouched = 0;\n\n            // Min and max in the data\n            //axis.dataMin = undefined,\n            //axis.dataMax = undefined,\n\n            // The axis range\n            axis.max = null;\n            axis.min = null;\n\n            // User set min and max\n            //axis.userMin = undefined,\n            //axis.userMax = undefined,\n\n            // Crosshair options\n            axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n            // Run Axis\n\n            var eventType,\n                events = axis.options.events;\n\n            // Register\n            if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n                if (isXAxis && !this.isColorAxis) { // #2713\n                    chart.axes.splice(chart.xAxis.length, 0, axis);\n                } else {\n                    chart.axes.push(axis);\n                }\n\n                chart[axis.coll].push(axis);\n            }\n\n            axis.series = axis.series || []; // populated by Series\n\n            // inverted charts have reversed xAxes as default\n            if (chart.inverted && isXAxis && axis.reversed === undefined) {\n                axis.reversed = true;\n            }\n\n            axis.removePlotBand = axis.removePlotBandOrLine;\n            axis.removePlotLine = axis.removePlotBandOrLine;\n\n\n            // register event listeners\n            for (eventType in events) {\n                addEvent(axis, eventType, events[eventType]);\n            }\n\n            // extend logarithmic axis\n            if (axis.isLog) {\n                axis.val2lin = log2lin;\n                axis.lin2val = lin2log;\n            }\n        },\n\n        /**\n         * Merge and set options\n         */\n        setOptions: function (userOptions) {\n            this.options = merge(\n                this.defaultOptions,\n                this.isXAxis ? {} : this.defaultYAxisOptions,\n                [this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n                    this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n                merge(\n                    defaultOptions[this.coll], // if set in setOptions (#1053)\n                    userOptions\n                )\n            );\n        },\n\n        /**\n         * The default label formatter. The context is a special config object for the label.\n         */\n        defaultLabelFormatter: function () {\n            var axis = this.axis,\n                value = this.value,\n                categories = axis.categories,\n                dateTimeLabelFormat = this.dateTimeLabelFormat,\n                numericSymbols = defaultOptions.lang.numericSymbols,\n                i = numericSymbols && numericSymbols.length,\n                multi,\n                ret,\n                formatOption = axis.options.labels.format,\n\n                // make sure the same symbol is added for all labels on a linear axis\n                numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n            if (formatOption) {\n                ret = format(formatOption, this);\n\n            } else if (categories) {\n                ret = value;\n\n            } else if (dateTimeLabelFormat) { // datetime axis\n                ret = H.dateFormat(dateTimeLabelFormat, value);\n\n            } else if (i && numericSymbolDetector >= 1000) {\n                // Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n                // If we are to enable this in tooltip or other places as well, we can move this\n                // logic to the numberFormatter and enable it by a parameter.\n                while (i-- && ret === undefined) {\n                    multi = Math.pow(1000, i + 1);\n                    if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {\n                        ret = H.numberFormat(value / multi, -1) + numericSymbols[i];\n                    }\n                }\n            }\n\n            if (ret === undefined) {\n                if (Math.abs(value) >= 10000) { // add thousands separators\n                    ret = H.numberFormat(value, -1);\n                } else { // small numbers\n                    ret = H.numberFormat(value, -1, undefined, ''); // #2466\n                }\n            }\n\n            return ret;\n        },\n\n        /**\n         * Get the minimum and maximum for the series of each axis\n         */\n        getSeriesExtremes: function () {\n            var axis = this,\n                chart = axis.chart;\n            axis.hasVisibleSeries = false;\n\n            // Reset properties in case we're redrawing (#3353)\n            axis.dataMin = axis.dataMax = axis.threshold = null;\n            axis.softThreshold = !axis.isXAxis;\n\n            if (axis.buildStacks) {\n                axis.buildStacks();\n            }\n\n            // loop through this axis' series\n            each(axis.series, function (series) {\n\n                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                    var seriesOptions = series.options,\n                        xData,\n                        threshold = seriesOptions.threshold,\n                        seriesDataMin,\n                        seriesDataMax;\n\n                    axis.hasVisibleSeries = true;\n\n                    // Validate threshold in logarithmic axes\n                    if (axis.isLog && threshold <= 0) {\n                        threshold = null;\n                    }\n\n                    // Get dataMin and dataMax for X axes\n                    if (axis.isXAxis) {\n                        xData = series.xData;\n                        if (xData.length) {\n                            axis.dataMin = Math.min(pick(axis.dataMin, xData[0]), arrayMin(xData));\n                            axis.dataMax = Math.max(pick(axis.dataMax, xData[0]), arrayMax(xData));\n                        }\n\n                    // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n                    } else {\n\n                        // Get this particular series extremes\n                        series.getExtremes();\n                        seriesDataMax = series.dataMax;\n                        seriesDataMin = series.dataMin;\n\n                        // Get the dataMin and dataMax so far. If percentage is used, the min and max are\n                        // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n                        // doesn't have active y data, we continue with nulls\n                        if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                            axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                            axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n                        }\n\n                        // Adjust to threshold\n                        if (defined(threshold)) {\n                            axis.threshold = threshold;\n                        }\n                        // If any series has a hard threshold, it takes precedence\n                        if (!seriesOptions.softThreshold || axis.isLog) {\n                            axis.softThreshold = false;\n                        }\n                    }\n                }\n            });\n        },\n\n        /**\n         * Translate from axis value to pixel position on the chart, or back\n         *\n         */\n        translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n            var axis = this.linkedParent || this, // #1417\n                sign = 1,\n                cvsOffset = 0,\n                localA = old ? axis.oldTransA : axis.transA,\n                localMin = old ? axis.oldMin : axis.min,\n                returnValue,\n                minPixelPadding = axis.minPixelPadding,\n                doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;\n\n            if (!localA) {\n                localA = axis.transA;\n            }\n\n            // In vertical axes, the canvas coordinates start from 0 at the top like in\n            // SVG.\n            if (cvsCoord) {\n                sign *= -1; // canvas coordinates inverts the value\n                cvsOffset = axis.len;\n            }\n\n            // Handle reversed axis\n            if (axis.reversed) {\n                sign *= -1;\n                cvsOffset -= sign * (axis.sector || axis.len);\n            }\n\n            // From pixels to value\n            if (backwards) { // reverse translation\n\n                val = val * sign + cvsOffset;\n                val -= minPixelPadding;\n                returnValue = val / localA + localMin; // from chart pixel to value\n                if (doPostTranslate) { // log and ordinal axes\n                    returnValue = axis.lin2val(returnValue);\n                }\n\n            // From value to pixels\n            } else {\n                if (doPostTranslate) { // log and ordinal axes\n                    val = axis.val2lin(val);\n                }\n                if (pointPlacement === 'between') {\n                    pointPlacement = 0.5;\n                }\n                returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n                    (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n            }\n\n            return returnValue;\n        },\n\n        /**\n         * Utility method to translate an axis value to pixel position.\n         * @param {Number} value A value in terms of axis units\n         * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n         *        or just the axis/pane itself.\n         */\n        toPixels: function (value, paneCoordinates) {\n            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n        },\n\n        /*\n         * Utility method to translate a pixel position in to an axis value\n         * @param {Number} pixel The pixel value coordinate\n         * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n         *        axis/pane itself.\n         */\n        toValue: function (pixel, paneCoordinates) {\n            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n        },\n\n        /**\n         * Create the path for a plot line that goes from the given value on\n         * this axis, across the plot to the opposite side\n         * @param {Number} value\n         * @param {Number} lineWidth Used for calculation crisp line\n         * @param {Number] old Use old coordinates (for resizing and rescaling)\n         */\n        getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n            var axis = this,\n                chart = axis.chart,\n                axisLeft = axis.left,\n                axisTop = axis.top,\n                x1,\n                y1,\n                x2,\n                y2,\n                cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n                cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n                skip,\n                transB = axis.transB,\n                /**\n                 * Check if x is between a and b. If not, either move to a/b or skip,\n                 * depending on the force parameter.\n                 */\n                between = function (x, a, b) {\n                    if (x < a || x > b) {\n                        if (force) {\n                            x = Math.min(Math.max(a, x), b);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    return x;\n                };\n\n            translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n            x1 = x2 = Math.round(translatedValue + transB);\n            y1 = y2 = Math.round(cHeight - translatedValue - transB);\n\n            if (isNaN(translatedValue)) { // no min or max\n                skip = true;\n\n            } else if (axis.horiz) {\n                y1 = axisTop;\n                y2 = cHeight - axis.bottom;\n                x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n            } else {\n                x1 = axisLeft;\n                x2 = cWidth - axis.right;\n                y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n            }\n            return skip && !force ?\n                null :\n                chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);\n        },\n\n        /**\n         * Set the tick positions of a linear axis to round values like whole tens or every five.\n         */\n        getLinearTickPositions: function (tickInterval, min, max) {\n            var pos,\n                lastPos,\n                roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n                roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n                tickPositions = [];\n\n            // For single points, add a tick regardless of the relative position (#2662)\n            if (min === max && isNumber(min)) {\n                return [min];\n            }\n\n            // Populate the intermediate values\n            pos = roundedMin;\n            while (pos <= roundedMax) {\n\n                // Place the tick on the rounded value\n                tickPositions.push(pos);\n\n                // Always add the raw tickInterval, not the corrected one.\n                pos = correctFloat(pos + tickInterval);\n\n                // If the interval is not big enough in the current min - max range to actually increase\n                // the loop variable, we need to break out to prevent endless loop. Issue #619\n                if (pos === lastPos) {\n                    break;\n                }\n\n                // Record the last value\n                lastPos = pos;\n            }\n            return tickPositions;\n        },\n\n        /**\n         * Return the minor tick positions. For logarithmic axes, reuse the same logic\n         * as for major ticks.\n         */\n        getMinorTickPositions: function () {\n            var axis = this,\n                options = axis.options,\n                tickPositions = axis.tickPositions,\n                minorTickInterval = axis.minorTickInterval,\n                minorTickPositions = [],\n                pos,\n                i,\n                pointRangePadding = axis.pointRangePadding || 0,\n                min = axis.min - pointRangePadding, // #1498\n                max = axis.max + pointRangePadding, // #1498\n                range = max - min,\n                len;\n\n            // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n            if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n                if (axis.isLog) {\n                    len = tickPositions.length;\n                    for (i = 1; i < len; i++) {\n                        minorTickPositions = minorTickPositions.concat(\n                            axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n                        );\n                    }\n                } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n                    minorTickPositions = minorTickPositions.concat(\n                        axis.getTimeTicks(\n                            axis.normalizeTimeTickInterval(minorTickInterval),\n                            min,\n                            max,\n                            options.startOfWeek\n                        )\n                    );\n                } else {\n                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n                        minorTickPositions.push(pos);\n                    }\n                }\n            }\n\n            if (minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks\n                axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498\n            }\n            return minorTickPositions;\n        },\n\n        /**\n         * Adjust the min and max for the minimum range. Keep in mind that the series data is\n         * not yet processed, so we don't have information on data cropping and grouping, or\n         * updated axis.pointRange or series.pointRange. The data can't be processed until\n         * we have finally established min and max.\n         */\n        adjustForMinRange: function () {\n            var axis = this,\n                options = axis.options,\n                min = axis.min,\n                max = axis.max,\n                zoomOffset,\n                spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n                closestDataRange,\n                i,\n                distance,\n                xData,\n                loopLength,\n                minArgs,\n                maxArgs,\n                minRange;\n\n            // Set the automatic minimum range based on the closest point distance\n            if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n\n                if (defined(options.min) || defined(options.max)) {\n                    axis.minRange = null; // don't do this again\n\n                } else {\n\n                    // Find the closest distance between raw data points, as opposed to\n                    // closestPointRange that applies to processed points (cropped and grouped)\n                    each(axis.series, function (series) {\n                        xData = series.xData;\n                        loopLength = series.xIncrement ? 1 : xData.length - 1;\n                        for (i = loopLength; i > 0; i--) {\n                            distance = xData[i] - xData[i - 1];\n                            if (closestDataRange === undefined || distance < closestDataRange) {\n                                closestDataRange = distance;\n                            }\n                        }\n                    });\n                    axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n                }\n            }\n\n            // if minRange is exceeded, adjust\n            if (max - min < axis.minRange) {\n                minRange = axis.minRange;\n                zoomOffset = (minRange - max + min) / 2;\n\n                // if min and max options have been set, don't go beyond it\n                minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n                if (spaceAvailable) { // if space is available, stay within the data range\n                    minArgs[2] = axis.dataMin;\n                }\n                min = arrayMax(minArgs);\n\n                maxArgs = [min + minRange, pick(options.max, min + minRange)];\n                if (spaceAvailable) { // if space is availabe, stay within the data range\n                    maxArgs[2] = axis.dataMax;\n                }\n\n                max = arrayMin(maxArgs);\n\n                // now if the max is adjusted, adjust the min back\n                if (max - min < minRange) {\n                    minArgs[0] = max - minRange;\n                    minArgs[1] = pick(options.min, max - minRange);\n                    min = arrayMax(minArgs);\n                }\n            }\n\n            // Record modified extremes\n            axis.min = min;\n            axis.max = max;\n        },\n\n        /**\n         * Update translation information\n         */\n        setAxisTranslation: function (saveOld) {\n            var axis = this,\n                range = axis.max - axis.min,\n                pointRange = axis.axisPointRange || 0,\n                closestPointRange,\n                minPointOffset = 0,\n                pointRangePadding = 0,\n                linkedParent = axis.linkedParent,\n                ordinalCorrection,\n                hasCategories = !!axis.categories,\n                transA = axis.transA,\n                isXAxis = axis.isXAxis;\n\n            // Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n            if (isXAxis || hasCategories || pointRange) {\n                if (linkedParent) {\n                    minPointOffset = linkedParent.minPointOffset;\n                    pointRangePadding = linkedParent.pointRangePadding;\n\n                } else {\n                    // Find the closestPointRange across all series\n                    each(axis.series, function (series) {\n                        var seriesClosest = series.closestPointRange;\n                        if (!series.noSharedTooltip && defined(seriesClosest)) {\n                            closestPointRange = defined(closestPointRange) ?\n                                Math.min(closestPointRange, seriesClosest) :\n                                seriesClosest;\n                        }\n                    });\n\n                    each(axis.series, function (series) {\n                        var seriesPointRange = hasCategories ? \n                            1 : \n                            (isXAxis ? \n                                pick(series.options.pointRange, closestPointRange, 0) : \n                                (axis.axisPointRange || 0)), // #2806\n                            pointPlacement = series.options.pointPlacement;\n\n                        pointRange = Math.max(pointRange, seriesPointRange);\n\n                        if (!axis.single) {\n                            // minPointOffset is the value padding to the left of the axis in order to make\n                            // room for points with a pointRange, typically columns. When the pointPlacement option\n                            // is 'between' or 'on', this padding does not apply.\n                            minPointOffset = Math.max(\n                                minPointOffset,\n                                isString(pointPlacement) ? 0 : seriesPointRange / 2\n                            );\n\n                            // Determine the total padding needed to the length of the axis to make room for the\n                            // pointRange. If the series' pointPlacement is 'on', no padding is added.\n                            pointRangePadding = Math.max(\n                                pointRangePadding,\n                                pointPlacement === 'on' ? 0 : seriesPointRange\n                            );\n                        }\n                    });\n                }\n\n                // Record minPointOffset and pointRangePadding\n                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n                // pointRange means the width reserved for each point, like in a column chart\n                axis.pointRange = Math.min(pointRange, range);\n\n                // closestPointRange means the closest distance between points. In columns\n                // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n                // is some other value\n                if (isXAxis) {\n                    axis.closestPointRange = closestPointRange;\n                }\n            }\n\n            // Secondary values\n            if (saveOld) {\n                axis.oldTransA = transA;\n            }\n            axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n            axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n            axis.minPixelPadding = transA * minPointOffset;\n        },\n\n        minFromRange: function () {\n            return this.max - this.range;\n        },\n\n        /**\n         * Set the tick positions to round values and optionally extend the extremes\n         * to the nearest tick\n         */\n        setTickInterval: function (secondPass) {\n            var axis = this,\n                chart = axis.chart,\n                options = axis.options,\n                isLog = axis.isLog,\n                isDatetimeAxis = axis.isDatetimeAxis,\n                isXAxis = axis.isXAxis,\n                isLinked = axis.isLinked,\n                maxPadding = options.maxPadding,\n                minPadding = options.minPadding,\n                length,\n                linkedParentExtremes,\n                tickIntervalOption = options.tickInterval,\n                minTickInterval,\n                tickPixelIntervalOption = options.tickPixelInterval,\n                categories = axis.categories,\n                threshold = axis.threshold,\n                softThreshold = axis.softThreshold,\n                thresholdMin,\n                thresholdMax,\n                hardMin,\n                hardMax;\n\n            if (!isDatetimeAxis && !categories && !isLinked) {\n                this.getTickAmount();\n            }\n\n            // Min or max set either by zooming/setExtremes or initial options\n            hardMin = pick(axis.userMin, options.min);\n            hardMax = pick(axis.userMax, options.max);\n\n            // Linked axis gets the extremes from the parent axis\n            if (isLinked) {\n                axis.linkedParent = chart[axis.coll][options.linkedTo];\n                linkedParentExtremes = axis.linkedParent.getExtremes();\n                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                if (options.type !== axis.linkedParent.options.type) {\n                    error(11, 1); // Can't link axes of different type\n                }\n\n            // Initial min and max from the extreme data values\n            } else {\n\n                // Adjust to hard threshold\n                if (!softThreshold && defined(threshold)) {\n                    if (axis.dataMin >= threshold) {\n                        thresholdMin = threshold;\n                        minPadding = 0;\n                    } else if (axis.dataMax <= threshold) {\n                        thresholdMax = threshold;\n                        maxPadding = 0;\n                    }\n                }\n\n                axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n                axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n            }\n\n            if (isLog) {\n                if (!secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n                    error(10, 1); // Can't plot negative values on log axis\n                }\n                // The correctFloat cures #934, float errors on full tens. But it\n                // was too aggressive for #4360 because of conversion back to lin,\n                // therefore use precision 15.\n                axis.min = correctFloat(log2lin(axis.min), 15);\n                axis.max = correctFloat(log2lin(axis.max), 15);\n            }\n\n            // handle zoomed range\n            if (axis.range && defined(axis.max)) {\n                axis.userMin = axis.min = hardMin = Math.max(axis.min, axis.minFromRange()); // #618\n                axis.userMax = hardMax = axis.max;\n\n                axis.range = null;  // don't use it when running setExtremes\n            }\n\n            // Hook for adjusting this.min and this.max. Used by bubble series.\n            if (axis.beforePadding) {\n                axis.beforePadding();\n            }\n\n            // adjust min and max for the minimum range\n            axis.adjustForMinRange();\n\n            // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n            // into account, we do this after computing tick interval (#1337).\n            if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n                length = axis.max - axis.min;\n                if (length) {\n                    if (!defined(hardMin) && minPadding) {\n                        axis.min -= length * minPadding;\n                    }\n                    if (!defined(hardMax)  && maxPadding) {\n                        axis.max += length * maxPadding;\n                    }\n                }\n            }\n\n            // Stay within floor and ceiling\n            if (isNumber(options.floor)) {\n                axis.min = Math.max(axis.min, options.floor);\n            }\n            if (isNumber(options.ceiling)) {\n                axis.max = Math.min(axis.max, options.ceiling);\n            }\n\n            // When the threshold is soft, adjust the extreme value only if\n            // the data extreme and the padded extreme land on either side of the threshold. For example,\n            // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the\n            // default minPadding and startOnTick options. This is prevented by the softThreshold\n            // option.\n            if (softThreshold && defined(axis.dataMin)) {\n                threshold = threshold || 0;\n                if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n                    axis.min = threshold;\n                } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n                    axis.max = threshold;\n                }\n            }\n\n\n            // get tickInterval\n            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n                axis.tickInterval = 1;\n            } else if (isLinked && !tickIntervalOption &&\n                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n                axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n            } else {\n                axis.tickInterval = pick(\n                    tickIntervalOption,\n                    this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,\n                    categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n                        1 :\n                        // don't let it be more than the data range\n                        (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)\n                );\n            }\n\n            // Now we're finished detecting min and max, crop and group series data. This\n            // is in turn needed in order to find tick positions in ordinal axes.\n            if (isXAxis && !secondPass) {\n                each(axis.series, function (series) {\n                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n                });\n            }\n\n            // set the translation factor used in translate function\n            axis.setAxisTranslation(true);\n\n            // hook for ordinal axes and radial axes\n            if (axis.beforeSetTickPositions) {\n                axis.beforeSetTickPositions();\n            }\n\n            // hook for extensions, used in Highstock ordinal axes\n            if (axis.postProcessTickInterval) {\n                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n            }\n\n            // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)\n            if (axis.pointRange && !tickIntervalOption) {\n                axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n            }\n\n            // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n            minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n                axis.tickInterval = minTickInterval;\n            }\n\n            // for linear axes, get magnitude and normalize the interval\n            if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n                axis.tickInterval = normalizeTickInterval(\n                    axis.tickInterval,\n                    null,\n                    getMagnitude(axis.tickInterval),\n                    // If the tick interval is between 0.5 and 5 and the axis max is in the order of\n                    // thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n                    pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n                    !!this.tickAmount\n                );\n            }\n\n            // Prevent ticks from getting so close that we can't draw the labels\n            if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length\n                axis.tickInterval = axis.unsquish();\n            }\n\n            this.setTickPositions();\n        },\n\n        /**\n         * Now we have computed the normalized tickInterval, get the tick positions\n         */\n        setTickPositions: function () {\n\n            var options = this.options,\n                tickPositions,\n                tickPositionsOption = options.tickPositions,\n                tickPositioner = options.tickPositioner,\n                startOnTick = options.startOnTick,\n                endOnTick = options.endOnTick,\n                single;\n\n            // Set the tickmarkOffset\n            this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&\n                this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n            // get minorTickInterval\n            this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n                this.tickInterval / 5 : options.minorTickInterval;\n\n            // Find the tick positions\n            this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)\n            if (!tickPositions) {\n\n                if (this.isDatetimeAxis) {\n                    tickPositions = this.getTimeTicks(\n                        this.normalizeTimeTickInterval(this.tickInterval, options.units),\n                        this.min,\n                        this.max,\n                        options.startOfWeek,\n                        this.ordinalPositions,\n                        this.closestPointRange,\n                        true\n                    );\n                } else if (this.isLog) {\n                    tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n                } else {\n                    tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n                }\n\n                // Too dense ticks, keep only the first and last (#4477)\n                if (tickPositions.length > this.len) {\n                    tickPositions = [tickPositions[0], tickPositions.pop()];\n                }\n\n                this.tickPositions = tickPositions;\n\n                // Run the tick positioner callback, that allows modifying auto tick positions.\n                if (tickPositioner) {\n                    tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n                    if (tickPositioner) {\n                        this.tickPositions = tickPositions = tickPositioner;\n                    }\n                }\n\n            }\n\n            if (!this.isLinked) {\n\n                // reset min/max or remove extremes based on start/end on tick\n                this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n                // When there is only one point, or all points have the same value on this axis, then min\n                // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n                // in order to center the point, but leave it with one tick. #1337.\n                if (this.min === this.max && defined(this.min) && !this.tickAmount) {\n                    // Substract half a unit (#2619, #2846, #2515, #3390)\n                    single = true;\n                    this.min -= 0.5;\n                    this.max += 0.5;\n                }\n                this.single = single;\n\n                if (!tickPositionsOption && !tickPositioner) {\n                    this.adjustTickAmount();\n                }\n            }\n        },\n\n        /**\n         * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n         */\n        trimTicks: function (tickPositions, startOnTick, endOnTick) {\n            var roundedMin = tickPositions[0],\n                roundedMax = tickPositions[tickPositions.length - 1],\n                minPointOffset = this.minPointOffset || 0;\n\n            if (startOnTick) {\n                this.min = roundedMin;\n            } else {\n                while (this.min - minPointOffset > tickPositions[0]) {\n                    tickPositions.shift();\n                }\n            }\n\n            if (endOnTick) {\n                this.max = roundedMax;\n            } else {\n                while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n                    tickPositions.pop();\n                }\n            }\n\n            // If no tick are left, set one tick in the middle (#3195)\n            if (tickPositions.length === 0 && defined(roundedMin)) {\n                tickPositions.push((roundedMax + roundedMin) / 2);\n            }\n        },\n\n        /**\n         * Check if there are multiple axes in the same pane\n         * @returns {Boolean} There are other axes\n         */\n        alignToOthers: function () {\n            var others = {}, // Whether there is another axis to pair with this one\n                hasOther,\n                options = this.options;\n\n            if (this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n                each(this.chart[this.coll], function (axis) {\n                    var otherOptions = axis.options,\n                        horiz = axis.horiz,\n                        key = [\n                            horiz ? otherOptions.left : otherOptions.top, \n                            otherOptions.width,\n                            otherOptions.height, \n                            otherOptions.pane\n                        ].join(',');\n\n\n                    if (axis.series.length) { // #4442\n                        if (others[key]) {\n                            hasOther = true; // #4201\n                        } else {\n                            others[key] = 1;\n                        }\n                    }\n                });\n            }\n            return hasOther;\n        },\n\n        /**\n         * Set the max ticks of either the x and y axis collection\n         */\n        getTickAmount: function () {\n            var options = this.options,\n                tickAmount = options.tickAmount,\n                tickPixelInterval = options.tickPixelInterval;\n\n            if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n                    !this.isLog && options.startOnTick && options.endOnTick) {\n                tickAmount = 2;\n            }\n\n            if (!tickAmount && this.alignToOthers()) {\n                // Add 1 because 4 tick intervals require 5 ticks (including first and last)\n                tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n            }\n\n            // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n            // prevents the axis from adding ticks that are too far away from the data extremes.\n            if (tickAmount < 4) {\n                this.finalTickAmt = tickAmount;\n                tickAmount = 5;\n            }\n\n            this.tickAmount = tickAmount;\n        },\n\n        /**\n         * When using multiple axes, adjust the number of ticks to match the highest\n         * number of ticks in that group\n         */\n        adjustTickAmount: function () {\n            var tickInterval = this.tickInterval,\n                tickPositions = this.tickPositions,\n                tickAmount = this.tickAmount,\n                finalTickAmt = this.finalTickAmt,\n                currentTickAmount = tickPositions && tickPositions.length,\n                i,\n                len;\n\n            if (currentTickAmount < tickAmount) {\n                while (tickPositions.length < tickAmount) {\n                    tickPositions.push(correctFloat(\n                        tickPositions[tickPositions.length - 1] + tickInterval\n                    ));\n                }\n                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                this.max = tickPositions[tickPositions.length - 1];\n\n            // We have too many ticks, run second pass to try to reduce ticks\n            } else if (currentTickAmount > tickAmount) {\n                this.tickInterval *= 2;\n                this.setTickPositions();\n            }\n\n            // The finalTickAmt property is set in getTickAmount\n            if (defined(finalTickAmt)) {\n                i = len = tickPositions.length;\n                while (i--) {\n                    if (\n                        (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n                        (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n                    ) {\n                        tickPositions.splice(i, 1);\n                    }\n                }\n                this.finalTickAmt = undefined;\n            }\n        },\n\n        /**\n         * Set the scale based on data min and max, user set min and max or options\n         *\n         */\n        setScale: function () {\n            var axis = this,\n                isDirtyData,\n                isDirtyAxisLength;\n\n            axis.oldMin = axis.min;\n            axis.oldMax = axis.max;\n            axis.oldAxisLength = axis.len;\n\n            // set the new axisLength\n            axis.setAxisSize();\n            //axisLength = horiz ? axisWidth : axisHeight;\n            isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n            // is there new data?\n            each(axis.series, function (series) {\n                if (series.isDirtyData || series.isDirty ||\n                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n                    isDirtyData = true;\n                }\n            });\n\n            // do we really need to go through all this?\n            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n                axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n\n                if (axis.resetStacks) {\n                    axis.resetStacks();\n                }\n\n                axis.forceRedraw = false;\n\n                // get data extremes if needed\n                axis.getSeriesExtremes();\n\n                // get fixed positions based on tickInterval\n                axis.setTickInterval();\n\n                // record old values to decide whether a rescale is necessary later on (#540)\n                axis.oldUserMin = axis.userMin;\n                axis.oldUserMax = axis.userMax;\n\n                // Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n                if (!axis.isDirty) {\n                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n                }\n            } else if (axis.cleanStacks) {\n                axis.cleanStacks();\n            }\n        },\n\n        /**\n         * Set the extremes and optionally redraw\n         * @param {Number} newMin\n         * @param {Number} newMax\n         * @param {Boolean} redraw\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         * @param {Object} eventArguments\n         *\n         */\n        setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n            var axis = this,\n                chart = axis.chart;\n\n            redraw = pick(redraw, true); // defaults to true\n\n            each(axis.series, function (serie) {\n                delete serie.kdTree;\n            });\n\n            // Extend the arguments with min and max\n            eventArguments = extend(eventArguments, {\n                min: newMin,\n                max: newMax\n            });\n\n            // Fire the event\n            fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n                axis.userMin = newMin;\n                axis.userMax = newMax;\n                axis.eventArgs = eventArguments;\n\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            });\n        },\n\n        /**\n         * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n         * in stock charts.\n         */\n        zoom: function (newMin, newMax) {\n            var dataMin = this.dataMin,\n                dataMax = this.dataMax,\n                options = this.options,\n                min = Math.min(dataMin, pick(options.min, dataMin)),\n                max = Math.max(dataMax, pick(options.max, dataMax));\n\n            // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n            if (!this.allowZoomOutside) {\n                if (defined(dataMin) && newMin <= min) {\n                    newMin = min;\n                }\n                if (defined(dataMax) && newMax >= max) {\n                    newMax = max;\n                }\n            }\n\n            // In full view, displaying the reset zoom button is not required\n            this.displayBtn = newMin !== undefined || newMax !== undefined;\n\n            // Do it\n            this.setExtremes(\n                newMin,\n                newMax,\n                false,\n                undefined,\n                { trigger: 'zoom' }\n            );\n            return true;\n        },\n\n        /**\n         * Update the axis metrics\n         */\n        setAxisSize: function () {\n            var chart = this.chart,\n                options = this.options,\n                offsetLeft = options.offsetLeft || 0,\n                offsetRight = options.offsetRight || 0,\n                horiz = this.horiz,\n                width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n                height = pick(options.height, chart.plotHeight),\n                top = pick(options.top, chart.plotTop),\n                left = pick(options.left, chart.plotLeft + offsetLeft),\n                percentRegex = /%$/;\n\n            // Check for percentage based input values. Rounding fixes problems with\n            // column overflow and plot line filtering (#4898, #4899)\n            if (percentRegex.test(height)) {\n                //height = Math.round(parseFloat(height) / 100 * chart.plotHeight);\n                height = parseFloat(height) / 100 * chart.plotHeight;\n            }\n            if (percentRegex.test(top)) {\n                //top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);\n                top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;\n            }\n\n            // Expose basic values to use in Series object and navigator\n            this.left = left;\n            this.top = top;\n            this.width = width;\n            this.height = height;\n            this.bottom = chart.chartHeight - height - top;\n            this.right = chart.chartWidth - width - left;\n\n            // Direction agnostic properties\n            this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n            this.pos = horiz ? left : top; // distance from SVG origin\n        },\n\n        /**\n         * Get the actual axis extremes\n         */\n        getExtremes: function () {\n            var axis = this,\n                isLog = axis.isLog;\n\n            return {\n                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n                dataMin: axis.dataMin,\n                dataMax: axis.dataMax,\n                userMin: axis.userMin,\n                userMax: axis.userMax\n            };\n        },\n\n        /**\n         * Get the zero plane either based on zero or on the min or max value.\n         * Used in bar and area plots\n         */\n        getThreshold: function (threshold) {\n            var axis = this,\n                isLog = axis.isLog,\n                realMin = isLog ? lin2log(axis.min) : axis.min,\n                realMax = isLog ? lin2log(axis.max) : axis.max;\n\n            // With a threshold of null, make the columns/areas rise from the top or bottom\n            // depending on the value, assuming an actual threshold of 0 (#4233).\n            if (threshold === null) {\n                threshold = realMax < 0 ? realMax : realMin;\n            } else if (realMin > threshold) {\n                threshold = realMin;\n            } else if (realMax < threshold) {\n                threshold = realMax;\n            }\n\n            return axis.translate(threshold, 0, 1, 0, 1);\n        },\n\n        /**\n         * Compute auto alignment for the axis label based on which side the axis is on\n         * and the given rotation for the label\n         */\n        autoLabelAlign: function (rotation) {\n            var ret,\n                angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n            if (angle > 15 && angle < 165) {\n                ret = 'right';\n            } else if (angle > 195 && angle < 345) {\n                ret = 'left';\n            } else {\n                ret = 'center';\n            }\n            return ret;\n        },\n\n        /**\n         * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n         * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.\n         * On a vertical axis remove ticks and add ellipsis.\n         */\n        unsquish: function () {\n            var chart = this.chart,\n                ticks = this.ticks,\n                labelOptions = this.options.labels,\n                horiz = this.horiz,\n                tickInterval = this.tickInterval,\n                newTickInterval = tickInterval,\n                slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n                rotation,\n                rotationOption = labelOptions.rotation,\n                labelMetrics = chart.renderer.fontMetrics(labelOptions.style && labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n                step,\n                bestScore = Number.MAX_VALUE,\n                autoRotation,\n                // Return the multiple of tickInterval that is needed to avoid collision\n                getStep = function (spaceNeeded) {\n                    var step = spaceNeeded / (slotSize || 1);\n                    step = step > 1 ? Math.ceil(step) : 1;\n                    return step * tickInterval;\n                };\n\n            if (horiz) {\n                autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n                    defined(rotationOption) ?\n                        [rotationOption] :\n                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation\n                );\n\n                if (autoRotation) {\n\n                    // Loop over the given autoRotation options, and determine which gives the best score. The\n                    // best score is that with the lowest number of steps and a rotation closest to horizontal.\n                    each(autoRotation, function (rot) {\n                        var score;\n\n                        if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n                    \n                            step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));\n\n                            score = step + Math.abs(rot / 360);\n\n                            if (score < bestScore) {\n                                bestScore = score;\n                                rotation = rot;\n                                newTickInterval = step;\n                            }\n                        }\n                    });\n                }\n\n            } else if (!labelOptions.step) { // #4411\n                newTickInterval = getStep(labelMetrics.h);\n            }\n\n            this.autoRotation = autoRotation;\n            this.labelRotation = pick(rotation, rotationOption);\n\n            return newTickInterval;\n        },\n\n        renderUnsquish: function () {\n            var chart = this.chart,\n                renderer = chart.renderer,\n                tickPositions = this.tickPositions,\n                ticks = this.ticks,\n                labelOptions = this.options.labels,\n                horiz = this.horiz,\n                margin = chart.margin,\n                slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,\n                slotWidth = this.slotWidth = (horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415\n                    ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||\n                    (!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,\n                innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),\n                attr = {},\n                labelMetrics = renderer.fontMetrics(labelOptions.style && labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n                textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,\n                css,\n                labelLength = 0,\n                label,\n                i,\n                pos;\n\n            // Set rotation option unless it is ___doublequote___auto___doublequote___, like in gauges\n            if (!isString(labelOptions.rotation)) {\n                attr.rotation = labelOptions.rotation || 0; // #4443\n            }\n\n            // Handle auto rotation on horizontal axis\n            if (this.autoRotation) {\n\n                // Get the longest label length\n                each(tickPositions, function (tick) {\n                    tick = ticks[tick];\n                    if (tick && tick.labelLength > labelLength) {\n                        labelLength = tick.labelLength;\n                    }\n                });\n\n                // Apply rotation only if the label is too wide for the slot, and\n                // the label is wider than its height.\n                if (labelLength > innerWidth && labelLength > labelMetrics.h) {\n                    attr.rotation = this.labelRotation;\n                } else {\n                    this.labelRotation = 0;\n                }\n\n            // Handle word-wrap or ellipsis on vertical axis\n            } else if (slotWidth) {\n                // For word-wrap or ellipsis\n                css = { width: innerWidth + 'px' };\n\n                if (!textOverflowOption) {\n                    css.textOverflow = 'clip';\n\n                    // On vertical axis, only allow word wrap if there is room for more lines.\n                    i = tickPositions.length;\n                    while (!horiz && i--) {\n                        pos = tickPositions[i];\n                        label = ticks[pos].label;\n                        if (label) {\n                            // Reset ellipsis in order to get the correct bounding box (#4070)\n                            if (label.styles && label.styles.textOverflow === 'ellipsis') {\n                                label.css({ textOverflow: 'clip' });\n                            }\n                            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f) ||\n                                    ticks[pos].labelLength > slotWidth) { // #4678\n                                label.specCss = { textOverflow: 'ellipsis' };\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            // Add ellipsis if the label length is significantly longer than ideal\n            if (attr.rotation) {\n                css = { \n                    width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'\n                };\n                if (!textOverflowOption) {\n                    css.textOverflow = 'ellipsis';\n                }\n            }\n\n            // Set the explicit or automatic label alignment\n            this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n\n            // Apply general and specific CSS\n            each(tickPositions, function (pos) {\n                var tick = ticks[pos],\n                    label = tick && tick.label;\n                if (label) {\n                    label.attr(attr); // This needs to go before the CSS in old IE (#4502)\n                    if (css) {\n                        label.css(merge(css, label.specCss));\n                    }\n                    delete label.specCss;\n                    tick.rotation = attr.rotation;\n                }\n            });\n\n            // Note: Why is this not part of getLabelPosition?\n            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n        },\n\n        /**\n         * Return true if the axis has associated data\n         */\n        hasData: function () {\n            return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);\n        },\n\n        /**\n         * Render the tick labels to a preliminary position to get their sizes\n         */\n        getOffset: function () {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                options = axis.options,\n                tickPositions = axis.tickPositions,\n                ticks = axis.ticks,\n                horiz = axis.horiz,\n                side = axis.side,\n                invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n                hasData,\n                showAxis,\n                titleOffset = 0,\n                titleOffsetOption,\n                titleMargin = 0,\n                axisTitleOptions = options.title,\n                labelOptions = options.labels,\n                labelOffset = 0, // reset\n                labelOffsetPadded,\n                opposite = axis.opposite,\n                axisOffset = chart.axisOffset,\n                clipOffset = chart.clipOffset,\n                clip,\n                directionFactor = [-1, 1, 1, -1][side],\n                n,\n                axisParent = axis.axisParent, // Used in color axis\n                lineHeightCorrection;\n\n            // For reuse in Axis.render\n            hasData = axis.hasData();\n            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n            // Set/reset staggerLines\n            axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n            // Create the axisGroup and gridGroup elements on first iteration\n            if (!axis.axisGroup) {\n                axis.gridGroup = renderer.g('grid')\n                    .attr({ zIndex: options.gridZIndex || 1 })\n                    .add(axisParent);\n                axis.axisGroup = renderer.g('axis')\n                    .attr({ zIndex: options.zIndex || 2 })\n                    .add(axisParent);\n                axis.labelGroup = renderer.g('axis-labels')\n                    .attr({ zIndex: labelOptions.zIndex || 7 })\n                    .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels')\n                    .add(axisParent);\n            }\n\n            if (hasData || axis.isLinked) {\n\n                // Generate ticks\n                each(tickPositions, function (pos) {\n                    if (!ticks[pos]) {\n                        ticks[pos] = new Tick(axis, pos);\n                    } else {\n                        ticks[pos].addLabel(); // update labels depending on tick interval\n                    }\n                });\n\n                axis.renderUnsquish();\n\n\n                // Left side must be align: right and right side must have align: left for labels\n                if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 ||\n                        { 1: 'left', 3: 'right' }[side] === axis.labelAlign || axis.labelAlign === 'center')) {\n                    each(tickPositions, function (pos) {\n\n                        // get the highest offset\n                        labelOffset = Math.max(\n                            ticks[pos].getLabelSize(),\n                            labelOffset\n                        );\n                    });\n                }\n\n                if (axis.staggerLines) {\n                    labelOffset *= axis.staggerLines;\n                    axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n                }\n\n\n            } else { // doesn't have data\n                for (n in ticks) {\n                    ticks[n].destroy();\n                    delete ticks[n];\n                }\n            }\n\n            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n                if (!axis.axisTitle) {\n                    axis.axisTitle = renderer.text(\n                        axisTitleOptions.text,\n                        0,\n                        0,\n                        axisTitleOptions.useHTML\n                    )\n                    .attr({\n                        zIndex: 7,\n                        rotation: axisTitleOptions.rotation || 0,\n                        align: \n                            axisTitleOptions.textAlign ||\n                            { \n                                low: opposite ? 'right' : 'left',\n                                middle: 'center',\n                                high: opposite ? 'left' : 'right'\n                            }[axisTitleOptions.align]\n                    })\n                    .addClass('highcharts-axis-title highcharts-' + this.coll.toLowerCase() + '-title')\n                    ";
if (build.classic) { 
s += "\n                    .css(axisTitleOptions.style)\n                    ";
} 
s += "\n                    .add(axis.axisGroup);\n                    axis.axisTitle.isNew = true;\n                }\n\n                if (showAxis) {\n                    titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                    titleOffsetOption = axisTitleOptions.offset;\n                    titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n                }\n\n                // hide or show the title depending on whether showEmpty is set\n                axis.axisTitle[showAxis ? 'show' : 'hide'](true);\n            }\n\n            // handle automatic or user set offset\n            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n            lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;\n            labelOffsetPadded = Math.abs(labelOffset) + titleMargin +\n                (labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));\n            axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n            axisOffset[side] = Math.max(\n                axisOffset[side],\n                axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n                labelOffsetPadded // #3027\n            );\n\n            // Decide the clipping needed to keep the graph inside the plot area and axis lines\n            clip = options.offset ? 0 : Math.floor(options.lineWidth / 2) * 2; // #4308, #4371\n            clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);\n        },\n\n        /**\n         * Get the path for the axis line\n         */\n        getLinePath: function (lineWidth) {\n            var chart = this.chart,\n                opposite = this.opposite,\n                offset = this.offset,\n                horiz = this.horiz,\n                lineLeft = this.left + (opposite ? this.width : 0) + offset,\n                lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n            if (opposite) {\n                lineWidth *= -1; // crispify the other way - #1480, #1687\n            }\n\n            return chart.renderer\n                .crispLine([\n                    'M',\n                    horiz ?\n                        this.left :\n                        lineLeft,\n                    horiz ?\n                        lineTop :\n                        this.top,\n                    'L',\n                    horiz ?\n                        chart.chartWidth - this.right :\n                        lineLeft,\n                    horiz ?\n                        lineTop :\n                        chart.chartHeight - this.bottom\n                ], lineWidth);\n        },\n\n        /**\n         * Position the title\n         */\n        getTitlePosition: function () {\n            // compute anchor points for each of the title align options\n            var horiz = this.horiz,\n                axisLeft = this.left,\n                axisTop = this.top,\n                axisLength = this.len,\n                axisTitleOptions = this.options.title,\n                margin = horiz ? axisLeft : axisTop,\n                opposite = this.opposite,\n                offset = this.offset,\n                xOption = axisTitleOptions.x || 0,\n                yOption = axisTitleOptions.y || 0,\n                fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, this.axisTitle).f,\n\n                // the position in the length direction of the axis\n                alongAxis = {\n                    low: margin + (horiz ? 0 : axisLength),\n                    middle: margin + axisLength / 2,\n                    high: margin + (horiz ? axisLength : 0)\n                }[axisTitleOptions.align],\n\n                // the position in the perpendicular direction of the axis\n                offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                    (opposite ? -1 : 1) * // so does opposite axes\n                    this.axisTitleMargin +\n                    (this.side === 2 ? fontSize : 0);\n\n            return {\n                x: horiz ?\n                    alongAxis + xOption :\n                    offAxis + (opposite ? this.width : 0) + offset + xOption,\n                y: horiz ?\n                    offAxis + yOption - (opposite ? this.height : 0) + offset :\n                    alongAxis + yOption\n            };\n        },\n\n        /**\n         * Render the axis\n         */\n        render: function () {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                options = axis.options,\n                isLog = axis.isLog,\n                isLinked = axis.isLinked,\n                tickPositions = axis.tickPositions,\n                axisTitle = axis.axisTitle,\n                ticks = axis.ticks,\n                minorTicks = axis.minorTicks,\n                alternateBands = axis.alternateBands,\n                stackLabelOptions = options.stackLabels,\n                alternateGridColor = options.alternateGridColor,\n                tickmarkOffset = axis.tickmarkOffset,\n                lineWidth = options.lineWidth,\n                linePath,\n                hasRendered = chart.hasRendered,\n                slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),\n                showAxis = axis.showAxis,\n                globalAnimation = renderer.globalAnimation,\n                from,\n                to;\n\n            // Reset\n            axis.labelEdge.length = 0;\n            //axis.justifyToPlot = overflow === 'justify';\n            axis.overlap = false;\n\n            // Mark all elements inActive before we go over and mark the active ones\n            each([ticks, minorTicks, alternateBands], function (coll) {\n                var pos;\n                for (pos in coll) {\n                    coll[pos].isActive = false;\n                }\n            });\n\n            // If the series has data draw the ticks. Else only the line and title\n            if (axis.hasData() || isLinked) {\n\n                // minor ticks\n                if (axis.minorTickInterval && !axis.categories) {\n                    each(axis.getMinorTickPositions(), function (pos) {\n                        if (!minorTicks[pos]) {\n                            minorTicks[pos] = new Tick(axis, pos, 'minor');\n                        }\n\n                        // render new ticks in old position\n                        if (slideInTicks && minorTicks[pos].isNew) {\n                            minorTicks[pos].render(null, true);\n                        }\n\n                        minorTicks[pos].render(null, false, 1);\n                    });\n                }\n\n                // Major ticks. Pull out the first item and render it last so that\n                // we can get the position of the neighbour label. #808.\n                if (tickPositions.length) { // #1300\n                    each(tickPositions, function (pos, i) {\n\n                        // linked axes need an extra check to find out if\n                        if (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n                            if (!ticks[pos]) {\n                                ticks[pos] = new Tick(axis, pos);\n                            }\n\n                            // render new ticks in old position\n                            if (slideInTicks && ticks[pos].isNew) {\n                                ticks[pos].render(i, true, 0.1);\n                            }\n\n                            ticks[pos].render(i);\n                        }\n\n                    });\n                    // In a categorized axis, the tick marks are displayed between labels. So\n                    // we need to add a tick mark and grid line at the left edge of the X axis.\n                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                        if (!ticks[-1]) {\n                            ticks[-1] = new Tick(axis, -1, null, true);\n                        }\n                        ticks[-1].render(-1);\n                    }\n\n                }\n\n                // alternate grid color\n                if (alternateGridColor) {\n                    each(tickPositions, function (pos, i) {\n                        to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; \n                        if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660\n                            if (!alternateBands[pos]) {\n                                alternateBands[pos] = new PlotLineOrBand(axis);\n                            }\n                            from = pos + tickmarkOffset; // #949\n                            alternateBands[pos].options = {\n                                from: isLog ? lin2log(from) : from,\n                                to: isLog ? lin2log(to) : to,\n                                color: alternateGridColor\n                            };\n                            alternateBands[pos].render();\n                            alternateBands[pos].isActive = true;\n                        }\n                    });\n                }\n\n                // custom plot lines and bands\n                if (!axis._addedPlotLB) { // only first time\n                    each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n                        axis.addPlotBandOrLine(plotLineOptions);\n                    });\n                    axis._addedPlotLB = true;\n                }\n\n            } // end if hasData\n\n            // Remove inactive ticks\n            each([ticks, minorTicks, alternateBands], function (coll) {\n                var pos,\n                    i,\n                    forDestruction = [],\n                    delay = globalAnimation ? globalAnimation.duration || 500 : 0,\n                    destroyInactiveItems = function () {\n                        i = forDestruction.length;\n                        while (i--) {\n                            // When resizing rapidly, the same items may be destroyed in different timeouts,\n                            // or the may be reactivated\n                            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n                                coll[forDestruction[i]].destroy();\n                                delete coll[forDestruction[i]];\n                            }\n                        }\n\n                    };\n\n                for (pos in coll) {\n\n                    if (!coll[pos].isActive) {\n                        // Render to zero opacity\n                        coll[pos].render(pos, false, 0);\n                        coll[pos].isActive = false;\n                        forDestruction.push(pos);\n                    }\n                }\n\n                // When the objects are finished fading out, destroy them\n                syncTimeout(\n                    destroyInactiveItems, \n                    coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay\n                );\n            });\n\n            // Static items. As the axis group is cleared on subsequent calls\n            // to render, these items are added outside the group.\n            // axis line\n            if (lineWidth) {\n                linePath = axis.getLinePath(lineWidth);\n                if (!axis.axisLine) {\n                    axis.axisLine = renderer.path(linePath)\n                        .addClass('highcharts-axis-line')\n                        .attr({\n                            stroke: options.lineColor,\n                            'stroke-width': lineWidth,\n                            zIndex: 7\n                        })\n                        .add(axis.axisGroup);\n                } else {\n                    axis.axisLine.animate({ d: linePath });\n                }\n\n                // show or hide the line depending on options.showEmpty\n                axis.axisLine[showAxis ? 'show' : 'hide'](true);\n            }\n\n            if (axisTitle && showAxis) {\n\n                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n                    axis.getTitlePosition()\n                );\n                axisTitle.isNew = false;\n            }\n\n            // Stacked totals:\n            if (stackLabelOptions && stackLabelOptions.enabled) {\n                axis.renderStackTotals();\n            }\n            // End stacked totals\n\n            axis.isDirty = false;\n        },\n\n        /**\n         * Redraw the axis to reflect changes in the data or axis extremes\n         */\n        redraw: function () {\n\n            if (this.visible) {\n                // render the axis\n                this.render();\n\n                // move plot lines and bands\n                each(this.plotLinesAndBands, function (plotLine) {\n                    plotLine.render();\n                });\n            }\n\n            // mark associated series as dirty and ready for redraw\n            each(this.series, function (series) {\n                series.isDirty = true;\n            });\n\n        },\n\n        /**\n         * Destroys an Axis instance.\n         */\n        destroy: function (keepEvents) {\n            var axis = this,\n                stacks = axis.stacks,\n                stackKey,\n                plotLinesAndBands = axis.plotLinesAndBands,\n                i;\n\n            // Remove the events\n            if (!keepEvents) {\n                removeEvent(axis);\n            }\n\n            // Destroy each stack total\n            for (stackKey in stacks) {\n                destroyObjectProperties(stacks[stackKey]);\n\n                stacks[stackKey] = null;\n            }\n\n            // Destroy collections\n            each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n                destroyObjectProperties(coll);\n            });\n            i = plotLinesAndBands.length;\n            while (i--) { // #1975\n                plotLinesAndBands[i].destroy();\n            }\n\n            // Destroy local variables\n            each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {\n                if (axis[prop]) {\n                    axis[prop] = axis[prop].destroy();\n                }\n            });\n\n            // Destroy crosshair\n            if (this.cross) {\n                this.cross.destroy();\n            }\n        },\n\n        /**\n         * Draw the crosshair\n         * \n         * @param  {Object} e The event arguments from the modified pointer event\n         * @param  {Object} point The Point object\n         */\n        drawCrosshair: function (e, point) {\n\n            var path,\n                options = this.crosshair,\n                pos,\n                attribs,\n                categorized,\n                strokeWidth;\n\n            if (\n                // Disabled in options\n                !this.crosshair ||\n                // Snap\n                ((defined(point) || !pick(options.snap, true)) === false) ||\n                // Not on this axis (#4095, #2888)\n                (point && point.series && point.series[this.coll] !== this)\n            ) {\n                this.hideCrosshair();\n\n            } else {\n\n                // Get the path\n                if (!pick(options.snap, true)) {\n                    pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n                } else if (defined(point)) {\n                    pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n                }\n\n                if (this.isRadial) {\n                    path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n                } else {\n                    path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n                }\n\n                if (path === null) {\n                    this.hideCrosshair();\n                    return;\n                }\n\n                categorized = this.categories && !this.isRadial;\n                strokeWidth = pick(options.width, (categorized ? this.transA : 1));\n\n                // Draw the cross\n                if (this.cross) {\n                    this.cross\n                        .attr({\n                            d: path,\n                            visibility: 'visible',\n                            'stroke-width': strokeWidth // #4737\n                        });\n                } else {\n                    attribs = {\n                        'stroke-width': strokeWidth,\n                        stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n                        zIndex: pick(options.zIndex, 2)\n                    };\n                    ";
if (build.classic) { 
s += "\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                    ";
} 
s += "\n                    this.cross = this.chart.renderer.path(path).attr(attribs).add();\n                }\n\n            }\n\n        },\n\n        /**\n         *    Hide the crosshair.\n         */\n        hideCrosshair: function () {\n            if (this.cross) {\n                this.cross.hide();\n            }\n        }\n    }; // end Axis\n\n    extend(H.Axis.prototype, AxisPlotLineOrBandExtension);\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Axis = H.Axis,\n            getMagnitude = H.getMagnitude,\n            lin2log = H.lin2log,\n            log2lin = H.log2lin,\n            map = H.map,\n            normalizeTickInterval = H.normalizeTickInterval,\n            pick = H.pick;\n    /**\n     * Methods defined on the Axis prototype\n     */\n\n    /**\n     * Set the tick positions of a logarithmic axis\n     */\n    Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n        var axis = this,\n            options = axis.options,\n            axisLength = axis.len,\n            // Since we use this method for both major and minor ticks,\n            // use a local variable and return the result\n            positions = [];\n\n        // Reset\n        if (!minor) {\n            axis._minorAutoInterval = null;\n        }\n\n        // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n        if (interval >= 0.5) {\n            interval = Math.round(interval);\n            positions = axis.getLinearTickPositions(interval, min, max);\n\n        // Second case: We need intermediary ticks. For example\n        // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n        } else if (interval >= 0.08) {\n            var roundedMin = Math.floor(min),\n                intermediate,\n                i,\n                j,\n                len,\n                pos,\n                lastPos,\n                break2;\n\n            if (interval > 0.3) {\n                intermediate = [1, 2, 4];\n            } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n                intermediate = [1, 2, 4, 6, 8];\n            } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n            }\n\n            for (i = roundedMin; i < max + 1 && !break2; i++) {\n                len = intermediate.length;\n                for (j = 0; j < len && !break2; j++) {\n                    pos = log2lin(lin2log(i) * intermediate[j]);\n                    if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113\n                        positions.push(lastPos);\n                    }\n\n                    if (lastPos > max) {\n                        break2 = true;\n                    }\n                    lastPos = pos;\n                }\n            }\n\n        // Third case: We are so deep in between whole logarithmic values that\n        // we might as well handle the tick positions like a linear axis. For\n        // example 1.01, 1.02, 1.03, 1.04.\n        } else {\n            var realMin = lin2log(min),\n                realMax = lin2log(max),\n                tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n                filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n                tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n                totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\n            interval = pick(\n                filteredTickIntervalOption,\n                axis._minorAutoInterval,\n                (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n            );\n\n            interval = normalizeTickInterval(\n                interval,\n                null,\n                getMagnitude(interval)\n            );\n\n            positions = map(axis.getLinearTickPositions(\n                interval,\n                realMin,\n                realMax\n            ), log2lin);\n\n            if (!minor) {\n                axis._minorAutoInterval = interval / 5;\n            }\n        }\n\n        // Set the axis-level tickInterval variable\n        if (!minor) {\n            axis.tickInterval = interval;\n        }\n        return positions;\n    };\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var dateFormat = H.dateFormat,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            isNumber = H.isNumber,\n            map = H.map,\n            pick = H.pick,\n            splat = H.splat,\n            stop = H.stop,\n            syncTimeout = H.syncTimeout,\n            timeUnits = H.timeUnits,\n            useCanVG = H.useCanVG;\n    /**\n     * The tooltip object\n     * @param {Object} chart The chart instance\n     * @param {Object} options Tooltip options\n     */\n    H.Tooltip = function () {\n        this.init.apply(this, arguments);\n    };\n\n    H.Tooltip.prototype = {\n\n        init: function (chart, options) {\n\n            // Save the chart and options\n            this.chart = chart;\n            this.options = options;\n\n            // Keep track of the current series\n            //this.currentSeries = undefined;\n\n            // List of crosshairs\n            this.crosshairs = [];\n\n            // Current values of x and y when animating\n            this.now = { x: 0, y: 0 };\n\n            // The tooltip is initially hidden\n            this.isHidden = true;\n\n\n            // create the label\n            this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n                .attr({\n                    padding: options.padding,\n                    r: options.borderRadius,\n                    zIndex: 8\n                })\n                .add()\n                .attr({ y: -9999 });\n\n            ";
if (build.classic) { 
s += "\n            this.label\n                .attr({\n                    'fill': options.backgroundColor,\n                    'stroke-width': options.borderWidth\n                })\n                // #2301, #2657\n                .css(options.style)\n            \n                // When using canVG the shadow shows up as a gray circle\n                // even if the tooltip is hidden.\n                .shadow(!useCanVG && options.shadow);\n\n        \n            ";
} 
s += "\n\n            // Public property for getting the shared state.\n            this.shared = options.shared;\n        },\n\n        /**\n         * Destroy the tooltip and its elements.\n         */\n        destroy: function () {\n            // Destroy and clear local variables\n            if (this.label) {\n                this.label = this.label.destroy();\n            }\n            clearTimeout(this.hideTimer);\n            clearTimeout(this.tooltipTimeout);\n        },\n\n        /**\n         * Provide a soft movement for the tooltip\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @private\n         */\n        move: function (x, y, anchorX, anchorY) {\n            var tooltip = this,\n                now = tooltip.now,\n                animate = tooltip.options.animation !== false && !tooltip.isHidden &&\n                    // When we get close to the target position, abort animation and land on the right place (#3056)\n                    (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n                skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n            // Get intermediate values for animation\n            extend(now, {\n                x: animate ? (2 * now.x + x) / 3 : x,\n                y: animate ? (now.y + y) / 2 : y,\n                anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n                anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY\n            });\n\n            // Move to the intermediate value\n            tooltip.label.attr(now);\n\n\n            // Run on next tick of the mouse tracker\n            if (animate) {\n\n                // Never allow two timeouts\n                clearTimeout(this.tooltipTimeout);\n\n                // Set the fixed interval ticking for the smooth tooltip\n                this.tooltipTimeout = setTimeout(function () {\n                    // The interval function may still be running during destroy, so check that the chart is really there before calling.\n                    if (tooltip) {\n                        tooltip.move(x, y, anchorX, anchorY);\n                    }\n                }, 32);\n\n            }\n        },\n\n        /**\n         * Hide the tooltip\n         */\n        hide: function (delay) {\n            var tooltip = this;\n            clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n            delay = pick(delay, this.options.hideDelay, 500);\n            if (!this.isHidden) {\n                this.hideTimer = syncTimeout(function () {\n                    tooltip.label[delay ? 'fadeOut' : 'hide']();\n                    tooltip.isHidden = true;\n                }, delay);\n            }\n        },\n\n        /**\n         * Extendable method to get the anchor position of the tooltip\n         * from a point or set of points\n         */\n        getAnchor: function (points, mouseEvent) {\n            var ret,\n                chart = this.chart,\n                inverted = chart.inverted,\n                plotTop = chart.plotTop,\n                plotLeft = chart.plotLeft,\n                plotX = 0,\n                plotY = 0,\n                yAxis,\n                xAxis;\n\n            points = splat(points);\n\n            // Pie uses a special tooltipPos\n            ret = points[0].tooltipPos;\n\n            // When tooltip follows mouse, relate the position to the mouse\n            if (this.followPointer && mouseEvent) {\n                if (mouseEvent.chartX === undefined) {\n                    mouseEvent = chart.pointer.normalize(mouseEvent);\n                }\n                ret = [\n                    mouseEvent.chartX - chart.plotLeft,\n                    mouseEvent.chartY - plotTop\n                ];\n            }\n            // When shared, use the average position\n            if (!ret) {\n                each(points, function (point) {\n                    yAxis = point.series.yAxis;\n                    xAxis = point.series.xAxis;\n                    plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n                        (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n                });\n\n                plotX /= points.length;\n                plotY /= points.length;\n\n                ret = [\n                    inverted ? chart.plotWidth - plotY : plotX,\n                    this.shared && !inverted && points.length > 1 && mouseEvent ?\n                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n                        inverted ? chart.plotHeight - plotX : plotY\n                ];\n            }\n\n            return map(ret, Math.round);\n        },\n\n        /**\n         * Place the tooltip in a chart without spilling over\n         * and not covering the point it self.\n         */\n        getPosition: function (boxWidth, boxHeight, point) {\n\n            var chart = this.chart,\n                distance = this.distance,\n                ret = {},\n                h = point.h || 0, // #4117\n                swapped,\n                first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],\n                second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],\n                // The far side is right or bottom\n                preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),\n                /**\n                 * Handle the preferred dimension. When the preferred dimension is tooltip\n                 * on top or bottom of the point, it will look for space there.\n                 */\n                firstDimension = function (dim, outerSize, innerSize, point, min, max) {\n                    var roomLeft = innerSize < point - distance,\n                        roomRight = point + distance + innerSize < outerSize,\n                        alignedLeft = point - distance - innerSize,\n                        alignedRight = point + distance;\n\n                    if (preferFarSide && roomRight) {\n                        ret[dim] = alignedRight;\n                    } else if (!preferFarSide && roomLeft) {\n                        ret[dim] = alignedLeft;\n                    } else if (roomLeft) {\n                        ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n                    } else if (roomRight) {\n                        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n                    } else {\n                        return false;\n                    }\n                },\n                /**\n                 * Handle the secondary dimension. If the preferred dimension is tooltip\n                 * on top or bottom of the point, the second dimension is to align the tooltip\n                 * above the point, trying to align center but allowing left or right\n                 * align within the chart box.\n                 */\n                secondDimension = function (dim, outerSize, innerSize, point) {\n                    var retVal;\n\n                    // Too close to the edge, return false and swap dimensions\n                    if (point < distance || point > outerSize - distance) {\n                        retVal = false;\n                    // Align left/top\n                    } else if (point < innerSize / 2) {\n                        ret[dim] = 1;\n                    // Align right/bottom\n                    } else if (point > outerSize - innerSize / 2) {\n                        ret[dim] = outerSize - innerSize - 2;\n                    // Align center\n                    } else {\n                        ret[dim] = point - innerSize / 2;\n                    }\n                    return retVal;\n                },\n                /**\n                 * Swap the dimensions\n                 */\n                swap = function (count) {\n                    var temp = first;\n                    first = second;\n                    second = temp;\n                    swapped = count;\n                },\n                run = function () {\n                    if (firstDimension.apply(0, first) !== false) {\n                        if (secondDimension.apply(0, second) === false && !swapped) {\n                            swap(true);\n                            run();\n                        }\n                    } else if (!swapped) {\n                        swap(true);\n                        run();\n                    } else {\n                        ret.x = ret.y = 0;\n                    }\n                };\n\n            // Under these conditions, prefer the tooltip on the side of the point\n            if (chart.inverted || this.len > 1) {\n                swap();\n            }\n            run();\n\n            return ret;\n\n        },\n\n        /**\n         * In case no user defined formatter is given, this will be used. Note that the context\n         * here is an object holding point, series, x, y etc.\n         */\n        defaultFormatter: function (tooltip) {\n            var items = this.points || splat(this),\n                s;\n\n            // build the header\n            s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n            // build the values\n            s = s.concat(tooltip.bodyFormatter(items));\n\n            // footer\n            s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n            return s.join('');\n        },\n\n        /**\n         * Refresh the tooltip's text and position.\n         * @param {Object} point\n         */\n        refresh: function (point, mouseEvent) {\n            var tooltip = this,\n                chart = tooltip.chart,\n                label = tooltip.label,\n                options = tooltip.options,\n                x,\n                y,\n                anchor,\n                textConfig = {},\n                text,\n                pointConfig = [],\n                formatter = options.formatter || tooltip.defaultFormatter,\n                hoverPoints = chart.hoverPoints,\n                borderColor,\n                shared = tooltip.shared,\n                currentSeries;\n\n            clearTimeout(this.hideTimer);\n\n            // get the reference point coordinates (pie charts use tooltipPos)\n            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n            anchor = tooltip.getAnchor(point, mouseEvent);\n            x = anchor[0];\n            y = anchor[1];\n\n            // shared tooltip, array is sent over\n            if (shared && !(point.series && point.series.noSharedTooltip)) {\n\n                // hide previous hoverPoints and set new\n\n                chart.hoverPoints = point;\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                each(point, function (item) {\n                    item.setState('hover');\n\n                    pointConfig.push(item.getLabelConfig());\n                });\n\n                textConfig = {\n                    x: point[0].category,\n                    y: point[0].y\n                };\n                textConfig.points = pointConfig;\n                this.len = pointConfig.length;\n                point = point[0];\n\n            // single point tooltip\n            } else {\n                textConfig = point.getLabelConfig();\n            }\n            text = formatter.call(textConfig, tooltip);\n\n            // register the current series\n            currentSeries = point.series;\n            this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n            // update the inner HTML\n            if (text === false) {\n                this.hide();\n            } else {\n\n                // show it\n                if (tooltip.isHidden) {\n                    stop(label);\n                    label.attr('opacity', 1).show();\n                }\n\n                // update text\n                label.attr({\n                    text: text\n                });\n\n                // set the stroke color of the box\n                borderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n                label.attr({\n                    stroke: borderColor\n                });\n                tooltip.updatePosition({\n                    plotX: x,\n                    plotY: y,\n                    negative: point.negative,\n                    ttBelow: point.ttBelow,\n                    h: anchor[2] || 0\n                });\n\n                this.isHidden = false;\n            }\n            fireEvent(chart, 'tooltipRefresh', {\n                text: text,\n                x: x + chart.plotLeft,\n                y: y + chart.plotTop,\n                borderColor: borderColor\n            });\n        },\n\n        /**\n         * Find the new position and perform the move\n         */\n        updatePosition: function (point) {\n            var chart = this.chart,\n                label = this.label,\n                pos = (this.options.positioner || this.getPosition).call(\n                    this,\n                    label.width,\n                    label.height,\n                    point\n                );\n\n            // do the move\n            this.move(\n                Math.round(pos.x), \n                Math.round(pos.y || 0), // can be undefined (#3977) \n                point.plotX + chart.plotLeft, \n                point.plotY + chart.plotTop\n            );\n        },\n\n        /**\n         * Get the best X date format based on the closest point range on the axis.\n         */\n        getXDateFormat: function (point, options, xAxis) {\n            var xDateFormat,\n                dateTimeLabelFormats = options.dateTimeLabelFormats,\n                closestPointRange = xAxis && xAxis.closestPointRange,\n                n,\n                blank = '01-01 00:00:00.000',\n                strpos = {\n                    millisecond: 15,\n                    second: 12,\n                    minute: 9,\n                    hour: 6,\n                    day: 3\n                },\n                date,\n                lastN = 'millisecond'; // for sub-millisecond data, #4223\n\n            if (closestPointRange) {\n                date = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n                for (n in timeUnits) {\n\n                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n                    if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&\n                            date.substr(6) === blank.substr(6)) {\n                        n = 'week';\n                        break;\n                    }\n\n                    // The first format that is too great for the range\n                    if (timeUnits[n] > closestPointRange) {\n                        n = lastN;\n                        break;\n                    }\n\n                    // If the point is placed every day at 23:59, we need to show\n                    // the minutes as well. #2637.\n                    if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                        break;\n                    }\n\n                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n                    if (n !== 'week') {\n                        lastN = n;\n                    }\n                }\n\n                if (n) {\n                    xDateFormat = dateTimeLabelFormats[n];\n                }\n            } else {\n                xDateFormat = dateTimeLabelFormats.day;\n            }\n\n            return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n        },\n\n        /**\n         * Format the footer/header of the tooltip\n         * #3397: abstraction to enable formatting of footer and header\n         */\n        tooltipFooterHeaderFormatter: function (point, isFooter) {\n            var footOrHead = isFooter ? 'footer' : 'header',\n                series = point.series,\n                tooltipOptions = series.tooltipOptions,\n                xDateFormat = tooltipOptions.xDateFormat,\n                xAxis = series.xAxis,\n                isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),\n                formatString = tooltipOptions[footOrHead + 'Format'];\n\n            // Guess the best date format based on the closest point distance (#568, #3418)\n            if (isDateTime && !xDateFormat) {\n                xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);\n            }\n\n            // Insert the footer date format if any\n            if (isDateTime && xDateFormat) {\n                formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n            }\n\n            return format(formatString, {\n                point: point,\n                series: series\n            });\n        },\n\n        /**\n         * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n         * abstracting this functionality allows to easily overwrite and extend it.\n         */\n        bodyFormatter: function (items) {\n            return map(items, function (item) {\n                var tooltipOptions = item.series.tooltipOptions;\n                return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n            });\n        }\n\n    };\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n    var addEvent = H.addEvent,\n        attr = H.attr,\n        charts = H.charts,\n        css = H.css,\n        defined = H.defined,\n        doc = H.doc,\n        each = H.each,\n        extend = H.extend,\n        fireEvent = H.fireEvent,\n        offset = H.offset,\n        pick = H.pick,\n        removeEvent = H.removeEvent,\n        splat = H.splat,\n        Tooltip = H.Tooltip,\n        useCanVG = H.useCanVg,\n        win = H.win;\n\n    // Global flag for touch support\n    H.hasTouch = doc && doc.documentElement.ontouchstart !== undefined;\n\n    /**\n     * The mouse tracker object. All methods starting with ___doublequote___on___doublequote___ are primary DOM event handlers.\n     * Subsequent methods should be named differently from what they are doing.\n     * @param {Object} chart The Chart instance\n     * @param {Object} options The root options object\n     */\n    H.Pointer = function (chart, options) {\n        this.init(chart, options);\n    };\n\n    H.Pointer.prototype = {\n        /**\n         * Initialize Pointer\n         */\n        init: function (chart, options) {\n\n            var chartOptions = options.chart,\n                chartEvents = chartOptions.events,\n                zoomType = useCanVG ? '' : chartOptions.zoomType,\n                inverted = chart.inverted,\n                zoomX,\n                zoomY;\n\n            // Store references\n            this.options = options;\n            this.chart = chart;\n\n            // Zoom status\n            this.zoomX = zoomX = /x/.test(zoomType);\n            this.zoomY = zoomY = /y/.test(zoomType);\n            this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n            this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n            this.hasZoom = zoomX || zoomY;\n\n            // Do we need to handle click on a touch device?\n            this.runChartClick = chartEvents && !!chartEvents.click;\n\n            this.pinchDown = [];\n            this.lastValidTouch = {};\n\n            if (Tooltip && options.tooltip.enabled) {\n                chart.tooltip = new Tooltip(chart, options.tooltip);\n                this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n            }\n\n            this.setDOMEvents();\n        },\n\n        /**\n         * Add crossbrowser support for chartX and chartY\n         * @param {Object} e The event object in standard browsers\n         */\n        normalize: function (e, chartPosition) {\n            var chartX,\n                chartY,\n                ePos;\n\n            // IE normalizing\n            e = e || win.event;\n            if (!e.target) {\n                e.target = e.srcElement;\n            }\n\n            // iOS (#2757)\n            ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n            // Get mouse position\n            if (!chartPosition) {\n                this.chartPosition = chartPosition = offset(this.chart.container);\n            }\n\n            // chartX and chartY\n            if (ePos.pageX === undefined) { // IE < 9. #886.\n                chartX = Math.max(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n                    // for IE10 quirks mode within framesets\n                chartY = e.y;\n            } else {\n                chartX = ePos.pageX - chartPosition.left;\n                chartY = ePos.pageY - chartPosition.top;\n            }\n\n            return extend(e, {\n                chartX: Math.round(chartX),\n                chartY: Math.round(chartY)\n            });\n        },\n\n        /**\n         * Get the click position in terms of axis values.\n         *\n         * @param {Object} e A pointer event\n         */\n        getCoordinates: function (e) {\n            var coordinates = {\n                    xAxis: [],\n                    yAxis: []\n                };\n\n            each(this.chart.axes, function (axis) {\n                coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                    axis: axis,\n                    value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n                });\n            });\n            return coordinates;\n        },\n\n        /**\n         * With line type charts with a single tracker, get the point closest to the mouse.\n         * Run Point.onMouseOver and display tooltip for the point or points.\n         */\n        runPointActions: function (e) {\n\n            var pointer = this,\n                chart = pointer.chart,\n                series = chart.series,\n                tooltip = chart.tooltip,\n                shared = tooltip ? tooltip.shared : false,\n                followPointer,\n                hoverPoint = chart.hoverPoint,\n                hoverSeries = chart.hoverSeries,\n                i,\n                distance = Number.MAX_VALUE, // #4511\n                anchor,\n                noSharedTooltip,\n                stickToHoverSeries,\n                directTouch,\n                kdpoints = [],\n                kdpoint,\n                kdpointT;\n\n            // For hovering over the empty parts of the plot area (hoverSeries is undefined).\n            // If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n            if (!shared && !hoverSeries) {\n                for (i = 0; i < series.length; i++) {\n                    if (series[i].directTouch || !series[i].options.stickyTracking) {\n                        series = [];\n                    }\n                }\n            }\n\n            // If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on\n            // a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise,\n            // search the k-d tree.\n            stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);\n            if (stickToHoverSeries && hoverPoint) {\n                kdpoint = hoverPoint;\n\n            // Handle shared tooltip or cases where a series is not yet hovered\n            } else {\n                // Find nearest points on all series\n                each(series, function (s) {\n                    // Skip hidden series\n                    noSharedTooltip = s.noSharedTooltip && shared;\n                    directTouch = !shared && s.directTouch;\n                    if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821\n                        kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828\n                        if (kdpointT) {\n                            kdpoints.push(kdpointT);\n                        }\n                    }\n                });\n                // Find absolute nearest point\n                each(kdpoints, function (p) {\n                    if (p && typeof p.dist === 'number' && p.dist < distance) {\n                        distance = p.dist;\n                        kdpoint = p;\n                    }\n                });\n            }\n\n            // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200\n            if (kdpoint && (kdpoint !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {\n                // Draw tooltip if necessary\n                if (shared && !kdpoint.series.noSharedTooltip) {\n                    i = kdpoints.length;\n                    while (i--) {\n                        if (kdpoints[i].clientX !== kdpoint.clientX || kdpoints[i].series.noSharedTooltip) {\n                            kdpoints.splice(i, 1);\n                        }\n                    }\n                    if (kdpoints.length && tooltip) {\n                        tooltip.refresh(kdpoints, e);\n                    }\n\n                    // Do mouseover on all points (#3919, #3985, #4410)\n                    each(kdpoints, function (point) {\n                        point.onMouseOver(e, point !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint));\n                    });\n                } else {\n                    if (tooltip) {\n                        tooltip.refresh(kdpoint, e);\n                    }\n                    if (!hoverSeries || !hoverSeries.directTouch) { // #4448\n                        kdpoint.onMouseOver(e);\n                    }\n                }\n                this.prevKDPoint = kdpoint;\n\n            // Update positions (regardless of kdpoint or hoverPoint)\n            } else {\n                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n                if (tooltip && followPointer && !tooltip.isHidden) {\n                    anchor = tooltip.getAnchor([{}], e);\n                    tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\n                }\n            }\n\n            // Start the event listener to pick up the tooltip and crosshairs\n            if (!pointer._onDocumentMouseMove) {\n                pointer._onDocumentMouseMove = function (e) {\n                    if (charts[H.hoverChartIndex]) {\n                        charts[H.hoverChartIndex].pointer.onDocumentMouseMove(e);\n                    }\n                };\n                addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n            }\n\n            // Crosshair\n            each(chart.axes, function (axis) {\n                axis.drawCrosshair(e, pick(kdpoint, hoverPoint));\n            });\n\n\n        },\n\n\n\n        /**\n         * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n         *\n         * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n         */\n        reset: function (allowMove, delay) {\n            var pointer = this,\n                chart = pointer.chart,\n                hoverSeries = chart.hoverSeries,\n                hoverPoint = chart.hoverPoint,\n                hoverPoints = chart.hoverPoints,\n                tooltip = chart.tooltip,\n                tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n\n            // Narrow in allowMove\n            allowMove = allowMove && tooltip && tooltipPoints;\n\n            // Check if the points have moved outside the plot area (#1003, #4736)\n            if (allowMove) {\n                each(splat(tooltipPoints), function (point) {\n                    if (point.plotX === undefined) {\n                        allowMove = false;\n                    }\n                });\n            }\n        \n            // Just move the tooltip, #349\n            if (allowMove) {\n                tooltip.refresh(tooltipPoints);\n                if (hoverPoint) { // #2500\n                    hoverPoint.setState(hoverPoint.state, true);\n                    each(chart.axes, function (axis) {\n                        if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {\n                            axis.drawCrosshair(null, hoverPoint);\n                        }  else {\n                            axis.hideCrosshair();\n                        }\n                    });\n\n                }\n\n            // Full reset\n            } else {\n\n                if (hoverPoint) {\n                    hoverPoint.onMouseOut();\n                }\n\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                if (hoverSeries) {\n                    hoverSeries.onMouseOut();\n                }\n\n                if (tooltip) {\n                    tooltip.hide(delay);\n                }\n\n                if (pointer._onDocumentMouseMove) {\n                    removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n                    pointer._onDocumentMouseMove = null;\n                }\n\n                // Remove crosshairs\n                each(chart.axes, function (axis) {\n                    axis.hideCrosshair();\n                });\n\n                pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n\n            }\n        },\n\n        /**\n         * Scale series groups to a certain scale and translation\n         */\n        scaleGroups: function (attribs, clip) {\n\n            var chart = this.chart,\n                seriesAttribs;\n\n            // Scale each series\n            each(chart.series, function (series) {\n                seriesAttribs = attribs || series.getPlotBox(); // #1701\n                if (series.xAxis && series.xAxis.zoomEnabled) {\n                    series.group.attr(seriesAttribs);\n                    if (series.markerGroup) {\n                        series.markerGroup.attr(seriesAttribs);\n                        series.markerGroup.clip(clip ? chart.clipRect : null);\n                    }\n                    if (series.dataLabelsGroup) {\n                        series.dataLabelsGroup.attr(seriesAttribs);\n                    }\n                }\n            });\n\n            // Clip\n            chart.clipRect.attr(clip || chart.clipBox);\n        },\n\n        /**\n         * Start a drag operation\n         */\n        dragStart: function (e) {\n            var chart = this.chart;\n\n            // Record the start position\n            chart.mouseIsDown = e.type;\n            chart.cancelClick = false;\n            chart.mouseDownX = this.mouseDownX = e.chartX;\n            chart.mouseDownY = this.mouseDownY = e.chartY;\n        },\n\n        /**\n         * Perform a drag operation in response to a mousemove event while the mouse is down\n         */\n        drag: function (e) {\n\n            var chart = this.chart,\n                chartOptions = chart.options.chart,\n                chartX = e.chartX,\n                chartY = e.chartY,\n                zoomHor = this.zoomHor,\n                zoomVert = this.zoomVert,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                clickedInside,\n                size,\n                selectionMarker = this.selectionMarker,\n                mouseDownX = this.mouseDownX,\n                mouseDownY = this.mouseDownY,\n                panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n            // If the device supports both touch and mouse (like IE11), and we are touch-dragging\n            // inside the plot area, don't handle the mouse event. #4339.\n            if (selectionMarker && selectionMarker.touch) {\n                return;\n            }\n\n            // If the mouse is outside the plot area, adjust to cooordinates\n            // inside to prevent the selection marker from going outside\n            if (chartX < plotLeft) {\n                chartX = plotLeft;\n            } else if (chartX > plotLeft + plotWidth) {\n                chartX = plotLeft + plotWidth;\n            }\n\n            if (chartY < plotTop) {\n                chartY = plotTop;\n            } else if (chartY > plotTop + plotHeight) {\n                chartY = plotTop + plotHeight;\n            }\n\n            // determine if the mouse has moved more than 10px\n            this.hasDragged = Math.sqrt(\n                Math.pow(mouseDownX - chartX, 2) +\n                Math.pow(mouseDownY - chartY, 2)\n            );\n\n            if (this.hasDragged > 10) {\n                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n                // make a selection\n                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n                    if (!selectionMarker) {\n                        this.selectionMarker = selectionMarker = chart.renderer.rect(\n                            plotLeft,\n                            plotTop,\n                            zoomHor ? 1 : plotWidth,\n                            zoomVert ? 1 : plotHeight,\n                            0\n                        )\n                        .attr({\n                            ";
if (build.classic) { 
s += "\n                            fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n                            ";
} 
s += "\n                            'class': 'highcharts-selection-marker',                    \n                            'zIndex': 7\n                        })\n                        .add();\n                    }\n                }\n\n                // adjust the width of the selection marker\n                if (selectionMarker && zoomHor) {\n                    size = chartX - mouseDownX;\n                    selectionMarker.attr({\n                        width: Math.abs(size),\n                        x: (size > 0 ? 0 : size) + mouseDownX\n                    });\n                }\n                // adjust the height of the selection marker\n                if (selectionMarker && zoomVert) {\n                    size = chartY - mouseDownY;\n                    selectionMarker.attr({\n                        height: Math.abs(size),\n                        y: (size > 0 ? 0 : size) + mouseDownY\n                    });\n                }\n\n                // panning\n                if (clickedInside && !selectionMarker && chartOptions.panning) {\n                    chart.pan(e, chartOptions.panning);\n                }\n            }\n        },\n\n        /**\n         * On mouse up or touch end across the entire document, drop the selection.\n         */\n        drop: function (e) {\n            var pointer = this,\n                chart = this.chart,\n                hasPinched = this.hasPinched;\n\n            if (this.selectionMarker) {\n                var selectionData = {\n                        originalEvent: e, // #4890\n                        xAxis: [],\n                        yAxis: []\n                    },\n                    selectionBox = this.selectionMarker,\n                    selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n                    selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n                    selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n                    selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n                    runZoom;\n\n                // a selection has been made\n                if (this.hasDragged || hasPinched) {\n\n                    // record each axis' min and max\n                    each(chart.axes, function (axis) {\n                        if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n                            var horiz = axis.horiz,\n                                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075\n                                selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n                            selectionData[axis.coll].push({\n                                axis: axis,\n                                min: Math.min(selectionMin, selectionMax), // for reversed axes\n                                max: Math.max(selectionMin, selectionMax)\n                            });\n                            runZoom = true;\n                        }\n                    });\n                    if (runZoom) {\n                        fireEvent(chart, 'selection', selectionData, function (args) { \n                            chart.zoom(extend(args, hasPinched ? { animation: false } : null)); \n                        });\n                    }\n\n                }\n                this.selectionMarker = this.selectionMarker.destroy();\n\n                // Reset scaling preview\n                if (hasPinched) {\n                    this.scaleGroups();\n                }\n            }\n\n            // Reset all\n            if (chart) { // it may be destroyed on mouse up - #877\n                css(chart.container, { cursor: chart._cursor });\n                chart.cancelClick = this.hasDragged > 10; // #370\n                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n                this.pinchDown = [];\n            }\n        },\n\n        onContainerMouseDown: function (e) {\n\n            e = this.normalize(e);\n\n            // issue #295, dragging not always working in Firefox\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n\n            this.dragStart(e);\n        },\n\n\n\n        onDocumentMouseUp: function (e) {\n            if (charts[H.hoverChartIndex]) {\n                charts[H.hoverChartIndex].pointer.drop(e);\n            }\n        },\n\n        /**\n         * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n         * Issue #149 workaround. The mouseleave event does not always fire.\n         */\n        onDocumentMouseMove: function (e) {\n            var chart = this.chart,\n                chartPosition = this.chartPosition;\n\n            e = this.normalize(e, chartPosition);\n\n            // If we're outside, hide the tooltip\n            if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                this.reset();\n            }\n        },\n\n        /**\n         * When mouse leaves the container, hide the tooltip.\n         */\n        onContainerMouseLeave: function () {\n            var chart = charts[H.hoverChartIndex];\n            if (chart) {\n                chart.pointer.reset();\n                chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n            }\n        },\n\n        // The mousemove, touchmove and touchstart event handler\n        onContainerMouseMove: function (e) {\n\n            var chart = this.chart;\n\n            H.hoverChartIndex = chart.index;\n\n            e = this.normalize(e);\n            e.returnValue = false; // #2251, #3224\n\n            if (chart.mouseIsDown === 'mousedown') {\n                this.drag(e);\n            }\n\n            // Show the tooltip and run mouse over events (#977)\n            if ((this.inClass(e.target, 'highcharts-tracker') ||\n                    chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n                this.runPointActions(e);\n            }\n        },\n\n        /**\n         * Utility to detect whether an element has, or has a parent with, a specific\n         * class name. Used on detection of tracker objects and on deciding whether\n         * hovering the tooltip should cause the active series to mouse out.\n         */\n        inClass: function (element, className) {\n            var elemClassName;\n            while (element) {\n                elemClassName = attr(element, 'class');\n                if (elemClassName) {\n                    if (elemClassName.indexOf(className) !== -1) {\n                        return true;\n                    }\n                    if (elemClassName.indexOf('highcharts-container') !== -1) {\n                        return false;\n                    }\n                }\n                element = element.parentNode;\n            }\n        },\n\n        onTrackerMouseOut: function (e) {\n            var series = this.chart.hoverSeries,\n                relatedTarget = e.relatedTarget || e.toElement;\n        \n            if (series && !series.options.stickyTracking && \n                    !this.inClass(relatedTarget, 'highcharts-tooltip') &&\n                    !this.inClass(relatedTarget, 'highcharts-series-' + series.index)) { // #2499, #4465\n                series.onMouseOut();\n            }\n        },\n\n        onContainerClick: function (e) {\n            var chart = this.chart,\n                hoverPoint = chart.hoverPoint, \n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop;\n\n            e = this.normalize(e);\n\n            if (!chart.cancelClick) {\n\n                // On tracker click, fire the series and point events. #783, #1583\n                if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n\n                    // the series click event\n                    fireEvent(hoverPoint.series, 'click', extend(e, {\n                        point: hoverPoint\n                    }));\n\n                    // the point click event\n                    if (chart.hoverPoint) { // it may be destroyed (#1844)\n                        hoverPoint.firePointEvent('click', e);\n                    }\n\n                // When clicking outside a tracker, fire a chart event\n                } else {\n                    extend(e, this.getCoordinates(e));\n\n                    // fire a click event in the chart\n                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n                        fireEvent(chart, 'click', e);\n                    }\n                }\n\n\n            }\n        },\n\n        /**\n         * Set the JS DOM events on the container and document. This method should contain\n         * a one-to-one assignment between methods and their handlers. Any advanced logic should\n         * be moved to the handler reflecting the event's name.\n         */\n        setDOMEvents: function () {\n\n            var pointer = this,\n                container = pointer.chart.container;\n\n            container.onmousedown = function (e) {\n                pointer.onContainerMouseDown(e);\n            };\n            container.onmousemove = function (e) {\n                pointer.onContainerMouseMove(e);\n            };\n            container.onclick = function (e) {\n                pointer.onContainerClick(e);\n            };\n            addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n            if (H.chartCount === 1) {\n                addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n            }\n            if (H.hasTouch) {\n                container.ontouchstart = function (e) {\n                    pointer.onContainerTouchStart(e);\n                };\n                container.ontouchmove = function (e) {\n                    pointer.onContainerTouchMove(e);\n                };\n                if (H.chartCount === 1) {\n                    addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                }\n            }\n\n        },\n\n        /**\n         * Destroys the Pointer object and disconnects DOM events.\n         */\n        destroy: function () {\n            var prop;\n\n            removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n            if (!H.chartCount) {\n                removeEvent(doc, 'mouseup', this.onDocumentMouseUp);\n                removeEvent(doc, 'touchend', this.onDocumentTouchEnd);\n            }\n\n            // memory and CPU leak\n            clearInterval(this.tooltipTimeout);\n\n            for (prop in this) {\n                this[prop] = null;\n            }\n        }\n    };\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var charts = H.charts,\n            each = H.each,\n            extend = H.extend,\n            map = H.map,\n            noop = H.noop,\n            pick = H.pick,\n            Pointer = H.Pointer;\n\n    /* Support for touch devices */\n    extend(Pointer.prototype, {\n\n        /**\n         * Run translation operations\n         */\n        pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n            if (this.zoomHor || this.pinchHor) {\n                this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n            if (this.zoomVert || this.pinchVert) {\n                this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n        },\n\n        /**\n         * Run translation operations for each direction (horizontal and vertical) independently\n         */\n        pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n            var chart = this.chart,\n                xy = horiz ? 'x' : 'y',\n                XY = horiz ? 'X' : 'Y',\n                sChartXY = 'chart' + XY,\n                wh = horiz ? 'width' : 'height',\n                plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n                selectionWH,\n                selectionXY,\n                clipXY,\n                scale = forcedScale || 1,\n                inverted = chart.inverted,\n                bounds = chart.bounds[horiz ? 'h' : 'v'],\n                singleTouch = pinchDown.length === 1,\n                touch0Start = pinchDown[0][sChartXY],\n                touch0Now = touches[0][sChartXY],\n                touch1Start = !singleTouch && pinchDown[1][sChartXY],\n                touch1Now = !singleTouch && touches[1][sChartXY],\n                outOfBounds,\n                transformScale,\n                scaleKey,\n                setScale = function () {\n                    if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n                        scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start); \n                    }\n\n                    clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                    selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n                };\n\n            // Set the scale, first pass\n            setScale();\n\n            selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n            // Out of bounds\n            if (selectionXY < bounds.min) {\n                selectionXY = bounds.min;\n                outOfBounds = true;\n            } else if (selectionXY + selectionWH > bounds.max) {\n                selectionXY = bounds.max - selectionWH;\n                outOfBounds = true;\n            }\n\n            // Is the chart dragged off its bounds, determined by dataMin and dataMax?\n            if (outOfBounds) {\n\n                // Modify the touchNow position in order to create an elastic drag movement. This indicates\n                // to the user that the chart is responsive but can't be dragged further.\n                touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n                if (!singleTouch) {\n                    touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n                }\n\n                // Set the scale, second pass to adapt to the modified touchNow positions\n                setScale();\n\n            } else {\n                lastValidTouch[xy] = [touch0Now, touch1Now];\n            }\n\n            // Set geometry for clipping, selection and transformation\n            if (!inverted) {\n                clip[xy] = clipXY - plotLeftTop;\n                clip[wh] = selectionWH;\n            }\n            scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n            transformScale = inverted ? 1 / scale : scale;\n\n            selectionMarker[wh] = selectionWH;\n            selectionMarker[xy] = selectionXY;\n            transform[scaleKey] = scale;\n            transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n        },\n\n        /**\n         * Handle touch events with two touches\n         */\n        pinch: function (e) {\n\n            var self = this,\n                chart = self.chart,\n                pinchDown = self.pinchDown,\n                touches = e.touches,\n                touchesLength = touches.length,\n                lastValidTouch = self.lastValidTouch,\n                hasZoom = self.hasZoom,\n                selectionMarker = self.selectionMarker,\n                transform = {},\n                fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') && \n                    chart.runTrackerClick) || self.runChartClick),\n                clip = {};\n\n            // Don't initiate panning until the user has pinched. This prevents us from\n            // blocking page scrolling as users scroll down a long page (#4210).\n            if (touchesLength > 1) {\n                self.initiated = true;\n            }\n\n            // On touch devices, only proceed to trigger click if a handler is defined\n            if (hasZoom && self.initiated && !fireClickEvent) {\n                e.preventDefault();\n            }\n\n            // Normalize each touch\n            map(touches, function (e) {\n                return self.normalize(e);\n            });\n\n            // Register the touch start position\n            if (e.type === 'touchstart') {\n                each(touches, function (e, i) {\n                    pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n                });\n                lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n                lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n                // Identify the data bounds in pixels\n                each(chart.axes, function (axis) {\n                    if (axis.zoomEnabled) {\n                        var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                            minPixelPadding = axis.minPixelPadding,\n                            min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n                            max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n                            absMin = Math.min(min, max),\n                            absMax = Math.max(min, max);\n\n                        // Store the bounds for use in the touchmove handler\n                        bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n                        bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);\n                    }\n                });\n                self.res = true; // reset on next move\n\n            // Event type is touchmove, handle panning and pinching\n            } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\n\n                // Set the marker\n                if (!selectionMarker) {\n                    self.selectionMarker = selectionMarker = extend({\n                        destroy: noop,\n                        touch: true\n                    }, chart.plotBox);\n                }\n\n                self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n                self.hasPinched = hasZoom;\n\n                // Scale and translate the groups to provide visual feedback during pinching\n                self.scaleGroups(transform, clip);\n\n                // Optionally move the tooltip on touchmove\n                if (!hasZoom && self.followTouchMove && touchesLength === 1) {\n                    this.runPointActions(self.normalize(e));\n                } else if (self.res) {\n                    self.res = false;\n                    this.reset(false, 0);\n                }\n            }\n        },\n\n        /**\n         * General touch handler shared by touchstart and touchmove.\n         */\n        touch: function (e, start) {\n            var chart = this.chart;\n\n            H.hoverChartIndex = chart.index;\n\n            if (e.touches.length === 1) {\n\n                e = this.normalize(e);\n\n                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n                    // Run mouse events and display tooltip etc\n                    if (start) {\n                        this.runPointActions(e);\n                    }\n\n                    this.pinch(e);\n\n                } else if (start) {\n                    // Hide the tooltip on touching outside the plot area (#1203)\n                    this.reset();\n                }\n\n            } else if (e.touches.length === 2) {\n                this.pinch(e);\n            }\n        },\n\n        onContainerTouchStart: function (e) {\n            this.touch(e, true);\n        },\n\n        onContainerTouchMove: function (e) {\n            this.touch(e);\n        },\n\n        onDocumentTouchEnd: function (e) {\n            if (charts[H.hoverChartIndex]) {\n                charts[H.hoverChartIndex].pointer.drop(e);\n            }\n        }\n\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            charts = H.charts,\n            css = H.css,\n            doc = H.doc,\n            extend = H.extend,\n            noop = H.noop,\n            Pointer = H.Pointer,\n            removeEvent = H.removeEvent,\n            win = H.win,\n            wrap = H.wrap;\n\n    if (win.PointerEvent || win.MSPointerEvent) {\n    \n        // The touches object keeps track of the points being touched at all times\n        var touches = {},\n            hasPointerEvent = !!win.PointerEvent,\n            getWebkitTouches = function () {\n                var key, fake = [];\n                fake.item = function (i) {\n                    return this[i];\n                };\n                for (key in touches) {\n                    if (touches.hasOwnProperty(key)) {\n                        fake.push({\n                            pageX: touches[key].pageX,\n                            pageY: touches[key].pageY,\n                            target: touches[key].target\n                        });\n                    }\n                }\n                return fake;\n            },\n            translateMSPointer = function (e, method, wktype, func) {\n                var p;\n                if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {\n                    func(e);\n                    p = charts[H.hoverChartIndex].pointer;\n                    p[method]({\n                        type: wktype,\n                        target: e.currentTarget,\n                        preventDefault: noop,\n                        touches: getWebkitTouches()\n                    });\n                }\n            };\n\n        /**\n         * Extend the Pointer prototype with methods for each event handler and more\n         */\n        extend(Pointer.prototype, {\n            onContainerPointerDown: function (e) {\n                translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n                });\n            },\n            onContainerPointerMove: function (e) {\n                translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n                    if (!touches[e.pointerId].target) {\n                        touches[e.pointerId].target = e.currentTarget;\n                    }\n                });\n            },\n            onDocumentPointerUp: function (e) {\n                translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {\n                    delete touches[e.pointerId];\n                });\n            },\n\n            /**\n             * Add or remove the MS Pointer specific events\n             */\n            batchMSEvents: function (fn) {\n                fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n                fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n                fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n            }\n        });\n\n        // Disable default IE actions for pinch and such on chart element\n        wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n            proceed.call(this, chart, options);\n            if (this.hasZoom) { // #4014\n                css(chart.container, {\n                    '-ms-touch-action': 'none',\n                    'touch-action': 'none'\n                });\n            }\n        });\n\n        // Add IE specific touch events to chart\n        wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n            proceed.apply(this);\n            if (this.hasZoom || this.followTouchMove) {\n                this.batchMSEvents(addEvent);\n            }\n        });\n        // Destroy MS events also\n        wrap(Pointer.prototype, 'destroy', function (proceed) {\n            this.batchMSEvents(removeEvent);\n            proceed.call(this);\n        });\n    }\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Legend,\n        \n            addEvent = H.addEvent,\n            css = H.css,\n            discardElement = H.discardElement,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            isFirefox = H.isFirefox,\n            marginNames = H.marginNames,\n            merge = H.merge,\n            pick = H.pick,\n            setAnimation = H.setAnimation,\n            stableSort = H.stableSort,\n            win = H.win,\n            wrap = H.wrap;\n    /**\n     * The overview of the chart's series\n     */\n    Legend = H.Legend = function (chart, options) {\n        this.init(chart, options);\n    };\n\n    Legend.prototype = {\n\n        /**\n         * Initialize the legend\n         */\n        init: function (chart, options) {\n\n            var legend = this,\n                ";
if (build.classic) { 
s += "\n                itemStyle = legend.itemStyle = options.itemStyle,\n                ";
} 
s += "\n                padding,\n                itemMarginTop = options.itemMarginTop || 0;\n\n            this.options = options;\n\n            if (!options.enabled) {\n                return;\n            }\n    \n            ";
if (build.classic) { 
s += "\n            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n            ";
} 
s += "\n            legend.itemMarginTop = itemMarginTop;\n            legend.padding = padding = pick(options.padding, 8);\n            legend.initialItemX = padding;\n            legend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n            legend.maxItemWidth = 0;\n            legend.chart = chart;\n            legend.itemHeight = 0;\n            legend.symbolWidth = pick(options.symbolWidth, 16);\n            legend.pages = [];\n\n\n            // Render it\n            legend.render();\n\n            // move checkboxes\n            addEvent(legend.chart, 'endResize', function () {\n                legend.positionCheckboxes();\n            });\n\n        },\n\n        /**\n         * Set the colors for the legend item\n         * @param {Object} item A Series or Point instance\n         * @param {Object} visible Dimmed or colored\n         */\n        colorizeItem: function (item, visible) {\n            item.legendGroup[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');\n\n            ";
if (build.classic) { 
s += "\n            var legend = this,\n                options = legend.options,\n                legendItem = item.legendItem,\n                legendLine = item.legendLine,\n                legendSymbol = item.legendSymbol,\n                hiddenColor = legend.itemHiddenStyle.color,\n                textColor = visible ? options.itemStyle.color : hiddenColor,\n                symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,\n                markerOptions = item.options && item.options.marker,\n                symbolAttr = { fill: symbolColor },\n                key;\n\n            if (legendItem) {\n                legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n            }\n            if (legendLine) {\n                legendLine.attr({ stroke: symbolColor });\n            }\n\n            if (legendSymbol) {\n\n                // Apply marker options\n                if (markerOptions && legendSymbol.isMarker) { // #585\n                    //symbolAttr.stroke = symbolColor;\n                    symbolAttr = item.pointAttribs();\n                    if (!visible) {\n                        for (key in symbolAttr) {\n                                symbolAttr[key] = hiddenColor;\n                        }\n                    }\n                }\n\n                legendSymbol.attr(symbolAttr);\n            }\n            ";
} 
s += "\n        },\n\n        /**\n         * Position the legend item\n         * @param {Object} item A Series or Point instance\n         */\n        positionItem: function (item) {\n            var legend = this,\n                options = legend.options,\n                symbolPadding = options.symbolPadding,\n                ltr = !options.rtl,\n                legendItemPos = item._legendItemPos,\n                itemX = legendItemPos[0],\n                itemY = legendItemPos[1],\n                checkbox = item.checkbox,\n                legendGroup = item.legendGroup;\n\n            if (legendGroup && legendGroup.element) {\n                legendGroup.translate(\n                    ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                    itemY\n                );\n            }\n\n            if (checkbox) {\n                checkbox.x = itemX;\n                checkbox.y = itemY;\n            }\n        },\n\n        /**\n         * Destroy a single legend item\n         * @param {Object} item The series or point\n         */\n        destroyItem: function (item) {\n            var checkbox = item.checkbox;\n\n            // destroy SVG elements\n            each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n                if (item[key]) {\n                    item[key] = item[key].destroy();\n                }\n            });\n\n            if (checkbox) {\n                discardElement(item.checkbox);\n            }\n        },\n\n        /**\n         * Destroys the legend.\n         */\n        destroy: function () {\n            var legend = this,\n                legendGroup = legend.group,\n                box = legend.box;\n\n            if (box) {\n                legend.box = box.destroy();\n            }\n\n            if (legendGroup) {\n                legend.group = legendGroup.destroy();\n            }\n        },\n\n        /**\n         * Position the checkboxes after the width is determined\n         */\n        positionCheckboxes: function (scrollOffset) {\n            var alignAttr = this.group.alignAttr,\n                translateY,\n                clipHeight = this.clipHeight || this.legendHeight,\n                titleHeight = this.titleHeight;\n\n            if (alignAttr) {\n                translateY = alignAttr.translateY;\n                each(this.allItems, function (item) {\n                    var checkbox = item.checkbox,\n                        top;\n\n                    if (checkbox) {\n                        top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;\n                        css(checkbox, {\n                            left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + 'px',\n                            top: top + 'px',\n                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'\n                        });\n                    }\n                });\n            }\n        },\n\n        /**\n         * Render the legend title on top of the legend\n         */\n        renderTitle: function () {\n            var options = this.options,\n                padding = this.padding,\n                titleOptions = options.title,\n                titleHeight = 0,\n                bBox;\n\n            if (titleOptions.text) {\n                if (!this.title) {\n                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n                        .attr({ zIndex: 1 })\n                        ";
if (build.classic) { 
s += "\n                        .css(titleOptions.style)\n                        ";
} 
s += "\n                        .add(this.group);\n                }\n                bBox = this.title.getBBox();\n                titleHeight = bBox.height;\n                this.offsetWidth = bBox.width; // #1717\n                this.contentGroup.attr({ translateY: titleHeight });\n            }\n            this.titleHeight = titleHeight;\n        },\n\n        /**\n         * Set the legend item text\n         */\n        setText: function (item) {\n            var options = this.options;\n            item.legendItem.attr({\n                text: options.labelFormat ? Highcharts.format(options.labelFormat, item) : options.labelFormatter.call(item)\n            });\n        },\n\n        /**\n         * Render a single specific legend item\n         * @param {Object} item A series or point\n         */\n        renderItem: function (item) {\n            var legend = this,\n                chart = legend.chart,\n                renderer = chart.renderer,\n                options = legend.options,\n                horizontal = options.layout === 'horizontal',\n                symbolWidth = legend.symbolWidth,\n                symbolPadding = options.symbolPadding,\n                ";
if (build.classic) { 
s += "\n                itemStyle = legend.itemStyle,\n                itemHiddenStyle = legend.itemHiddenStyle,\n                ";
} 
s += "\n                padding = legend.padding,\n                itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n                ltr = !options.rtl,\n                itemHeight,\n                widthOption = options.width,\n                itemMarginBottom = options.itemMarginBottom || 0,\n                itemMarginTop = legend.itemMarginTop,\n                initialItemX = legend.initialItemX,\n                bBox,\n                itemWidth,\n                li = item.legendItem,\n                isSeries = !item.series,\n                series = !isSeries && item.series.drawLegendSymbol ? item.series : item,\n                seriesOptions = series.options,\n                showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n                useHTML = options.useHTML,\n                fontSize = 12;\n\n            if (!li) { // generate it once, later move it\n\n                // Generate the group box\n                // A group to hold the symbol and text. Text is to be appended in Legend class.\n                item.legendGroup = renderer.g('legend-item')\n                    .addClass('highcharts-' + series.type + '-series highcharts-color-' + item.colorIndex + ' ' + \n                        (item.options.className || '') +\n                        (isSeries ? 'highcharts-series-' + item.index : '')\n                    )\n                    .attr({ zIndex: 1 })\n                    .add(legend.scrollGroup);\n\n                // Generate the list item text and add it to the group\n                item.legendItem = li = renderer.text(\n                        '',\n                        ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                        legend.baseline || 0,\n                        useHTML\n                    )\n                    ";
if (build.classic) { 
s += "\n                    .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n                    ";
} 
s += "\n                    .attr({\n                        align: ltr ? 'left' : 'right',\n                        zIndex: 2\n                    })\n                    .add(item.legendGroup);\n\n                // Get the baseline for the first item - the font size is equal for all\n                if (!legend.baseline) {\n                    ";
if (build.classic) { 
s += "\n                    fontSize = itemStyle.fontSize;\n                    ";
} 
s += "\n                    legend.fontMetrics = renderer.fontMetrics(\n                        fontSize,\n                        li\n                    );\n                    legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;\n                    li.attr('y', legend.baseline);\n                }\n\n                // Draw the legend symbol inside the group box\n                series.drawLegendSymbol(legend, item);\n\n                if (legend.setItemEvents) {\n                    legend.setItemEvents(item, li, useHTML);\n                }        \n\n                // add the HTML checkbox on top\n                if (showCheckbox) {\n                    legend.createCheckboxForItem(item);\n                }\n            }\n\n            // Colorize the items\n            legend.colorizeItem(item, item.visible);\n\n            // Always update the text\n            legend.setText(item);\n\n            // calculate the positions for the next line\n            bBox = li.getBBox();\n\n            itemWidth = item.checkboxOffset =\n                options.itemWidth ||\n                item.legendItemWidth ||\n                symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n            legend.itemHeight = itemHeight = Math.round(item.legendItemHeight || bBox.height);\n\n            // if the item exceeds the width, start a new line\n            if (horizontal && legend.itemX - initialItemX + itemWidth >\n                    (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n                legend.itemX = initialItemX;\n                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n                legend.lastLineHeight = 0; // reset for next line (#915, #3976)\n            }\n\n            // If the item exceeds the height, start a new column\n            /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n                legend.itemY = legend.initialItemY;\n                legend.itemX += legend.maxItemWidth;\n                legend.maxItemWidth = 0;\n            }*/\n\n            // Set the edge positions\n            legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);\n            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n            legend.lastLineHeight = Math.max(itemHeight, legend.lastLineHeight); // #915\n\n            // cache the position of the newly generated or reordered items\n            item._legendItemPos = [legend.itemX, legend.itemY];\n\n            // advance\n            if (horizontal) {\n                legend.itemX += itemWidth;\n\n            } else {\n                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n                legend.lastLineHeight = itemHeight;\n            }\n\n            // the width of the widest item\n            legend.offsetWidth = widthOption || Math.max(\n                (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n                legend.offsetWidth\n            );\n        },\n\n        /**\n         * Get all items, which is one item per series for normal series and one item per point\n         * for pie series.\n         */\n        getAllItems: function () {\n            var allItems = [];\n            each(this.chart.series, function (series) {\n                var seriesOptions = series.options;\n\n                // Handle showInLegend. If the series is linked to another series, defaults to false.\n                if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true)) {\n                    return;\n                }\n\n                // use points or series for the legend item depending on legendType\n                allItems = allItems.concat(\n                        series.legendItems ||\n                        (seriesOptions.legendType === 'point' ?\n                                series.data :\n                                series)\n                );\n            });\n            return allItems;\n        },\n\n        /**\n         * Adjust the chart margins by reserving space for the legend on only one side\n         * of the chart. If the position is set to a corner, top or bottom is reserved\n         * for horizontal legends and left or right for vertical ones.\n         */\n        adjustMargins: function (margin, spacing) {\n            var chart = this.chart,\n                options = this.options,\n                // Use the first letter of each alignment option in order to detect the side\n                alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7\n\n            if (this.display && !options.floating) {\n\n                each([\n                    /(lth|ct|rth)/,\n                    /(rtv|rm|rbv)/,\n                    /(rbh|cb|lbh)/,\n                    /(lbv|lm|ltv)/\n                ], function (alignments, side) {\n                    if (alignments.test(alignment) && !defined(margin[side])) {\n                        // Now we have detected on which side of the chart we should reserve space for the legend\n                        chart[marginNames[side]] = Math.max(\n                            chart[marginNames[side]],\n                            chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +\n                                [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +\n                                pick(options.margin, 12) +\n                                spacing[side]\n                        );\n                    }\n                });\n            }\n        },\n\n        /**\n         * Render the legend. This method can be called both before and after\n         * chart.render. If called after, it will only rearrange items instead\n         * of creating new ones.\n         */\n        render: function () {\n            var legend = this,\n                chart = legend.chart,\n                renderer = chart.renderer,\n                legendGroup = legend.group,\n                allItems,\n                display,\n                legendWidth,\n                legendHeight,\n                box = legend.box,\n                options = legend.options,\n                padding = legend.padding,\n                borderWidth;\n\n            legend.itemX = legend.initialItemX;\n            legend.itemY = legend.initialItemY;\n            legend.offsetWidth = 0;\n            legend.lastItemY = 0;\n\n            if (!legendGroup) {\n                legend.group = legendGroup = renderer.g('legend')\n                    .attr({ zIndex: 7 })\n                    .add();\n                legend.contentGroup = renderer.g()\n                    .attr({ zIndex: 1 }) // above background\n                    .add(legendGroup);\n                legend.scrollGroup = renderer.g()\n                    .add(legend.contentGroup);\n            }\n\n            legend.renderTitle();\n\n            // add each series or point\n            allItems = legend.getAllItems();\n\n            // sort by legendIndex\n            stableSort(allItems, function (a, b) {\n                return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n            });\n\n            // reversed legend\n            if (options.reversed) {\n                allItems.reverse();\n            }\n\n            legend.allItems = allItems;\n            legend.display = display = !!allItems.length;\n\n            // render the items\n            legend.lastLineHeight = 0;\n            each(allItems, function (item) {\n                legend.renderItem(item);\n            });\n\n            // Get the box\n            legendWidth = (options.width || legend.offsetWidth) + padding;\n            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n            legendHeight = legend.handleOverflow(legendHeight);\n            legendHeight += padding;\n\n            // Draw the border and/or background\n            if (!box) {\n                legend.box = box = renderer.rect()\n                    .addClass('highcharts-legend-box')\n                    .attr({\n                        r: options.borderRadius\n                    })\n                    .add(legendGroup);\n                box.isNew = true;\n            } \n\n            ";
if (!build.classic) { 
s += "\n            borderWidth = box.pxStyle('stroke-width');\n            ";
} else { 
s += "\n            borderWidth = options.borderWidth || 0;\n            box.attr({\n                    stroke: options.borderColor,\n                    'stroke-width': options.borderWidth || 0,\n                    fill: options.backgroundColor || 'none'\n                })\n                .shadow(options.shadow);\n            ";
} 
s += "\n\n            if (legendWidth > 0 && legendHeight > 0) {\n                box[box.isNew ? 'attr' : 'animate'](\n                    box.crisp({ x: 0, y: 0, width: legendWidth, height: legendHeight }, borderWidth)\n                );\n                box.isNew = false;\n            }\n\n            // hide the border if no items\n            box[display ? 'show' : 'hide']();\n\n            ";
if (!build.classic) { 
s += "\n            // Open for responsiveness\n            if (legendGroup.getStyle('display') === 'none') {\n                legendWidth = legendHeight = 0;\n            }\n            ";
} 
s += "\n\n            legend.legendWidth = legendWidth;\n            legend.legendHeight = legendHeight;\n\n            // Now that the legend width and height are established, put the items in the\n            // final position\n            each(allItems, function (item) {\n                legend.positionItem(item);\n            });\n\n            // 1.x compatibility: positioning based on style\n            /*var props = ['left', 'right', 'top', 'bottom'],\n                prop,\n                i = 4;\n            while (i--) {\n                prop = props[i];\n                if (options.style[prop] && options.style[prop] !== 'auto') {\n                    options[i < 2 ? 'align' : 'verticalAlign'] = prop;\n                    options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n                }\n            }*/\n\n            if (display) {\n                legendGroup.align(extend({\n                    width: legendWidth,\n                    height: legendHeight\n                }, options), true, 'spacingBox');\n            }\n\n            if (!chart.isResizing) {\n                this.positionCheckboxes();\n            }\n        },\n\n        /**\n         * Set up the overflow handling by adding navigation with up and down arrows below the\n         * legend.\n         */\n        handleOverflow: function (legendHeight) {\n            var legend = this,\n                chart = this.chart,\n                renderer = chart.renderer,\n                options = this.options,\n                optionsY = options.y,\n                alignTop = options.verticalAlign === 'top',\n                spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n                maxHeight = options.maxHeight,\n                clipHeight,\n                clipRect = this.clipRect,\n                navOptions = options.navigation,\n                animation = pick(navOptions.animation, true),\n                arrowSize = navOptions.arrowSize || 12,\n                nav = this.nav,\n                pages = this.pages,\n                padding = this.padding,\n                lastY,\n                allItems = this.allItems,\n                clipToHeight = function (height) {\n                    clipRect.attr({\n                        height: height\n                    });\n\n                    // useHTML\n                    if (legend.contentGroup.div) {\n                        legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';\n                    }\n                };\n\n\n            // Adjust the height\n            if (options.layout === 'horizontal') {\n                spaceHeight /= 2;\n            }\n            if (maxHeight) {\n                spaceHeight = Math.min(spaceHeight, maxHeight);\n            }\n\n            // Reset the legend height and adjust the clipping rectangle\n            pages.length = 0;\n            if (legendHeight > spaceHeight) {\n\n                this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n                this.currentPage = pick(this.currentPage, 1);\n                this.fullHeight = legendHeight;\n\n                // Fill pages with Y positions so that the top of each a legend item defines\n                // the scroll top for each page (#2098)\n                each(allItems, function (item, i) {\n                    var y = item._legendItemPos[1],\n                        h = Math.round(item.legendItem.getBBox().height),\n                        len = pages.length;\n\n                    if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n                        pages.push(lastY || y);\n                        len++;\n                    }\n\n                    if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n                        pages.push(y);\n                    }\n                    if (y !== lastY) {\n                        lastY = y;\n                    }\n                });\n\n                // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n                if (!clipRect) {\n                    clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);\n                    legend.contentGroup.clip(clipRect);\n                }\n\n                clipToHeight(clipHeight);\n\n                // Add navigation elements\n                if (!nav) {\n                    this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n                    this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n                        .on('click', function () {\n                            legend.scroll(-1, animation);\n                        })\n                        .add(nav);\n                    this.pager = renderer.text('', 15, 10)\n                        .addClass('highcharts-legend-navigation')\n                        ";
if (build.classic) { 
s += "\n                        .css(navOptions.style)\n                        ";
} 
s += "\n                        .add(nav);\n                    this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n                        .on('click', function () {\n                            legend.scroll(1, animation);\n                        })\n                        .add(nav);\n                }\n\n                // Set initial position\n                legend.scroll(0);\n\n                legendHeight = spaceHeight;\n\n            } else if (nav) {\n                clipToHeight(chart.chartHeight);\n                nav.hide();\n                this.scrollGroup.attr({\n                    translateY: 1\n                });\n                this.clipHeight = 0; // #1379\n            }\n\n            return legendHeight;\n        },\n\n        /**\n         * Scroll the legend by a number of pages\n         * @param {Object} scrollBy\n         * @param {Object} animation\n         */\n        scroll: function (scrollBy, animation) {\n            var pages = this.pages,\n                pageCount = pages.length,\n                currentPage = this.currentPage + scrollBy,\n                clipHeight = this.clipHeight,\n                navOptions = this.options.navigation,\n                pager = this.pager,\n                padding = this.padding,\n                scrollOffset;\n\n            // When resizing while looking at the last page\n            if (currentPage > pageCount) {\n                currentPage = pageCount;\n            }\n\n            if (currentPage > 0) {\n            \n                if (animation !== undefined) {\n                    setAnimation(animation, this.chart);\n                }\n\n                this.nav.attr({\n                    translateX: padding,\n                    translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                    visibility: 'visible'\n                });\n                this.up.attr({\n                    'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n                });\n                pager.attr({\n                    text: currentPage + '/' + pageCount\n                });\n                this.down.attr({\n                    'x': 18 + this.pager.getBBox().width, // adjust to text width\n                    'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n                });\n\n                ";
if (build.classic) { 
s += "\n                this.up\n                    .attr({\n                        fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor\n                    })\n                    .css({\n                        cursor: currentPage === 1 ? 'default' : 'pointer'\n                    });\n                this.down\n                    .attr({\n                        fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor\n                    })\n                    .css({\n                        cursor: currentPage === pageCount ? 'default' : 'pointer'\n                    });\n                ";
} 
s += "\n            \n                scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n                this.scrollGroup.animate({\n                    translateY: scrollOffset\n                });\n\n                this.currentPage = currentPage;\n                this.positionCheckboxes(scrollOffset);\n            }\n\n        }\n\n    };\n\n    /*\n     * LegendSymbolMixin\n     */\n\n    H.LegendSymbolMixin = {\n\n        /**\n         * Get the series' symbol in the legend\n         *\n         * @param {Object} legend The legend object\n         * @param {Object} item The series (this) or point\n         */\n        drawRectangle: function (legend, item) {\n            var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;\n\n            item.legendSymbol = this.chart.renderer.rect(\n                0,\n                legend.baseline - symbolHeight + 1, // #3988\n                legend.symbolWidth,\n                symbolHeight,\n                legend.options.symbolRadius || 0\n            )\n            .addClass('highcharts-point')\n            .attr({\n                zIndex: 3\n            }).add(item.legendGroup);\n\n        },\n\n        /**\n         * Get the series' symbol in the legend. This method should be overridable to create custom\n         * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n         *\n         * @param {Object} legend The legend object\n         */\n        drawLineMarker: function (legend) {\n\n            var options = this.options,\n                markerOptions = options.marker,\n                radius,\n                legendSymbol,\n                symbolWidth = legend.symbolWidth,\n                renderer = this.chart.renderer,\n                legendItemGroup = this.legendGroup,\n                verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3),\n                attr = {};\n\n            // Draw the line\n            ";
if (build.classic) { 
s += "\n            attr = {\n                'stroke-width': options.lineWidth || 0\n            };\n            if (options.dashStyle) {\n                attr.dashstyle = options.dashStyle;\n            }\n            ";
} 
s += "\n        \n            this.legendLine = renderer.path([\n                'M',\n                0,\n                verticalCenter,\n                'L',\n                symbolWidth,\n                verticalCenter\n            ])\n            .addClass('highcharts-graph')\n            .attr(attr)\n            .add(legendItemGroup);\n        \n            // Draw the marker\n            if (markerOptions && markerOptions.enabled !== false) {\n                radius = markerOptions.radius;\n                this.legendSymbol = legendSymbol = renderer.symbol(\n                    this.symbol,\n                    (symbolWidth / 2) - radius,\n                    verticalCenter - radius,\n                    2 * radius,\n                    2 * radius,\n                    markerOptions\n                )\n                .addClass('highcharts-point')\n                .add(legendItemGroup);\n                legendSymbol.isMarker = true;\n            }\n        }\n    };\n\n    // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n    // and for #2580, a similar drawing flaw in Firefox 26.\n    // Explore if there's a general cause for this. The problem may be related\n    // to nested group elements, as the legend item texts are within 4 group elements.\n    if (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n        wrap(Legend.prototype, 'positionItem', function (proceed, item) {\n            var legend = this,\n                runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n                    if (item._legendItemPos) {\n                        proceed.call(legend, item);\n                    }\n                };\n\n            // Do it now, for export and to get checkbox placement\n            runPositionItem();\n\n            // Do it after to work around the core issue\n            setTimeout(runPositionItem);\n        });\n    }\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            animate = H.animate,\n            attr = H.attr,\n            doc = H.doc,\n            Axis = H.Axis, // @todo add as requirement\n            CanVGController = H.CanVGController,\n            createElement = H.createElement,\n            defaultOptions = H.defaultOptions,\n            discardElement = H.discardElement,\n            charts = H.charts,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            error = H.error,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            getStyle = H.getStyle,\n            grep = H.grep,\n            isString = H.isString,\n            Legend = H.Legend, // @todo add as requirement\n            marginNames = H.marginNames,\n            merge = H.merge,\n            Pointer = H.Pointer, // @todo add as requirement\n            pick = H.pick,\n            pInt = H.pInt,\n            removeEvent = H.removeEvent,\n            seriesTypes = H.seriesTypes,\n            splat = H.splat,\n            svg = H.svg,\n            syncTimeout = H.syncTimeout,\n            win = H.win,\n            Renderer = H.Renderer,\n            useCanVG = H.useCanVG;\n    /**\n     * The Chart class\n     * @param {String|Object} renderTo The DOM element to render to, or its id\n     * @param {Object} options\n     * @param {Function} callback Function to run when the chart has loaded\n     */\n    var Chart = Highcharts.Chart = function () {\n        this.getArgs.apply(this, arguments);\n    };\n\n    Highcharts.chart = function (a, b, c) {\n        return new Chart(a, b, c);\n    };\n\n    Chart.prototype = {\n\n        /**\n         * Hook for modules\n         */\n        callbacks: [],\n\n        ";
if (!build.classic) { 
s += "\n        colorCount: 10,\n        ";
} 
s += "\n\n        /**\n         * Handle the arguments passed to the constructor\n         * @returns {Array} Arguments without renderTo\n         */\n        getArgs: function () {\n            var args = [].slice.call(arguments);\n        \n            // Remove the optional first argument, renderTo, and\n            // set it on this.\n            if (isString(args[0]) || args[0].nodeName) {\n                this.renderTo = args.shift();\n            }\n            this.init(args[0], args[1]);\n        },\n\n        /**\n         * Initialize the chart\n         */\n        init: function (userOptions, callback) {\n\n            // Handle regular options\n            var options,\n                seriesOptions = userOptions.series; // skip merging data points to increase performance\n\n            userOptions.series = null;\n            options = merge(defaultOptions, userOptions); // do the merge\n            options.series = userOptions.series = seriesOptions; // set back the series data\n            this.userOptions = userOptions;\n\n            var optionsChart = options.chart;\n\n            // Create margin & spacing array\n            this.margin = this.splashArray('margin', optionsChart);\n            this.spacing = this.splashArray('spacing', optionsChart);\n\n            var chartEvents = optionsChart.events;\n\n            //this.runChartClick = chartEvents && !!chartEvents.click;\n            this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n            this.callback = callback;\n            this.isResizing = 0;\n            this.options = options;\n            //chartTitleOptions = undefined;\n            //chartSubtitleOptions = undefined;\n\n            this.axes = [];\n            this.series = [];\n            this.hasCartesianSeries = optionsChart.showAxes;\n            //this.axisOffset = undefined;\n            //this.maxTicks = undefined; // handle the greatest amount of ticks on grouped axes\n            //this.inverted = undefined;\n            //this.loadingShown = undefined;\n            //this.container = undefined;\n            //this.chartWidth = undefined;\n            //this.chartHeight = undefined;\n            //this.marginRight = undefined;\n            //this.marginBottom = undefined;\n            //this.containerWidth = undefined;\n            //this.containerHeight = undefined;\n            //this.oldChartWidth = undefined;\n            //this.oldChartHeight = undefined;\n\n            //this.renderTo = undefined;\n            //this.renderToClone = undefined;\n\n            //this.spacingBox = undefined\n\n            //this.legend = undefined;\n\n            // Elements\n            //this.chartBackground = undefined;\n            //this.plotBackground = undefined;\n            //this.plotBGImage = undefined;\n            //this.plotBorder = undefined;\n            //this.loadingDiv = undefined;\n            //this.loadingSpan = undefined;\n\n            var chart = this,\n                eventType;\n\n            // Add the chart to the global lookup\n            chart.index = charts.length;\n            charts.push(chart);\n            H.chartCount++;\n\n            // Set up auto resize\n            if (optionsChart.reflow !== false) {\n                addEvent(chart, 'load', function () {\n                    chart.initReflow();\n                });\n            }\n\n            // Chart event handlers\n            if (chartEvents) {\n                for (eventType in chartEvents) {\n                    addEvent(chart, eventType, chartEvents[eventType]);\n                }\n            }\n\n            chart.xAxis = [];\n            chart.yAxis = [];\n\n            // Expose methods and variables\n            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n            chart.firstRender();\n        },\n\n        /**\n         * Initialize an individual series, called internally before render time\n         */\n        initSeries: function (options) {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n                series,\n                constr = seriesTypes[type];\n\n            // No such series type\n            if (!constr) {\n                error(17, true);\n            }\n\n            series = new constr();\n            series.init(this, options);\n            return series;\n        },\n\n        /**\n         * Check whether a given point is within the plot area\n         *\n         * @param {Number} plotX Pixel x relative to the plot area\n         * @param {Number} plotY Pixel y relative to the plot area\n         * @param {Boolean} inverted Whether the chart is inverted\n         */\n        isInsidePlot: function (plotX, plotY, inverted) {\n            var x = inverted ? plotY : plotX,\n                y = inverted ? plotX : plotY;\n\n            return x >= 0 &&\n                x <= this.plotWidth &&\n                y >= 0 &&\n                y <= this.plotHeight;\n        },\n\n        /**\n         * Redraw legend, axes or series based on updated data\n         *\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        redraw: function (animation) {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series,\n                pointer = chart.pointer,\n                legend = chart.legend,\n                redrawLegend = chart.isDirtyLegend,\n                hasStackedSeries,\n                hasDirtyStacks,\n                hasCartesianSeries = chart.hasCartesianSeries,\n                isDirtyBox = chart.isDirtyBox,\n                seriesLength = series.length,\n                i = seriesLength,\n                serie,\n                renderer = chart.renderer,\n                isHiddenChart = renderer.isHidden(),\n                afterRedraw = [];\n            \n            H.setAnimation(animation, chart);\n        \n            if (isHiddenChart) {\n                chart.cloneRenderTo();\n            }\n\n            // Adjust title layout (reflow multiline text)\n            chart.layOutTitles();\n\n            // link stacked series\n            while (i--) {\n                serie = series[i];\n\n                if (serie.options.stacking) {\n                    hasStackedSeries = true;\n\n                    if (serie.isDirty) {\n                        hasDirtyStacks = true;\n                        break;\n                    }\n                }\n            }\n            if (hasDirtyStacks) { // mark others as dirty\n                i = seriesLength;\n                while (i--) {\n                    serie = series[i];\n                    if (serie.options.stacking) {\n                        serie.isDirty = true;\n                    }\n                }\n            }\n\n            // Handle updated data in the series\n            each(series, function (serie) {\n                if (serie.isDirty) {\n                    if (serie.options.legendType === 'point') {\n                        if (serie.updateTotals) {\n                            serie.updateTotals();\n                        }\n                        redrawLegend = true;\n                    }\n                }\n            });\n\n            // handle added or removed series\n            if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n                // draw legend graphics\n                legend.render();\n\n                chart.isDirtyLegend = false;\n            }\n\n            // reset stacks\n            if (hasStackedSeries) {\n                chart.getStacks();\n            }\n\n\n            if (hasCartesianSeries) {\n                if (!chart.isResizing) {\n\n                    // reset maxTicks\n                    chart.maxTicks = null;\n\n                    // set axes scales\n                    each(axes, function (axis) {\n                        axis.setScale();\n                    });\n                }\n            }\n\n            chart.getMargins(); // #3098\n\n            if (hasCartesianSeries) {\n                // If one axis is dirty, all axes must be redrawn (#792, #2169)\n                each(axes, function (axis) {\n                    if (axis.isDirty) {\n                        isDirtyBox = true;\n                    }\n                });\n\n                // redraw axes\n                each(axes, function (axis) {\n\n                    // Fire 'afterSetExtremes' only if extremes are set\n                    var key = axis.min + ',' + axis.max;\n                    if (axis.extKey !== key) { // #821, #4452\n                        axis.extKey = key;\n                        afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n                            delete axis.eventArgs;\n                        });\n                    }\n                    if (isDirtyBox || hasStackedSeries) {\n                        axis.redraw();\n                    }\n                });\n            }\n\n            // the plot areas size has changed\n            if (isDirtyBox) {\n                chart.drawChartBox();\n            }\n\n\n            // redraw affected series\n            each(series, function (serie) {\n                if (serie.isDirty && serie.visible &&\n                        (!serie.isCartesian || serie.xAxis)) { // issue #153\n                    serie.redraw();\n                }\n            });\n\n            // move tooltip or reset\n            if (pointer) {\n                pointer.reset(true);\n            }\n\n            // redraw if canvas\n            renderer.draw();\n\n            // fire the event\n            fireEvent(chart, 'redraw');\n\n            if (isHiddenChart) {\n                chart.cloneRenderTo(true);\n            }\n\n            // Fire callbacks that are put on hold until after the redraw\n            each(afterRedraw, function (callback) {\n                callback.call();\n            });\n        },\n\n        /**\n         * Get an axis, series or point object by id.\n         * @param id {String} The id as given in the configuration options\n         */\n        get: function (id) {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series;\n\n            var i,\n                j,\n                points;\n\n            // search axes\n            for (i = 0; i < axes.length; i++) {\n                if (axes[i].options.id === id) {\n                    return axes[i];\n                }\n            }\n\n            // search series\n            for (i = 0; i < series.length; i++) {\n                if (series[i].options.id === id) {\n                    return series[i];\n                }\n            }\n\n            // search points\n            for (i = 0; i < series.length; i++) {\n                points = series[i].points || [];\n                for (j = 0; j < points.length; j++) {\n                    if (points[j].id === id) {\n                        return points[j];\n                    }\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Create the Axis instances based on the config options\n         */\n        getAxes: function () {\n            var chart = this,\n                options = this.options,\n                xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n                yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n                optionsArray;\n\n            // make sure the options are arrays and add some members\n            each(xAxisOptions, function (axis, i) {\n                axis.index = i;\n                axis.isX = true;\n            });\n\n            each(yAxisOptions, function (axis, i) {\n                axis.index = i;\n            });\n\n            // concatenate all axis options into one array\n            optionsArray = xAxisOptions.concat(yAxisOptions);\n\n            each(optionsArray, function (axisOptions) {\n                new Axis(chart, axisOptions); // eslint-disable-line no-new\n            });\n        },\n\n\n        /**\n         * Get the currently selected points from all series\n         */\n        getSelectedPoints: function () {\n            var points = [];\n            each(this.series, function (serie) {\n                points = points.concat(grep(serie.points || [], function (point) {\n                    return point.selected;\n                }));\n            });\n            return points;\n        },\n\n        /**\n         * Get the currently selected series\n         */\n        getSelectedSeries: function () {\n            return grep(this.series, function (serie) {\n                return serie.selected;\n            });\n        },\n\n        /**\n         * Show the title and subtitle of the chart\n         *\n         * @param titleOptions {Object} New title options\n         * @param subtitleOptions {Object} New subtitle options\n         *\n         */\n        setTitle: function (titleOptions, subtitleOptions, redraw) {\n            var chart = this,\n                options = chart.options,\n                chartTitleOptions,\n                chartSubtitleOptions;\n\n            chartTitleOptions = options.title = merge(options.title, titleOptions);\n            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n            // add title and subtitle\n            each([\n                ['title', titleOptions, chartTitleOptions],\n                ['subtitle', subtitleOptions, chartSubtitleOptions]\n            ], function (arr) {\n                var name = arr[0],\n                    title = chart[name],\n                    titleOptions = arr[1],\n                    chartTitleOptions = arr[2];\n\n                if (title && titleOptions) {\n                    chart[name] = title = title.destroy(); // remove old\n                }\n\n                if (chartTitleOptions && chartTitleOptions.text && !title) {\n                    chart[name] = chart.renderer.text(\n                        chartTitleOptions.text,\n                        0,\n                        0,\n                        chartTitleOptions.useHTML\n                    )\n                    .attr({\n                        align: chartTitleOptions.align,\n                        'class': 'highcharts-' + name,\n                        zIndex: chartTitleOptions.zIndex || 4\n                    })\n                    .css(chartTitleOptions.style)\n                    .add();\n                }\n            });\n            chart.layOutTitles(redraw);\n        },\n\n        /**\n         * Lay out the chart titles and cache the full offset height for use in getMargins\n         */\n        layOutTitles: function (redraw) {\n            var titleOffset = 0,\n                title = this.title,\n                subtitle = this.subtitle,\n                options = this.options,\n                titleOptions = options.title,\n                subtitleOptions = options.subtitle,\n                requiresDirtyBox,\n                renderer = this.renderer,\n                titleSize,\n                autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button\n\n            if (title) {\n                ";
if (build.classic) { 
s += "\n                titleSize = titleOptions.style.fontSize;\n                ";
} 
s += "\n                titleSize = renderer.fontMetrics(titleSize, title).b;\n            \n                title\n                    .css({ width: (titleOptions.width || autoWidth) + 'px' })\n                    .align(extend({ \n                        y: titleSize - 3\n                    }, titleOptions), false, 'spacingBox');\n\n                if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                    titleOffset = title.getBBox().height;\n                }\n            }\n            if (subtitle) {\n                subtitle\n                    .css({ width: (subtitleOptions.width || autoWidth) + 'px' })\n                    .align(extend({ \n                        y: titleOffset + (titleOptions.margin - 13) + (titleSize || 0)\n                    }, subtitleOptions), false, 'spacingBox');\n\n                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {\n                    titleOffset = Math.ceil(titleOffset + subtitle.getBBox().height);\n                }\n            }\n\n            requiresDirtyBox = this.titleOffset !== titleOffset;\n            this.titleOffset = titleOffset; // used in getMargins\n\n            if (!this.isDirtyBox && requiresDirtyBox) {\n                this.isDirtyBox = requiresDirtyBox;\n                // Redraw if necessary (#2719, #2744)\n                if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                    this.redraw();\n                }\n            }\n        },\n\n        /**\n         * Get chart width and height according to options and container size\n         */\n        getChartSize: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                widthOption = optionsChart.width,\n                heightOption = optionsChart.height,\n                renderTo = chart.renderToClone || chart.renderTo;\n\n            // Get inner width and height\n            if (!defined(widthOption)) {\n                chart.containerWidth = getStyle(renderTo, 'width');\n            }\n            if (!defined(heightOption)) {\n                chart.containerHeight = getStyle(renderTo, 'height');\n            }\n        \n            chart.chartWidth = Math.max(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n            chart.chartHeight = Math.max(0, pick(heightOption,\n                // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n                chart.containerHeight > 19 ? chart.containerHeight : 400));\n        },\n\n        /**\n         * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n         * size computation on chart.render and chart.redraw\n         */\n        cloneRenderTo: function (revert) {\n            var clone = this.renderToClone,\n                container = this.container;\n\n            // Destroy the clone and bring the container back to the real renderTo div\n            if (revert) {\n                if (clone) {\n                    this.renderTo.appendChild(container);\n                    discardElement(clone);\n                    delete this.renderToClone;\n                }\n\n            // Set up the clone\n            } else {\n                if (container && container.parentNode === this.renderTo) {\n                    this.renderTo.removeChild(container); // do not clone this\n                }\n                this.renderToClone = clone = this.renderTo.cloneNode(0);\n                css(clone, {\n                    position: 'absolute',\n                    top: '-9999px',\n                    display: 'block' // #833\n                });\n                if (clone.style.setProperty) { // #2631\n                    clone.style.setProperty('display', 'block', 'important');\n                }\n                doc.body.appendChild(clone);\n                if (container) {\n                    clone.appendChild(container);\n                }\n            }\n        },\n\n        /**\n         * Get the containing element, determine the size and create the inner container\n         * div to hold the chart\n         */\n        getContainer: function () {\n            var chart = this,\n                container,\n                options = chart.options,\n                optionsChart = options.chart,\n                chartWidth,\n                chartHeight,\n                renderTo = chart.renderTo,\n                indexAttrName = 'data-highcharts-chart',\n                oldChartIndex,\n                Ren,\n                containerId = 'highcharts-' + H.idCounter++,\n                containerStyle;\n\n            if (!renderTo) {\n                chart.renderTo = renderTo = optionsChart.renderTo;\n            }\n        \n            if (isString(renderTo)) {\n                chart.renderTo = renderTo = doc.getElementById(renderTo);\n            }\n\n            // Display an error if the renderTo is wrong\n            if (!renderTo) {\n                error(13, true);\n            }\n\n            // If the container already holds a chart, destroy it. The check for hasRendered is there\n            // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n            // attribute and the SVG contents, but not an interactive chart. So in this case,\n            // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n            oldChartIndex = pInt(attr(renderTo, indexAttrName));\n            if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n                charts[oldChartIndex].destroy();\n            }\n\n            // Make a reference to the chart from the div\n            attr(renderTo, indexAttrName, chart.index);\n\n            // remove previous chart\n            renderTo.innerHTML = '';\n\n            // If the container doesn't have an offsetWidth, it has or is a child of a node\n            // that has display:none. We need to temporarily move it out to a visible\n            // state to determine the size, else the legend and tooltips won't render\n            // properly. The allowClone option is used in sparklines as a micro optimization,\n            // saving about 1-2 ms each chart.\n            if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n                chart.cloneRenderTo();\n            }\n\n            // get the width and height\n            chart.getChartSize();\n            chartWidth = chart.chartWidth;\n            chartHeight = chart.chartHeight;\n\n            // Create the inner container\n            ";
if (build.classic) { 
s += "\n            containerStyle = extend({\n                position: 'relative',\n                overflow: 'hidden', // needed for context menu (avoid scrollbars) and\n                    // content overflow in IE\n                width: chartWidth + 'px',\n                height: chartHeight + 'px',\n                textAlign: 'left',\n                lineHeight: 'normal', // #427\n                zIndex: 0, // #1072\n                '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n            }, optionsChart.style);\n            ";
} 
s += "\n            chart.container = container = createElement('div', {\n                    className: 'highcharts-container ' + (optionsChart.className || ''),\n                    id: containerId\n                },\n                containerStyle,\n                chart.renderToClone || renderTo\n            );\n\n            // cache the cursor (#1650)\n            chart._cursor = container.style.cursor;\n\n            // Initialize the renderer\n            Ren = Highcharts[optionsChart.renderer] || Renderer;\n            chart.renderer = new Ren(\n                container,\n                chartWidth,\n                chartHeight,\n                optionsChart.style,\n                optionsChart.forExport,\n                options.exporting && options.exporting.allowHTML\n            );\n\n            if (useCanVG) {\n                // If we need canvg library, extend and configure the renderer\n                // to get the tracker for translating mouse events\n                chart.renderer.create(chart, container, chartWidth, chartHeight);\n            }\n            // Add a reference to the charts index\n            chart.renderer.chartIndex = chart.index;\n        },\n\n        /**\n         * Calculate margins by rendering axis labels in a preliminary position. Title,\n         * subtitle and legend have already been rendered at this stage, but will be\n         * moved into their final positions\n         */\n        getMargins: function (skipAxes) {\n            var chart = this,\n                spacing = chart.spacing,\n                margin = chart.margin,\n                titleOffset = chart.titleOffset;\n\n            chart.resetMargins();\n\n            // Adjust for title and subtitle\n            if (titleOffset && !defined(margin[0])) {\n                chart.plotTop = Math.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n            }\n\n            // Adjust for legend\n            chart.legend.adjustMargins(margin, spacing);\n\n            // adjust for scroller\n            if (chart.extraBottomMargin) {\n                chart.marginBottom += chart.extraBottomMargin;\n            }\n            if (chart.extraTopMargin) {\n                chart.plotTop += chart.extraTopMargin;\n            }\n            if (!skipAxes) {\n                this.getAxisMargins();\n            }\n        },\n\n        getAxisMargins: function () {\n\n            var chart = this,\n                axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n                margin = chart.margin;\n\n            // pre-render axes to get labels offset width\n            if (chart.hasCartesianSeries) {\n                each(chart.axes, function (axis) {\n                    if (axis.visible) {\n                        axis.getOffset();\n                    }\n                });\n            }\n\n            // Add the axis offsets\n            each(marginNames, function (m, side) {\n                if (!defined(margin[side])) {\n                    chart[m] += axisOffset[side];\n                }\n            });\n\n            chart.setChartSize();\n\n        },\n\n        /**\n         * Resize the chart to its container if size is not explicitly set\n         */\n        reflow: function (e) {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                renderTo = chart.renderTo,\n                width = optionsChart.width || getStyle(renderTo, 'width'),\n                height = optionsChart.height || getStyle(renderTo, 'height'),\n                target = e ? e.target : win;\n\n            // Width and height checks for display:none. Target is doc in IE8 and Opera,\n            // win in Firefox, Chrome and IE9.\n            if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n                if (width !== chart.containerWidth || height !== chart.containerHeight) {\n                    clearTimeout(chart.reflowTimeout);\n                    // When called from window.resize, e is set, else it's called directly (#2224)\n                    chart.reflowTimeout = syncTimeout(function () {\n                        if (chart.container) { // It may have been destroyed in the meantime (#1257)\n                            chart.setSize(width, height, false);\n                            chart.hasUserSize = null;\n                        }\n                    }, e ? 100 : 0);\n                }\n                chart.containerWidth = width;\n                chart.containerHeight = height;\n            }\n        },\n\n        /**\n         * Add the event handlers necessary for auto resizing\n         */\n        initReflow: function () {\n            var chart = this,\n                reflow = function (e) {\n                    chart.reflow(e);\n                };\n            \n        \n            addEvent(win, 'resize', reflow);\n            addEvent(chart, 'destroy', function () {\n                removeEvent(win, 'resize', reflow);\n            });\n        },\n\n        /**\n         * Resize the chart to a given width and height\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Object|Boolean} animation\n         */\n        setSize: function (width, height, animation) {\n            var chart = this,\n                chartWidth,\n                chartHeight,\n                renderer = chart.renderer,\n                globalAnimation;\n\n            // Handle the isResizing counter\n            chart.isResizing += 1;\n        \n            // set the animation for the current process\n            H.setAnimation(animation, chart);\n\n            chart.oldChartHeight = chart.chartHeight;\n            chart.oldChartWidth = chart.chartWidth;\n            if (defined(width)) {\n                chart.chartWidth = chartWidth = Math.max(0, Math.round(width));\n                chart.hasUserSize = !!chartWidth;\n            }\n            if (defined(height)) {\n                chart.chartHeight = chartHeight = Math.max(0, Math.round(height));\n            }\n\n            // Resize the container with the global animation applied if enabled (#2503)\n            ";
if (build.classic) { 
s += "\n            globalAnimation = renderer.globalAnimation;\n            (globalAnimation ? animate : css)(chart.container, {\n                width: chartWidth + 'px',\n                height: chartHeight + 'px'\n            }, globalAnimation);\n            ";
} 
s += "\n\n            chart.setChartSize(true);\n            renderer.setSize(chartWidth, chartHeight, animation);\n\n            // handle axes\n            chart.maxTicks = null;\n            each(chart.axes, function (axis) {\n                axis.isDirty = true;\n                axis.setScale();\n            });\n\n            // make sure non-cartesian series are also handled\n            each(chart.series, function (serie) {\n                serie.isDirty = true;\n            });\n\n            chart.isDirtyLegend = true; // force legend redraw\n            chart.isDirtyBox = true; // force redraw of plot and chart border\n\n            chart.layOutTitles(); // #2857\n            chart.getMargins();\n\n            chart.redraw(animation);\n\n\n            chart.oldChartHeight = null;\n            fireEvent(chart, 'resize');\n\n            // Fire endResize and set isResizing back. If animation is disabled, fire without delay\n            globalAnimation = renderer.globalAnimation; // Reassign it before using it, it may have changed since the top of this function.\n            syncTimeout(function () {\n                if (chart) {\n                    fireEvent(chart, 'endResize', null, function () {\n                        chart.isResizing -= 1;\n                    });\n                }\n            }, globalAnimation === false ? 0 : ((globalAnimation && globalAnimation.duration) || 500));\n        },\n\n        /**\n         * Set the public chart properties. This is done before and after the pre-render\n         * to determine margin sizes\n         */\n        setChartSize: function (skipAxes) {\n            var chart = this,\n                inverted = chart.inverted,\n                renderer = chart.renderer,\n                chartWidth = chart.chartWidth,\n                chartHeight = chart.chartHeight,\n                optionsChart = chart.options.chart,\n                spacing = chart.spacing,\n                clipOffset = chart.clipOffset,\n                clipX,\n                clipY,\n                plotLeft,\n                plotTop,\n                plotWidth,\n                plotHeight,\n                plotBorderWidth;\n\n            chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n            chart.plotTop = plotTop = Math.round(chart.plotTop);\n            chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));\n            chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));\n\n            chart.plotSizeX = inverted ? plotHeight : plotWidth;\n            chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n            // Set boxes used for alignment\n            chart.spacingBox = renderer.spacingBox = {\n                x: spacing[3],\n                y: spacing[0],\n                width: chartWidth - spacing[3] - spacing[1],\n                height: chartHeight - spacing[0] - spacing[2]\n            };\n            chart.plotBox = renderer.plotBox = {\n                x: plotLeft,\n                y: plotTop,\n                width: plotWidth,\n                height: plotHeight\n            };\n\n            plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n            clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);\n            clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);\n            chart.clipBox = {\n                x: clipX, \n                y: clipY, \n                width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX), \n                height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n            };\n\n            if (!skipAxes) {\n                each(chart.axes, function (axis) {\n                    axis.setAxisSize();\n                    axis.setAxisTranslation();\n                });\n            }\n        },\n\n        /**\n         * Initial margins before auto size margins are applied\n         */\n        resetMargins: function () {\n            var chart = this;\n\n            each(marginNames, function (m, side) {\n                chart[m] = pick(chart.margin[side], chart.spacing[side]);\n            });\n            chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n            chart.clipOffset = [0, 0, 0, 0];\n        },\n\n        /**\n         * Draw the borders and backgrounds for chart and plot area\n         */\n        drawChartBox: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                renderer = chart.renderer,\n                chartWidth = chart.chartWidth,\n                chartHeight = chart.chartHeight,\n                chartBackground = chart.chartBackground,\n                plotBackground = chart.plotBackground,\n                plotBorder = chart.plotBorder,\n                chartBorderWidth,\n                ";
if (build.classic) { 
s += "\n                plotBGImage = chart.plotBGImage,\n                chartBackgroundColor = optionsChart.backgroundColor,\n                plotBackgroundColor = optionsChart.plotBackgroundColor,\n                plotBackgroundImage = optionsChart.plotBackgroundImage,\n                ";
} 
s += "\n                plotBorderWidth,\n                mgn,\n                bgAttr,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                plotBox = chart.plotBox,\n                clipRect = chart.clipRect,\n                clipBox = chart.clipBox,\n                verb = 'animate';\n\n            // Chart area\n            if (!chartBackground) {\n                chart.chartBackground = chartBackground = renderer.rect()\n                    .addClass('highcharts-background')\n                    .add();\n                verb = 'attr';\n            }\n\n            ";
if (!build.classic) { 
s += "\n            chartBorderWidth = mgn = chartBackground.pxStyle('stroke-width');\n            ";
} else { 
s += "\n\n            chartBorderWidth = optionsChart.borderWidth || 0;\n            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n            bgAttr = {\n                fill: chartBackgroundColor || 'none'\n            };\n\n            if (chartBorderWidth) { // #980\n                bgAttr.stroke = optionsChart.borderColor;\n                bgAttr['stroke-width'] = chartBorderWidth;\n            }\n            chartBackground\n                .attr(bgAttr)\n                .shadow(optionsChart.shadow);\n            ";
} 
s += "\n\n            chartBackground[verb]({\n                x: mgn / 2,\n                y: mgn / 2,\n                width: chartWidth - mgn - chartBorderWidth % 2,\n                height: chartHeight - mgn - chartBorderWidth % 2,\n                r: optionsChart.borderRadius\n            });\n\n            // Plot background\n            verb = 'animate';\n            if (!plotBackground) {\n                verb = 'attr';\n                chart.plotBackground = plotBackground = renderer.rect()\n                    .addClass('highcharts-plot-background')\n                    .add();\n            }\n            plotBackground[verb](plotBox);\n\n            ";
if (build.classic) { 
s += "\n            // Presentational attributes for the background\n            plotBackground\n                .attr({\n                    fill: plotBackgroundColor || 'none'\n                })\n                .shadow(optionsChart.plotShadow);\n        \n            // Create the background image\n            if (plotBackgroundImage) {\n                if (!plotBGImage) {\n                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n                        .add();\n                } else {\n                    plotBGImage.animate(plotBox);\n                }\n            }\n            ";
} 
s += "\n        \n            // Plot clip\n            if (!clipRect) {\n                chart.clipRect = renderer.clipRect(clipBox);\n            } else {\n                clipRect.animate({\n                    width: clipBox.width,\n                    height: clipBox.height\n                });\n            }\n\n            // Plot area border\n            verb = 'animate';\n            if (!plotBorder) {\n                verb = 'attr';\n                chart.plotBorder = plotBorder = renderer.rect()\n                    .addClass('highcharts-plot-border')\n                    .attr({\n                        zIndex: 1 // Above the grid\n                    })\n                    .add();\n            }\n            ";
if (!build.classic) { 
s += "\n            plotBorderWidth = plotBorder.pxStyle('stroke-width');\n\n            ";
} else { 
s += "\n            plotBorderWidth = optionsChart.plotBorderWidth || 0;\n            plotBorder.attr({\n                stroke: optionsChart.plotBorderColor,\n                'stroke-width': plotBorderWidth,\n                fill: 'none'\n            });\n            ";
} 
s += "\n\n            plotBorder[verb](plotBorder.crisp({\n                x: plotLeft,\n                y: plotTop,\n                width: plotWidth,\n                height: plotHeight\n            }, -plotBorderWidth)); //#3282 plotBorder should be negative;\n\n            // reset\n            chart.isDirtyBox = false;\n        },\n\n        /**\n         * Detect whether a certain chart property is needed based on inspecting its options\n         * and series. This mainly applies to the chart.invert property, and in extensions to\n         * the chart.angular and chart.polar properties.\n         */\n        propFromSeries: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                klass,\n                seriesOptions = chart.options.series,\n                i,\n                value;\n\n\n            each(['inverted', 'angular', 'polar'], function (key) {\n\n                // The default series type's class\n                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n\n                // Get the value from available chart-wide properties\n                value = (\n                    chart[key] || // 1. it is set before\n                    optionsChart[key] || // 2. it is set in the options\n                    (klass && klass.prototype[key]) // 3. it's default series class requires it\n                );\n\n                // 4. Check if any the chart's series require it\n                i = seriesOptions && seriesOptions.length;\n                while (!value && i--) {\n                    klass = seriesTypes[seriesOptions[i].type];\n                    if (klass && klass.prototype[key]) {\n                        value = true;\n                    }\n                }\n\n                // Set the chart property\n                chart[key] = value;\n            });\n\n        },\n\n        /**\n         * Link two or more series together. This is done initially from Chart.render,\n         * and after Chart.addSeries and Series.remove.\n         */\n        linkSeries: function () {\n            var chart = this,\n                chartSeries = chart.series;\n\n            // Reset links\n            each(chartSeries, function (series) {\n                series.linkedSeries.length = 0;\n            });\n\n            // Apply new links\n            each(chartSeries, function (series) {\n                var linkedTo = series.options.linkedTo;\n                if (isString(linkedTo)) {\n                    if (linkedTo === ':previous') {\n                        linkedTo = chart.series[series.index - 1];\n                    } else {\n                        linkedTo = chart.get(linkedTo);\n                    }\n                    if (linkedTo) {\n                        linkedTo.linkedSeries.push(series);\n                        series.linkedParent = linkedTo;\n                        series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879\n                    }\n                }\n            });\n        },\n\n        /**\n         * Render series for the chart\n         */\n        renderSeries: function () {\n            each(this.series, function (serie) {\n                serie.translate();\n                serie.render();\n            });\n        },\n\n        /**\n         * Render labels for the chart\n         */\n        renderLabels: function () {\n            var chart = this,\n                labels = chart.options.labels;\n            if (labels.items) {\n                each(labels.items, function (label) {\n                    var style = extend(labels.style, label.style),\n                        x = pInt(style.left) + chart.plotLeft,\n                        y = pInt(style.top) + chart.plotTop + 12;\n\n                    // delete to prevent rewriting in IE\n                    delete style.left;\n                    delete style.top;\n\n                    chart.renderer.text(\n                        label.html,\n                        x,\n                        y\n                    )\n                    .attr({ zIndex: 2 })\n                    .css(style)\n                    .add();\n\n                });\n            }\n        },\n\n        /**\n         * Render all graphics for the chart\n         */\n        render: function () {\n            var chart = this,\n                axes = chart.axes,\n                renderer = chart.renderer,\n                options = chart.options,\n                tempWidth,\n                tempHeight,\n                redoHorizontal,\n                redoVertical;\n\n            // Title\n            chart.setTitle();\n\n\n            // Legend\n            chart.legend = new Legend(chart, options.legend);\n\n            // Get stacks\n            if (chart.getStacks) {\n                chart.getStacks();\n            }\n\n            // Get chart margins\n            chart.getMargins(true);\n            chart.setChartSize();\n\n            // Record preliminary dimensions for later comparison\n            tempWidth = chart.plotWidth;\n            tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels\n\n            // Get margins by pre-rendering axes\n            each(axes, function (axis) {\n                axis.setScale();\n            });\n            chart.getAxisMargins();\n\n            // If the plot area size has changed significantly, calculate tick positions again\n            redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n            redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive\n\n            if (redoHorizontal || redoVertical) {\n\n                chart.maxTicks = null; // reset for second pass\n                each(axes, function (axis) {\n                    if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n                        axis.setTickInterval(true); // update to reflect the new margins\n                    }\n                });\n                chart.getMargins(); // second pass to check for new labels\n            }\n\n            // Draw the borders and backgrounds\n            chart.drawChartBox();\n\n\n            // Axes\n            if (chart.hasCartesianSeries) {\n                each(axes, function (axis) {\n                    if (axis.visible) {\n                        axis.render();\n                    }\n                });\n            }\n\n            // The series\n            if (!chart.seriesGroup) {\n                chart.seriesGroup = renderer.g('series-group')\n                    .attr({ zIndex: 3 })\n                    .add();\n            }\n            chart.renderSeries();\n\n            // Labels\n            chart.renderLabels();\n\n            // Credits\n            chart.showCredits(options.credits);\n\n            // Set flag\n            chart.hasRendered = true;\n\n        },\n\n        /**\n         * Show chart credits based on config options\n         */\n        showCredits: function (credits) {\n            if (credits.enabled && !this.credits) {\n                this.credits = this.renderer.text(\n                    credits.text,\n                    0,\n                    0\n                )\n                .addClass('highcharts-credits')\n                .on('click', function () {\n                    if (credits.href) {\n                        win.location.href = credits.href;\n                    }\n                })\n                .attr({\n                    align: credits.position.align,\n                    zIndex: 8\n                })\n                ";
if (build.classic) { 
s += "\n                .css(credits.style)\n                ";
} 
s += "\n                .add()\n                .align(credits.position);\n            }\n        },\n\n        /**\n         * Clean up memory usage\n         */\n        destroy: function () {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series,\n                container = chart.container,\n                i,\n                parentNode = container && container.parentNode;\n\n            // fire the chart.destoy event\n            fireEvent(chart, 'destroy');\n\n            // Delete the chart from charts lookup array\n            charts[chart.index] = undefined;\n            H.chartCount--;\n            chart.renderTo.removeAttribute('data-highcharts-chart');\n\n            // remove events\n            removeEvent(chart);\n\n            // ==== Destroy collections:\n            // Destroy axes\n            i = axes.length;\n            while (i--) {\n                axes[i] = axes[i].destroy();\n            }\n\n            // Destroy each series\n            i = series.length;\n            while (i--) {\n                series[i] = series[i].destroy();\n            }\n\n            // ==== Destroy chart properties:\n            each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',\n                    'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',\n                    'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n                var prop = chart[name];\n\n                if (prop && prop.destroy) {\n                    chart[name] = prop.destroy();\n                }\n            });\n\n            // remove container and all SVG\n            if (container) { // can break in IE when destroyed before finished loading\n                container.innerHTML = '';\n                removeEvent(container);\n                if (parentNode) {\n                    discardElement(container);\n                }\n\n            }\n\n            // clean it all up\n            for (i in chart) {\n                delete chart[i];\n            }\n\n        },\n\n\n        /**\n         * VML namespaces can't be added until after complete. Listening\n         * for Perini's doScroll hack is not enough.\n         */\n        isReadyToRender: function () {\n            var chart = this;\n\n            // Note: win == win.top is required\n            if ((!svg && (win == win.top && win.readyState !== 'complete')) || (useCanVG && !win.canvg)) { // eslint-disable-line eqeqeq\n                if (useCanVG) {\n                    // Delay rendering until canvg library is downloaded and ready\n                    CanVGController.push(function () {\n                        chart.firstRender();\n                    }, chart.options.global.canvasToolsURL);\n                } else {\n                    doc.attachEvent('onreadystatechange', function () {\n                        doc.detachEvent('onreadystatechange', chart.firstRender);\n                        if (doc.readyState === 'complete') {\n                            chart.firstRender();\n                        }\n                    });\n                }\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Prepare for first rendering after all data are loaded\n         */\n        firstRender: function () {\n            var chart = this,\n                options = chart.options,\n                callback = chart.callback;\n\n            // Check whether the chart is ready to render\n            if (!chart.isReadyToRender()) {\n                return;\n            }\n\n            // Create the container\n            chart.getContainer();\n\n            // Run an early event after the container and renderer are established\n            fireEvent(chart, 'init');\n\n\n            chart.resetMargins();\n            chart.setChartSize();\n\n            // Set the common chart properties (mainly invert) from the given series\n            chart.propFromSeries();\n\n            // get axes\n            chart.getAxes();\n\n            // Initialize the series\n            each(options.series || [], function (serieOptions) {\n                chart.initSeries(serieOptions);\n            });\n\n            chart.linkSeries();\n\n            // Run an event after axes and series are initialized, but before render. At this stage,\n            // the series data is indexed and cached in the xData and yData arrays, so we can access\n            // those before rendering. Used in Highstock.\n            fireEvent(chart, 'beforeRender');\n\n            // depends on inverted and on margins being set\n            if (Pointer) {\n                chart.pointer = new Pointer(chart, options);\n            }\n\n            chart.render();\n\n            // add canvas\n            chart.renderer.draw();\n            // run callbacks\n            if (callback) {\n                callback.apply(chart, [chart]);\n            }\n            each(chart.callbacks, function (fn) {\n                if (chart.index !== undefined) { // Chart destroyed in its own callback (#3600)\n                    fn.apply(chart, [chart]);\n                }\n            });\n\n            // Fire the load event\n            fireEvent(chart, 'load');\n\n            // If the chart was rendered outside the top container, put it back in (#3679)\n            chart.cloneRenderTo(true);\n\n        },\n\n        /**\n        * Creates arrays for spacing and margin from given options.\n        */\n        splashArray: function (target, options) {\n            var oVar = options[target],\n                tArray = H.isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n            return [pick(options[target + 'Top'], tArray[0]),\n                    pick(options[target + 'Right'], tArray[1]),\n                    pick(options[target + 'Bottom'], tArray[2]),\n                    pick(options[target + 'Left'], tArray[3])];\n        }\n    }; // end Chart\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Point,\n\n            each = H.each,\n            extend = H.extend,\n            erase = H.erase,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            isArray = H.isArray,\n            pick = H.pick,\n            removeEvent = H.removeEvent;\n\n    /**\n     * The Point object and prototype. Inheritable and used as base for PiePoint\n     */\n    Point = H.Point = function () {};\n    Point.prototype = {\n\n        /**\n         * Initialize the point\n         * @param {Object} series The series object containing this point\n         * @param {Object} options The data in either number, array or object format\n         */\n        init: function (series, options, x) {\n\n            var point = this,\n                colors;\n            point.series = series;\n            point.color = series.color; // #3445\n            point.applyOptions(options, x);\n\n            if (series.options.colorByPoint) {\n                colors = series.options.colors || series.chart.options.colors;\n                ";
if (build.classic) { 
s += "\n                point.color = point.color || colors[series.colorCounter];\n                ";
} 
s += "\n                point.colorIndex = series.colorCounter;\n                series.colorCounter++;\n                // loop back to zero\n                if (series.colorCounter === colors.length) {\n                    series.colorCounter = 0;\n                }\n            }\n\n            series.chart.pointCount++;\n            return point;\n        },\n        /**\n         * Apply the options containing the x and y data and possible some extra properties.\n         * This is called on point init or from point.update.\n         *\n         * @param {Object} options\n         */\n        applyOptions: function (options, x) {\n            var point = this,\n                series = point.series,\n                pointValKey = series.options.pointValKey || series.pointValKey;\n\n            options = Point.prototype.optionsToObject.call(this, options);\n\n            // copy options directly to point\n            extend(point, options);\n            point.options = point.options ? extend(point.options, options) : options;\n\n            // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n            if (pointValKey) {\n                point.y = point[pointValKey];\n            }\n            point.isNull = point.y === null;\n\n            // If no x is set by now, get auto incremented value. All points must have an\n            // x value, however the y value can be null to create a gap in the series\n            if (point.x === undefined && series) {\n                point.x = x === undefined ? series.autoIncrement() : x;\n            }\n\n            return point;\n        },\n\n        /**\n         * Transform number or array configs into objects\n         */\n        optionsToObject: function (options) {\n            var ret = {},\n                series = this.series,\n                keys = series.options.keys,\n                pointArrayMap = keys || series.pointArrayMap || ['y'],\n                valueCount = pointArrayMap.length,\n                firstItemType,\n                i = 0,\n                j = 0;\n\n            if (typeof options === 'number' || options === null) {\n                ret[pointArrayMap[0]] = options;\n\n            } else if (isArray(options)) {\n                // with leading x value\n                if (!keys && options.length > valueCount) {\n                    firstItemType = typeof options[0];\n                    if (firstItemType === 'string') {\n                        ret.name = options[0];\n                    } else if (firstItemType === 'number') {\n                        ret.x = options[0];\n                    }\n                    i++;\n                }\n                while (j < valueCount) {\n                    if (!keys || options[i] !== undefined) { // Skip undefined positions for keys\n                        ret[pointArrayMap[j]] = options[i];\n                    }\n                    i++;\n                    j++;\n                }\n            } else if (typeof options === 'object') {\n                ret = options;\n\n                // This is the fastest way to detect if there are individual point dataLabels that need\n                // to be considered in drawDataLabels. These can only occur in object configs.\n                if (options.dataLabels) {\n                    series._hasPointLabels = true;\n                }\n\n                // Same approach as above for markers\n                if (options.marker) {\n                    series._hasPointMarkers = true;\n                }\n            }\n            return ret;\n        },\n\n        /**\n         * Return the zone that the point belongs to\n         */\n        getZone: function () {\n            var series = this.series,\n                zones = series.zones,\n                zoneAxis = series.zoneAxis || 'y',\n                i = 0,\n                zone;\n\n            zone = zones[i];\n            while (this[zoneAxis] >= zone.value) {            \n                zone = zones[++i];\n            }\n\n            if (zone && zone.color && !this.options.color) {\n                this.color = zone.color;\n            }\n\n            return zone;\n        },\n\n        /**\n         * Destroy a point to clear memory. Its reference still stays in series.data.\n         */\n        destroy: function () {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                hoverPoints = chart.hoverPoints,\n                prop;\n\n            chart.pointCount--;\n\n            if (hoverPoints) {\n                point.setState();\n                erase(hoverPoints, point);\n                if (!hoverPoints.length) {\n                    chart.hoverPoints = null;\n                }\n\n            }\n            if (point === chart.hoverPoint) {\n                point.onMouseOut();\n            }\n\n            // remove all events\n            if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n                removeEvent(point);\n                point.destroyElements();\n            }\n\n            if (point.legendItem) { // pies have legend items\n                chart.legend.destroyItem(point);\n            }\n\n            for (prop in point) {\n                point[prop] = null;\n            }\n\n\n        },\n\n        /**\n         * Destroy SVG elements associated with the point\n         */\n        destroyElements: function () {\n            var point = this,\n                props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n                prop,\n                i = 6;\n            while (i--) {\n                prop = props[i];\n                if (point[prop]) {\n                    point[prop] = point[prop].destroy();\n                }\n            }\n        },\n\n        /**\n         * Return the configuration hash needed for the data label and tooltip formatters\n         */\n        getLabelConfig: function () {\n            return {\n                x: this.category,\n                y: this.y,\n                color: this.color,\n                key: this.name || this.category,\n                series: this.series,\n                point: this,\n                percentage: this.percentage,\n                total: this.total || this.stackTotal\n            };\n        },\n\n        /**\n         * Extendable method for formatting each point's tooltip line\n         *\n         * @return {String} A string to be concatenated in to the common tooltip text\n         */\n        tooltipFormatter: function (pointFormat) {\n\n            // Insert options for valueDecimals, valuePrefix, and valueSuffix\n            var series = this.series,\n                seriesTooltipOptions = series.tooltipOptions,\n                valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n                valuePrefix = seriesTooltipOptions.valuePrefix || '',\n                valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n            // Loop over the point array map and replace unformatted values with sprintf formatting markup\n            each(series.pointArrayMap || ['y'], function (key) {\n                key = '{point.' + key; // without the closing bracket\n                if (valuePrefix || valueSuffix) {\n                    pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n                }\n                pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n            });\n\n            return format(pointFormat, {\n                point: this,\n                series: this.series\n            });\n        },\n\n        /**\n         * Fire an event on the Point object.\n         * @param {String} eventType\n         * @param {Object} eventArgs Additional event arguments\n         * @param {Function} defaultFunction Default event handler\n         */\n        firePointEvent: function (eventType, eventArgs, defaultFunction) {\n            var point = this,\n                series = this.series,\n                seriesOptions = series.options;\n\n            // load event handlers on demand to save time on mouseover/out\n            if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n                this.importEvents();\n            }\n\n            // add default handler if in selection mode\n            if (eventType === 'click' && seriesOptions.allowPointSelect) {\n                defaultFunction = function (event) {\n                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n                    if (point.select) { // Could be destroyed by prior event handlers (#2911)\n                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                    }\n                };\n            }\n\n            fireEvent(this, eventType, eventArgs, defaultFunction);\n        },\n        visible: true\n    };\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            Date = H.Date,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            defined = H.defined,\n            each = H.each,\n            erase = H.erase,\n            error = H.error,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            grep = H.grep,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            isString = H.isString,\n            LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement\n            merge = H.merge,\n            pick = H.pick,\n            Point = H.Point, // @todo  add as a requirement\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            stableSort = H.stableSort,\n            SVGElement = H.SVGElement,\n            syncTimeout = H.syncTimeout,\n            useCanVG = H.useCanVG,\n            win = H.win;\n\n    /**\n     * @classDescription The base function which all other series types inherit from. The data in the series is stored\n     * in various arrays.\n     *\n     * - First, series.options.data contains all the original config options for\n     * each point whether added by options or methods like series.addPoint.\n     * - Next, series.data contains those values converted to points, but in case the series data length\n     * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n     * only contains the points that have been created on demand.\n     * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n     * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n     * compared to series.data and series.options.data. If however the series data is grouped, these can't\n     * be correlated one to one.\n     * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n     * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n     *\n     * @param {Object} chart\n     * @param {Object} options\n     */\n    H.Series = function () {}; // @todo return this object\n\n    H.Series.prototype = {\n\n        isCartesian: true,\n        type: 'line',\n        pointClass: Point,\n        sorted: true, // requires the data to be sorted\n        requireSorting: true,\n        directTouch: false,\n        axisTypes: ['xAxis', 'yAxis'],\n        colorCounter: 0,\n        parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n        init: function (chart, options) {\n            var series = this,\n                eventType,\n                events,\n                chartSeries = chart.series,\n                sortByIndex = function (a, b) {\n                    return pick(a.options.index, a._i) - pick(b.options.index, b._i);\n                };\n\n            series.chart = chart;\n            series.options = options = series.setOptions(options); // merge with plotOptions\n            series.linkedSeries = [];\n\n            // bind the axes\n            series.bindAxes();\n\n            // set some variables\n            extend(series, {\n                name: options.name,\n                state: '',\n                visible: options.visible !== false, // true by default\n                selected: options.selected === true // false by default\n            });\n\n            // special\n            if (useCanVG) {\n                options.animation = false;\n            }\n\n            // register event listeners\n            events = options.events;\n            for (eventType in events) {\n                addEvent(series, eventType, events[eventType]);\n            }\n            if (\n                (events && events.click) ||\n                (options.point && options.point.events && options.point.events.click) ||\n                options.allowPointSelect\n            ) {\n                chart.runTrackerClick = true;\n            }\n\n            series.getColor();\n            series.getSymbol();\n\n            // Set the data\n            each(series.parallelArrays, function (key) {\n                series[key + 'Data'] = [];\n            });\n            series.setData(options.data, false);\n\n            // Mark cartesian\n            if (series.isCartesian) {\n                chart.hasCartesianSeries = true;\n            }\n\n            // Register it in the chart\n            chartSeries.push(series);\n            series._i = chartSeries.length - 1;\n\n            // Sort series according to index option (#248, #1123, #2456)\n            stableSort(chartSeries, sortByIndex);\n            if (this.yAxis) {\n                stableSort(this.yAxis.series, sortByIndex);\n            }\n\n            each(chartSeries, function (series, i) {\n                series.index = i;\n                series.name = series.name || 'Series ' + (i + 1);\n            });\n\n        },\n\n        /**\n         * Set the xAxis and yAxis properties of cartesian series, and register the series\n         * in the axis.series array\n         */\n        bindAxes: function () {\n            var series = this,\n                seriesOptions = series.options,\n                chart = series.chart,\n                axisOptions;\n\n            each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n                each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n                    axisOptions = axis.options;\n\n                    // apply if the series xAxis or yAxis option mathches the number of the\n                    // axis, or if undefined, use the first axis\n                    if ((seriesOptions[AXIS] === axisOptions.index) ||\n                            (seriesOptions[AXIS] !== undefined && seriesOptions[AXIS] === axisOptions.id) ||\n                            (seriesOptions[AXIS] === undefined && axisOptions.index === 0)) {\n\n                        // register this series in the axis.series lookup\n                        axis.series.push(series);\n\n                        // set this series.xAxis or series.yAxis reference\n                        series[AXIS] = axis;\n\n                        // mark dirty for redraw\n                        axis.isDirty = true;\n                    }\n                });\n\n                // The series needs an X and an Y axis\n                if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                    error(18, true);\n                }\n\n            });\n        },\n\n        /**\n         * For simple series types like line and column, the data values are held in arrays like\n         * xData and yData for quick lookup to find extremes and more. For multidimensional series\n         * like bubble and map, this can be extended with arrays like zData and valueData by\n         * adding to the series.parallelArrays array.\n         */\n        updateParallelArrays: function (point, i) {\n            var series = point.series,\n                args = arguments,\n                fn = typeof i === 'number' ?\n                    // Insert the value in the given position\n                    function (key) {\n                        var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n                        series[key + 'Data'][i] = val;\n                    } :\n                    // Apply the method specified in i with the following arguments as arguments\n                    function (key) {\n                        Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n                    };\n\n            each(series.parallelArrays, fn);\n        },\n\n        /**\n         * Return an auto incremented x value based on the pointStart and pointInterval options.\n         * This is only used if an x value is not given for the point that calls autoIncrement.\n         */\n        autoIncrement: function () {\n\n            var options = this.options,\n                xIncrement = this.xIncrement,\n                date,\n                pointInterval,\n                pointIntervalUnit = options.pointIntervalUnit;\n\n            xIncrement = pick(xIncrement, options.pointStart, 0);\n\n            this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n\n            // Added code for pointInterval strings\n            if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {\n                date = new Date(xIncrement);\n                date = (pointIntervalUnit === 'month') ?\n                    +date[Date.hcSetMonth](date[Date.hcGetMonth]() + pointInterval) :\n                    +date[Date.hcSetFullYear](date[Date.hcGetFullYear]() + pointInterval);\n                pointInterval = date - xIncrement;\n\n            }\n\n            this.xIncrement = xIncrement + pointInterval;\n            return xIncrement;\n        },\n    \n        /**\n         * Set the series options by merging from the options tree\n         * @param {Object} itemOptions\n         */\n        setOptions: function (itemOptions) {\n            var chart = this.chart,\n                chartOptions = chart.options,\n                plotOptions = chartOptions.plotOptions,\n                userOptions = chart.userOptions || {},\n                userPlotOptions = userOptions.plotOptions || {},\n                typeOptions = plotOptions[this.type],\n                options,\n                zones;\n\n            this.userOptions = itemOptions;\n\n            // General series options take precedence over type options because otherwise, default\n            // type options like column.animation would be overwritten by the general option.\n            // But issues have been raised here (#3881), and the solution may be to distinguish\n            // between default option and userOptions like in the tooltip below.\n            options = merge(\n                typeOptions,\n                plotOptions.series,\n                itemOptions\n            );\n\n            // The tooltip options are merged between global and series specific options\n            this.tooltipOptions = merge(\n                defaultOptions.tooltip,\n                defaultOptions.plotOptions[this.type].tooltip,\n                userOptions.tooltip,\n                userPlotOptions.series && userPlotOptions.series.tooltip,\n                userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n                itemOptions.tooltip\n            );\n\n            // Delete marker object if not allowed (#1125)\n            if (typeOptions.marker === null) {\n                delete options.marker;\n            }\n\n            // Handle color zones\n            this.zoneAxis = options.zoneAxis;\n            zones = this.zones = (options.zones || []).slice();\n            if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n                zones.push({\n                    value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n                    className: 'highcharts-negative',\n                    ";
if (build.classic) { 
s += "\n                    color: options.negativeColor,\n                    fillColor: options.negativeFillColor\n                    ";
} 
s += "\n                });\n            }\n            if (zones.length) { // Push one extra zone for the rest\n                if (defined(zones[zones.length - 1].value)) {\n                    zones.push({\n                        ";
if (build.classic) { 
s += "\n                        color: this.color,\n                        fillColor: this.fillColor\n                        ";
} 
s += "\n                    });\n                }\n            }\n            return options;\n        },\n\n        getCyclic: function (prop, value, defaults) {\n            var i,\n                userOptions = this.userOptions,\n                indexName = prop + 'Index',\n                counterName = prop + 'Counter',\n                len = defaults ? defaults.length : this.chart[prop + 'Count'];\n\n            if (!value) {\n                if (defined(userOptions['_' + indexName])) { // after Series.update()\n                    i = userOptions['_' + indexName];\n                } else {\n                    userOptions['_' + indexName] = i = this.chart[counterName] % len;\n                    this.chart[counterName] += 1;\n                }\n                if (defaults) {\n                    value = defaults[i];\n                }\n            }\n            // Set the colorIndex\n            if (i !== undefined) {\n                this[indexName] = i;\n            }\n            this[prop] = value;\n        },\n\n        /**\n         * Get the series' color\n         */\n        ";
if (!build.classic) { 
s += "\n        getColor: function () {\n            this.getCyclic('color');\n        },\n\n        ";
} else { 
s += "\n        getColor: function () {\n            if (this.options.colorByPoint) {\n                this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.\n            } else {\n                this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n            }\n        },\n        ";
} 
s += "\n        /**\n         * Get the series' symbol\n         */\n        getSymbol: function () {\n            var seriesMarkerOption = this.options.marker;\n\n            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n            // don't substract radius in image symbols (#604)\n            if (/^url/.test(this.symbol)) {\n                seriesMarkerOption.radius = 0;\n            }\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n        /**\n         * Replace the series data with a new set of data\n         * @param {Object} data\n         * @param {Object} redraw\n         */\n        setData: function (data, redraw, animation, updatePoints) {\n            var series = this,\n                oldData = series.points,\n                oldDataLength = (oldData && oldData.length) || 0,\n                dataLength,\n                options = series.options,\n                chart = series.chart,\n                firstPoint = null,\n                xAxis = series.xAxis,\n                hasCategories = xAxis && !!xAxis.categories,\n                i,\n                turboThreshold = options.turboThreshold,\n                pt,\n                xData = this.xData,\n                yData = this.yData,\n                pointArrayMap = series.pointArrayMap,\n                valueCount = pointArrayMap && pointArrayMap.length;\n\n            data = data || [];\n            dataLength = data.length;\n            redraw = pick(redraw, true);\n\n            // If the point count is the same as is was, just run Point.update which is\n            // cheaper, allows animation, and keeps references to points.\n            if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n                each(data, function (point, i) {\n                    // .update doesn't exist on a linked, hidden series (#3709)\n                    if (oldData[i].update && point !== options.data[i]) {\n                        oldData[i].update(point, false, null, false);\n                    }\n                });\n\n            } else {\n\n                // Reset properties\n                series.xIncrement = null;\n\n                series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n                // Update parallel arrays\n                each(this.parallelArrays, function (key) {\n                    series[key + 'Data'].length = 0;\n                });\n\n                // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n                // first value is tested, and we assume that all the rest are defined the same\n                // way. Although the 'for' loops are similar, they are repeated inside each\n                // if-else conditional for max performance.\n                if (turboThreshold && dataLength > turboThreshold) {\n\n                    // find the first non-null point\n                    i = 0;\n                    while (firstPoint === null && i < dataLength) {\n                        firstPoint = data[i];\n                        i++;\n                    }\n\n\n                    if (isNumber(firstPoint)) { // assume all points are numbers\n                        var x = pick(options.pointStart, 0),\n                            pointInterval = pick(options.pointInterval, 1);\n\n                        for (i = 0; i < dataLength; i++) {\n                            xData[i] = x;\n                            yData[i] = data[i];\n                            x += pointInterval;\n                        }\n                        series.xIncrement = x;\n                    } else if (isArray(firstPoint)) { // assume all points are arrays\n                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] = pt.slice(1, valueCount + 1);\n                            }\n                        } else { // [x, y]\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] = pt[1];\n                            }\n                        }\n                    } else {\n                        error(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n                    }\n                } else {\n                    for (i = 0; i < dataLength; i++) {\n                        if (data[i] !== undefined) { // stray commas in oldIE\n                            pt = { series: series };\n                            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n                            series.updateParallelArrays(pt, i);\n                            if (hasCategories && defined(pt.name)) { // #4401\n                                xAxis.names[pt.x] = pt.name; // #2046\n                            }\n                        }\n                    }\n                }\n\n                // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n                if (isString(yData[0])) {\n                    error(14, true);\n                }\n\n                series.data = [];\n                series.options.data = data;\n                //series.zData = zData;\n\n                // destroy old points\n                i = oldDataLength;\n                while (i--) {\n                    if (oldData[i] && oldData[i].destroy) {\n                        oldData[i].destroy();\n                    }\n                }\n\n                // reset minRange (#878)\n                if (xAxis) {\n                    xAxis.minRange = xAxis.userMinRange;\n                }\n\n                // redraw\n                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n                animation = false;\n            }\n\n            // Typically for pie series, points need to be processed and generated\n            // prior to rendering the legend\n            if (options.legendType === 'point') { // docs: legendType now supported on more series types (at least column and pie)\n                this.processData();\n                this.generatePoints();\n            }\n\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        },\n\n        /**\n         * Process the data by cropping away unused data points if the series is longer\n         * than the crop threshold. This saves computing time for lage series.\n         */\n        processData: function (force) {\n            var series = this,\n                processedXData = series.xData, // copied during slice operation below\n                processedYData = series.yData,\n                dataLength = processedXData.length,\n                croppedData,\n                cropStart = 0,\n                cropped,\n                distance,\n                closestPointRange,\n                xAxis = series.xAxis,\n                i, // loop variable\n                options = series.options,\n                cropThreshold = options.cropThreshold,\n                getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599\n                isCartesian = series.isCartesian,\n                xExtremes,\n                val2lin = xAxis && xAxis.val2lin,\n                isLog = xAxis && xAxis.isLog,\n                min,\n                max;\n\n            // If the series data or axes haven't changed, don't go through this. Return false to pass\n            // the message on to override methods like in data grouping.\n            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n                return false;\n            }\n\n            if (xAxis) {\n                xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n                min = xExtremes.min;\n                max = xExtremes.max;\n            }\n\n            // optionally filter out points outside the plot area\n            if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n\n                // it's outside current extremes\n                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n                    processedXData = [];\n                    processedYData = [];\n\n                // only crop if it's actually spilling out\n                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n                    croppedData = this.cropData(series.xData, series.yData, min, max);\n                    processedXData = croppedData.xData;\n                    processedYData = croppedData.yData;\n                    cropStart = croppedData.start;\n                    cropped = true;\n                }\n            }\n\n\n            // Find the closest distance between processed points\n            i = processedXData.length || 1;\n            while (--i) {\n                distance = isLog ?\n                    val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                    processedXData[i] - processedXData[i - 1];\n\n                if (distance > 0 && (closestPointRange === undefined || distance < closestPointRange)) {\n                    closestPointRange = distance;\n\n                // Unsorted data is not supported by the line tooltip, as well as data grouping and\n                // navigation in Stock charts (#725) and width calculation of columns (#1900)\n                } else if (distance < 0 && series.requireSorting) {\n                    error(15);\n                }\n            }\n\n            // Record the properties\n            series.cropped = cropped; // undefined or true\n            series.cropStart = cropStart;\n            series.processedXData = processedXData;\n            series.processedYData = processedYData;\n\n            series.closestPointRange = closestPointRange;\n\n        },\n\n        /**\n         * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n         * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n         */\n        cropData: function (xData, yData, min, max) {\n            var dataLength = xData.length,\n                cropStart = 0,\n                cropEnd = dataLength,\n                cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n                i,\n                j;\n\n            // iterate up to find slice start\n            for (i = 0; i < dataLength; i++) {\n                if (xData[i] >= min) {\n                    cropStart = Math.max(0, i - cropShoulder);\n                    break;\n                }\n            }\n\n            // proceed to find slice end\n            for (j = i; j < dataLength; j++) {\n                if (xData[j] > max) {\n                    cropEnd = j + cropShoulder;\n                    break;\n                }\n            }\n\n            return {\n                xData: xData.slice(cropStart, cropEnd),\n                yData: yData.slice(cropStart, cropEnd),\n                start: cropStart,\n                end: cropEnd\n            };\n        },\n\n\n        /**\n         * Generate the data point after the data has been processed by cropping away\n         * unused points and optionally grouped in Highcharts Stock.\n         */\n        generatePoints: function () {\n            var series = this,\n                options = series.options,\n                dataOptions = options.data,\n                data = series.data,\n                dataLength,\n                processedXData = series.processedXData,\n                processedYData = series.processedYData,\n                pointClass = series.pointClass,\n                processedDataLength = processedXData.length,\n                cropStart = series.cropStart || 0,\n                cursor,\n                hasGroupedData = series.hasGroupedData,\n                point,\n                points = [],\n                i;\n\n            if (!data && !hasGroupedData) {\n                var arr = [];\n                arr.length = dataOptions.length;\n                data = series.data = arr;\n            }\n\n            for (i = 0; i < processedDataLength; i++) {\n                cursor = cropStart + i;\n                if (!hasGroupedData) {\n                    if (data[cursor]) {\n                        point = data[cursor];\n                    } else if (dataOptions[cursor] !== undefined) { // #970\n                        data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n                    }\n                    points[i] = point;\n                } else {\n                    // splat the y data in case of ohlc data array\n                    points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n                }\n                points[i].index = cursor; // For faster access in Point.update\n            }\n\n            // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n            // swithching view from non-grouped data to grouped data (#637)\n            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n                for (i = 0; i < dataLength; i++) {\n                    if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n                        i += processedDataLength;\n                    }\n                    if (data[i]) {\n                        data[i].destroyElements();\n                        data[i].plotX = undefined; // #1003\n                    }\n                }\n            }\n\n            series.data = data;\n            series.points = points;\n        },\n\n        /**\n         * Calculate Y extremes for visible data\n         */\n        getExtremes: function (yData) {\n            var xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                xData = this.processedXData,\n                yDataLength,\n                activeYData = [],\n                activeCounter = 0,\n                xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n                xMin = xExtremes.min,\n                xMax = xExtremes.max,\n                validValue,\n                withinRange,\n                x,\n                y,\n                i,\n                j;\n\n            yData = yData || this.stackedYData || this.processedYData;\n            yDataLength = yData.length;\n\n            for (i = 0; i < yDataLength; i++) {\n\n                x = xData[i];\n                y = yData[i];\n\n                // For points within the visible range, including the first point outside the\n                // visible range, consider y extremes\n                validValue = y !== null && y !== undefined && (!yAxis.isLog || (y.length || y > 0));\n                withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||\n                    ((xData[i + 1] || x) >= xMin &&    (xData[i - 1] || x) <= xMax);\n\n                if (validValue && withinRange) {\n\n                    j = y.length;\n                    if (j) { // array, like ohlc or range data\n                        while (j--) {\n                            if (y[j] !== null) {\n                                activeYData[activeCounter++] = y[j];\n                            }\n                        }\n                    } else {\n                        activeYData[activeCounter++] = y;\n                    }\n                }\n            }\n            this.dataMin = arrayMin(activeYData);\n            this.dataMax = arrayMax(activeYData);\n        },\n\n        /**\n         * Translate data points from raw data values to chart specific positioning data\n         * needed later in drawPoints, drawGraph and drawTracker.\n         */\n        translate: function () {\n            if (!this.processedXData) { // hidden series\n                this.processData();\n            }\n            this.generatePoints();\n            var series = this,\n                options = series.options,\n                stacking = options.stacking,\n                xAxis = series.xAxis,\n                categories = xAxis.categories,\n                yAxis = series.yAxis,\n                points = series.points,\n                dataLength = points.length,\n                hasModifyValue = !!series.modifyValue,\n                i,\n                pointPlacement = options.pointPlacement,\n                dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n                threshold = options.threshold,\n                stackThreshold = options.startFromThreshold ? threshold : 0,\n                plotX,\n                plotY,\n                lastPlotX,\n                stackIndicator,\n                closestPointRangePx = Number.MAX_VALUE;\n\n            // Translate each point\n            for (i = 0; i < dataLength; i++) {\n                var point = points[i],\n                    xValue = point.x,\n                    yValue = point.y,\n                    yBottom = point.low,\n                    stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],\n                    pointStack,\n                    stackValues;\n\n                // Discard disallowed y values for log axes (#3434)\n                if (yAxis.isLog && yValue !== null && yValue <= 0) {\n                    point.y = yValue = null;\n                    error(10);\n                }\n\n                // Get the plotX translation\n                point.plotX = plotX = Math.min(Math.max(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923\n\n\n                // Calculate the bottom y value for stacked series\n                if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {\n                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n                    pointStack = stack[xValue];\n                    stackValues = pointStack.points[stackIndicator.key];\n                    yBottom = stackValues[0];\n                    yValue = stackValues[1];\n\n                    if (yBottom === stackThreshold) {\n                        yBottom = pick(threshold, yAxis.min);\n                    }\n                    if (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n                        yBottom = null;\n                    }\n\n                    point.total = point.stackTotal = pointStack.total;\n                    point.percentage = pointStack.total && (point.y / pointStack.total * 100);\n                    point.stackY = yValue;\n\n                    // Place the stack label\n                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n                }\n\n                // Set translated yBottom or remove it\n                point.yBottom = defined(yBottom) ?\n                    yAxis.translate(yBottom, 0, 1, 0, 1) :\n                    null;\n\n                // general hook, used for Highstock compare mode\n                if (hasModifyValue) {\n                    yValue = series.modifyValue(yValue, point);\n                }\n\n                // Set the the plotY value, reset it for redraws\n                point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n                    Math.min(Math.max(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n                    undefined;\n                point.isInside = plotY !== undefined && plotY >= 0 && plotY <= yAxis.len && // #3519\n                    plotX >= 0 && plotX <= xAxis.len;\n\n\n                // Set client related positions for mouse tracking\n                point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514\n\n                point.negative = point.y < (threshold || 0);\n\n                // some API data\n                point.category = categories && categories[point.x] !== undefined ?\n                    categories[point.x] : point.x;\n\n                // Determine auto enabling of markers (#3635)\n                if (i) {\n                    closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));\n                }\n                lastPlotX = plotX;\n\n            }\n            series.closestPointRangePx = closestPointRangePx;\n        },\n\n        /**\n         * Return the series points with null points filtered out\n         */\n        getValidPoints: function () {\n            return grep(this.points, function (point) {\n                return !point.isNull;\n            });\n        },\n\n        /**\n         * Set the clipping for the series. For animated series it is called twice, first to initiate\n         * animating the clip then the second time without the animation to set the final clip.\n         */\n        setClip: function (animation) {\n            var chart = this.chart,\n                options = this.options,\n                renderer = chart.renderer,\n                inverted = chart.inverted,\n                seriesClipBox = this.clipBox,\n                clipBox = seriesClipBox || chart.clipBox,\n                sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526\n                clipRect = chart[sharedClipKey],\n                markerClipRect = chart[sharedClipKey + 'm'];\n\n            // If a clipping rectangle with the same properties is currently present in the chart, use that.\n            if (!clipRect) {\n\n                // When animation is set, prepare the initial positions\n                if (animation) {\n                    clipBox.width = 0;\n\n                    chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n                        -99, // include the width of the first marker\n                        inverted ? -chart.plotLeft : -chart.plotTop,\n                        99,\n                        inverted ? chart.chartWidth : chart.chartHeight\n                    );\n                }\n                chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n\n            }\n            if (animation) {\n                clipRect.count += 1;\n            }\n\n            if (options.clip !== false) {\n                this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n                this.markerGroup.clip(markerClipRect);\n                this.sharedClipKey = sharedClipKey;\n            }\n\n            // Remove the shared clipping rectangle when all series are shown\n            if (!animation) {\n                clipRect.count -= 1;\n                if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {\n                    if (!seriesClipBox) {\n                        chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                    }\n                    if (chart[sharedClipKey + 'm']) {\n                        chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n                    }\n                }\n            }\n        },\n\n        /**\n         * Animate in the series\n         */\n        animate: function (init) {\n            var series = this,\n                chart = series.chart,\n                clipRect,\n                animation = series.options.animation,\n                sharedClipKey;\n\n            // Animation option is set to true\n            if (animation && !isObject(animation)) {\n                animation = defaultPlotOptions[series.type].animation;\n            }\n\n            // Initialize the animation. Set up the clipping rectangle.\n            if (init) {\n\n                series.setClip(animation);\n\n            // Run the animation\n            } else {\n                sharedClipKey = this.sharedClipKey;\n                clipRect = chart[sharedClipKey];\n                if (clipRect) {\n                    clipRect.animate({\n                        width: chart.plotSizeX\n                    }, animation);\n                }\n                if (chart[sharedClipKey + 'm']) {\n                    chart[sharedClipKey + 'm'].animate({\n                        width: chart.plotSizeX + 99\n                    }, animation);\n                }\n\n                // Delete this function to allow it only once\n                series.animate = null;\n\n            }\n        },\n\n        /**\n         * This runs after animation to land on the final plot clipping\n         */\n        afterAnimate: function () {\n            this.setClip();\n            fireEvent(this, 'afterAnimate');\n        },\n\n        /**\n         * Draw the markers\n         */\n        drawPoints: function () {\n            var series = this,\n                points = series.points,\n                chart = series.chart,\n                plotX,\n                plotY,\n                i,\n                point,\n                radius,\n                symbol,\n                isImage,\n                graphic,\n                options = series.options,\n                seriesMarkerOptions = options.marker,\n                pointMarkerOptions,\n                hasPointMarker,\n                enabled,\n                isInside,\n                markerGroup = series.markerGroup,\n                xAxis = series.xAxis,\n                globallyEnabled = pick(\n                    seriesMarkerOptions.enabled,\n                    xAxis.isRadial,\n                    series.closestPointRangePx > 2 * seriesMarkerOptions.radius\n                );\n\n            if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n                i = points.length;\n                while (i--) {\n                    point = points[i];\n                    plotX = Math.floor(point.plotX); // #1843\n                    plotY = point.plotY;\n                    graphic = point.graphic;\n                    pointMarkerOptions = point.marker || {};\n                    hasPointMarker = !!point.marker;\n                    enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;\n                    isInside = point.isInside;\n\n                    // Only draw the point if y is defined\n                    if (enabled && plotY !== undefined && !isNaN(plotY) && point.y !== null) {\n\n                        // Shortcuts\n                        radius = seriesMarkerOptions.radius;\n                        symbol = pick(pointMarkerOptions.symbol, series.symbol);\n                        isImage = symbol.indexOf('url') === 0;\n\n                        if (graphic) { // update\n                            graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n                                .animate(extend({\n                                    x: plotX - radius,\n                                    y: plotY - radius\n                                }, graphic.symbolName ? { // don't apply to image symbols #507\n                                    width: 2 * radius,\n                                    height: 2 * radius\n                                } : {}));\n                        } else if (isInside && (radius > 0 || isImage)) {\n                            point.graphic = graphic = chart.renderer.symbol(\n                                symbol,\n                                plotX - radius,\n                                plotY - radius,\n                                2 * radius,\n                                2 * radius,\n                                hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n                            )\n                            .addClass('highcharts-point' + (point.selected ? ' highcharts-point-select' : ''))\n                            .attr({ r: radius })\n                            .add(markerGroup);\n\n                            ";
if (build.classic) { 
s += "\n                            // Presentational attributes\n                            graphic.attr(series.pointAttribs(point, point.selected && 'select'));\n                            ";
} 
s += "\n                        }\n\n                    } else if (graphic) {\n                        point.graphic = graphic.destroy(); // #1269\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Get presentational attributes for marker-based series (line, spline, scatter, bubble, mappoint...)\n         */\n        pointAttribs: function (point, state) {\n            var seriesMarkerOptions = this.options.marker,\n                seriesStateOptions,\n                pointMarkerOptions = (point && point.options && point.options.marker) || {},\n                pointStateOptions,\n                strokeWidth = seriesMarkerOptions.lineWidth,\n                color = this.color,\n                pointColorOption = point && point.options.color,\n                pointColor = point && point.color,\n                zoneColor,\n                fill,\n                stroke,\n                zone;\n\n            if (point && this.zones.length) {\n                zone = point.getZone();\n                if (zone && zone.color) {\n                    zoneColor = zone.color;\n                }\n            }\n\n            color = pointColorOption || zoneColor || pointColor || color;\n            fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;\n            stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;\n\n            // Handle hover and select states\n            if (state) {\n                seriesStateOptions = seriesMarkerOptions.states[state];\n                pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};\n                strokeWidth = seriesStateOptions.lineWidth || strokeWidth + seriesStateOptions.lineWidthPlus;\n                fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;\n                stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;\n            }\n        \n            return {\n                'stroke': stroke,\n                'stroke-width': strokeWidth,\n                'fill': fill\n            };\n        },\n\n        /**\n         * Clear DOM objects and free up memory\n         */\n        destroy: function () {\n            var series = this,\n                chart = series.chart,\n                issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n                destroy,\n                i,\n                data = series.data || [],\n                point,\n                prop,\n                axis;\n\n            // add event hook\n            fireEvent(series, 'destroy');\n\n            // remove all events\n            removeEvent(series);\n\n            // erase from axes\n            each(series.axisTypes || [], function (AXIS) {\n                axis = series[AXIS];\n                if (axis) {\n                    erase(axis.series, series);\n                    axis.isDirty = axis.forceRedraw = true;\n                }\n            });\n\n            // remove legend items\n            if (series.legendItem) {\n                series.chart.legend.destroyItem(series);\n            }\n\n            // destroy all points with their elements\n            i = data.length;\n            while (i--) {\n                point = data[i];\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            }\n            series.points = null;\n\n            // Clear the animation timeout if we are destroying the series during initial animation\n            clearTimeout(series.animationTimeout);\n\n            // Destroy all SVGElements associated to the series\n            for (prop in series) {\n                if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying\n\n                    // issue 134 workaround\n                    destroy = issue134 && prop === 'group' ?\n                        'hide' :\n                        'destroy';\n\n                    series[prop][destroy]();\n                }\n            }\n\n            // remove from hoverSeries\n            if (chart.hoverSeries === series) {\n                chart.hoverSeries = null;\n            }\n            erase(chart.series, series);\n\n            // clear all members\n            for (prop in series) {\n                delete series[prop];\n            }\n        },\n\n        /**\n         * Get the graph path\n         */\n        getGraphPath: function (points, nullsAsZeroes, connectCliffs) {\n            var series = this,\n                options = series.options,\n                step = options.step,\n                graphPath = [],\n                gap;\n\n            points = points || series.points;\n\n            // Build the line\n            each(points, function (point, i) {\n\n                var plotX = point.plotX,\n                    plotY = point.plotY,\n                    lastPoint = points[i - 1],                \n                    pathToPoint; // the path to this point from the previous\n\n                if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {\n                    gap = true; // ... and continue\n                }\n\n                // Line series, nullsAsZeroes is not handled\n                if (point.isNull && !defined(nullsAsZeroes)) {\n                    gap = !options.connectNulls;\n\n                // Area series, nullsAsZeroes is set\n                } else if (point.isNull && !nullsAsZeroes) {\n                    gap = true;\n\n                } else {\n\n                    if (i === 0 || gap) {\n                        pathToPoint = ['M', point.plotX, point.plotY];\n                \n                    } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n                    \n                        pathToPoint = series.getPointSpline(points, point, i);\n\n                    } else if (step) {\n\n                        if (step === 'right') {\n                            pathToPoint = [\n                                'L',\n                                lastPoint.plotX,\n                                plotY\n                            ];\n                        \n                        } else if (step === 'center') {\n                            pathToPoint = [\n                                'L',\n                                (lastPoint.plotX + plotX) / 2,\n                                lastPoint.plotY,\n                                'L',\n                                (lastPoint.plotX + plotX) / 2,\n                                plotY\n                            ];\n                        \n                        } else {\n                            pathToPoint = [\n                                'L',\n                                plotX,\n                                lastPoint.plotY\n                            ];\n                        }\n                        pathToPoint.push('L', plotX, plotY);\n\n                    } else {\n                        // normal line to next point\n                        pathToPoint = [\n                            'L',\n                            plotX,\n                            plotY\n                        ];\n                    }\n\n\n                    graphPath.push.apply(graphPath, pathToPoint);\n                    gap = false;\n                }\n            });\n\n            series.graphPath = graphPath;\n\n            return graphPath;\n\n        },\n\n        /**\n         * Draw the actual graph\n         */\n        drawGraph: function () {\n            var series = this,\n                options = this.options,\n                props = [['graph', options.lineColor || this.color, options.dashStyle]],\n                graphPath = (this.gappedPath || this.getGraphPath).call(this),\n                zones = this.zones;\n\n            each(zones, function (threshold, i) {\n                props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);\n            });\n\n            // Draw the graph\n            each(props, function (prop, i) {\n                var graphKey = prop[0],\n                    graph = series[graphKey],\n                    attribs;\n\n                if (graph) {\n                    graph.animate({ d: graphPath });\n\n                } else if (graphPath.length) { // #1487\n                \n                    series[graphKey] = series.chart.renderer.path(graphPath)\n                        .addClass('highcharts-graph ' + (prop[1] || ''))\n                        .attr({ zIndex: 1 }) // #1069\n                        .add(series.group);\n\n                    ";
if (build.classic) { 
s += "\n                    attribs = {\n                        'stroke': prop[2],\n                        'stroke-width': options.lineWidth,\n                        'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph\n                    };\n\n                    if (prop[3]) {\n                        attribs.dashstyle = prop[3];\n                    } else if (options.linecap !== 'square') {\n                        attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n                    }\n\n                    series[graphKey]\n                        .attr(attribs)\n                        .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n                    ";
} 
s += "\n                }\n            });\n        },\n\n        /**\n         * Clip the graphs into the positive and negative coloured graphs\n         */\n        applyZones: function () {\n            var series = this,\n                chart = this.chart,\n                renderer = chart.renderer,\n                zones = this.zones,\n                translatedFrom,\n                translatedTo,\n                clips = this.clips || [],\n                clipAttr,\n                graph = this.graph,\n                area = this.area,\n                chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n                axis = this[(this.zoneAxis || 'y') + 'Axis'],\n                extremes,\n                reversed = axis.reversed,\n                inverted = chart.inverted,\n                horiz = axis.horiz,\n                pxRange,\n                pxPosMin,\n                pxPosMax,\n                ignoreZones = false;\n\n            if (zones.length && (graph || area) && axis.min !== undefined) {\n                // The use of the Color Threshold assumes there are no gaps\n                // so it is safe to hide the original graph and area\n                if (graph) {\n                    graph.hide();\n                }\n                if (area) {\n                    area.hide();\n                }\n\n                // Create the clips\n                extremes = axis.getExtremes();\n                each(zones, function (threshold, i) {\n\n                    translatedFrom = reversed ?\n                        (horiz ? chart.plotWidth : 0) :\n                        (horiz ? 0 : axis.toPixels(extremes.min));\n                    translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n                    translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n                \n                    if (ignoreZones) {\n                        translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                    }\n\n                    pxRange = Math.abs(translatedFrom - translatedTo);\n                    pxPosMin = Math.min(translatedFrom, translatedTo);\n                    pxPosMax = Math.max(translatedFrom, translatedTo);\n                    if (axis.isXAxis) {\n                        clipAttr = {\n                            x: inverted ? pxPosMax : pxPosMin,\n                            y: 0,\n                            width: pxRange,\n                            height: chartSizeMax\n                        };\n                        if (!horiz) {\n                            clipAttr.x = chart.plotHeight - clipAttr.x;\n                        }\n                    } else {\n                        clipAttr = {\n                            x: 0,\n                            y: inverted ? pxPosMax : pxPosMin,\n                            width: chartSizeMax,\n                            height: pxRange\n                        };\n                        if (horiz) {\n                            clipAttr.y = chart.plotWidth - clipAttr.y;\n                        }\n                    }\n\n                    /// VML SUPPPORT\n                    if (chart.inverted && renderer.isVML) {\n                        if (axis.isXAxis) {\n                            clipAttr = {\n                                x: 0,\n                                y: reversed ? pxPosMin : pxPosMax,\n                                height: clipAttr.width,\n                                width: chart.chartWidth\n                            };\n                        } else {\n                            clipAttr = {\n                                x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n                                y: 0,\n                                width: clipAttr.height,\n                                height: chart.chartHeight\n                            };\n                        }\n                    }\n                    /// END OF VML SUPPORT\n\n                    if (clips[i]) {\n                        clips[i].animate(clipAttr);\n                    } else {\n                        clips[i] = renderer.clipRect(clipAttr);\n\n                        if (graph) {\n                            series['zone-graph-' + i].clip(clips[i]);\n                        }\n\n                        if (area) {\n                            series['zone-area-' + i].clip(clips[i]);\n                        }\n                    }\n                    // if this zone extends out of the axis, ignore the others\n                    ignoreZones = threshold.value > extremes.max;\n                });\n                this.clips = clips;\n            }\n        },\n\n        /**\n         * Initialize and perform group inversion on series.group and series.markerGroup\n         */\n        invertGroups: function () {\n            var series = this,\n                chart = series.chart;\n\n            // Pie, go away (#1736)\n            if (!series.xAxis) {\n                return;\n            }\n\n            // A fixed size is needed for inversion to work\n            function setInvert() {\n                var size = {\n                    width: series.yAxis.len,\n                    height: series.xAxis.len\n                };\n\n                each(['group', 'markerGroup'], function (groupName) {\n                    if (series[groupName]) {\n                        series[groupName].attr(size).invert();\n                    }\n                });\n            }\n\n            addEvent(chart, 'resize', setInvert); // do it on resize\n            addEvent(series, 'destroy', function () {\n                removeEvent(chart, 'resize', setInvert);\n            });\n\n            // Do it now\n            setInvert(); // do it now\n\n            // On subsequent render and redraw, just do setInvert without setting up events again\n            series.invertGroups = setInvert;\n        },\n\n        /**\n         * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n         * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n         */\n        plotGroup: function (prop, name, visibility, zIndex, parent) {\n            var group = this[prop],\n                isNew = !group;\n\n            // Generate it on first call\n            if (isNew) {\n                this[prop] = group = this.chart.renderer.g(name)\n                    .attr({\n                        zIndex: zIndex || 0.1 // IE8 needs this\n                    })\n                    .add(parent);\n\n                group.addClass('highcharts-series-' + this.index + ' highcharts-' + this.type + '-series highcharts-color-' + this.colorIndex +\n                    ' ' + (this.options.className || '')); // docs: className\n            }\n\n            // Place it on first and subsequent (redraw) calls\n            group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](this.getPlotBox());\n            return group;\n        },\n\n        /**\n         * Get the translation and scale for the plot area of this series\n         */\n        getPlotBox: function () {\n            var chart = this.chart,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis;\n\n            // Swap axes for inverted (#2339)\n            if (chart.inverted) {\n                xAxis = yAxis;\n                yAxis = this.xAxis;\n            }\n            return {\n                translateX: xAxis ? xAxis.left : chart.plotLeft,\n                translateY: yAxis ? yAxis.top : chart.plotTop,\n                scaleX: 1, // #1623\n                scaleY: 1\n            };\n        },\n\n        /**\n         * Render the graph and markers\n         */\n        render: function () {\n            var series = this,\n                chart = series.chart,\n                group,\n                options = series.options,\n                animation = options.animation,\n                // Animation doesn't work in IE8 quirks when the group div is hidden,\n                // and looks bad in other oldIE\n                animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,\n                visibility = series.visible ? 'inherit' : 'hidden', // #2597\n                zIndex = options.zIndex,\n                hasRendered = series.hasRendered,\n                chartSeriesGroup = chart.seriesGroup;\n\n            // the group\n            group = series.plotGroup(\n                'group',\n                'series',\n                visibility,\n                zIndex,\n                chartSeriesGroup\n            );\n\n            series.markerGroup = series.plotGroup(\n                'markerGroup',\n                'markers',\n                visibility,\n                zIndex,\n                chartSeriesGroup\n            );\n\n            // initiate the animation\n            if (animDuration) {\n                series.animate(true);\n            }\n\n            ";
if (build.classic) { 
s += "\n            // cache attributes for shapes\n            //series.getAttribs();\n            ";
} 
s += "\n\n            // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n            group.inverted = series.isCartesian ? chart.inverted : false;\n\n            // draw the graph if any\n            if (series.drawGraph) {\n                series.drawGraph();\n                series.applyZones();\n            }\n\n            each(series.points, function (point) {\n                if (point.redraw) {\n                    point.redraw();\n                }\n            });\n\n            // draw the data labels (inn pies they go before the points)\n            if (series.drawDataLabels) {\n                series.drawDataLabels();\n            }\n\n            // draw the points\n            if (series.visible) {\n                series.drawPoints();\n            }\n\n\n            // draw the mouse tracking area\n            if (series.drawTracker && series.options.enableMouseTracking !== false) {\n                series.drawTracker();\n            }\n\n            // Handle inverted series and tracker groups\n            if (chart.inverted) {\n                series.invertGroups();\n            }\n\n            // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n                group.clip(chart.clipRect);\n            }\n\n            // Run the animation\n            if (animDuration) {\n                series.animate();\n            }\n\n            // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n            // which should be available to the user).\n            if (!hasRendered) {\n                series.animationTimeout = syncTimeout(function () {\n                    series.afterAnimate();\n                }, animDuration);\n            }\n\n            series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n            // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n            series.hasRendered = true;\n        },\n\n        /**\n         * Redraw the series after an update in the axes.\n         */\n        redraw: function () {\n            var series = this,\n                chart = series.chart,\n                wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after\n                wasDirty = series.isDirty,\n                group = series.group,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis;\n\n            // reposition on resize\n            if (group) {\n                if (chart.inverted) {\n                    group.attr({\n                        width: chart.plotWidth,\n                        height: chart.plotHeight\n                    });\n                }\n\n                group.animate({\n                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                    translateY: pick(yAxis && yAxis.top, chart.plotTop)\n                });\n            }\n\n            series.translate();\n            series.render();\n            if (wasDirtyData) {\n                fireEvent(series, 'updatedData');\n            }\n            if (wasDirty || wasDirtyData) {            // #3945 recalculate the kdtree when dirty\n                delete this.kdTree; // #3868 recalculate the kdtree with dirty data\n            }\n        },\n\n        /**\n         * KD Tree && PointSearching Implementation\n         */\n\n        kdDimensions: 1,\n        kdAxisArray: ['clientX', 'plotY'],\n\n        searchPoint: function (e, compareX) {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                inverted = series.chart.inverted;\n\n            return this.searchKDTree({\n                clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n                plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n            }, compareX);\n        },\n\n        buildKDTree: function () {\n            var series = this,\n                dimensions = series.kdDimensions;\n\n            // Internal function\n            function _kdtree(points, depth, dimensions) {\n                var axis, median, length = points && points.length;\n\n                if (length) {\n\n                    // alternate between the axis\n                    axis = series.kdAxisArray[depth % dimensions];\n\n                    // sort point array\n                    points.sort(function (a, b) {\n                        return a[axis] - b[axis];\n                    });\n\n                    median = Math.floor(length / 2);\n\n                    // build and return nod\n                    return {\n                        point: points[median],\n                        left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n                        right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n                    };\n\n                }\n            }\n\n            // Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n            function startRecursive() {\n                var points = grep(series.points || [], function (point) { // #4390\n                    return point.y !== null;\n                });\n\n                series.kdTree = _kdtree(points, dimensions, dimensions);\n            }\n            delete series.kdTree;\n\n            // For testing tooltips, don't build async\n            syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n        },\n\n        searchKDTree: function (point, compareX) {\n            var series = this,\n                kdX = this.kdAxisArray[0],\n                kdY = this.kdAxisArray[1],\n                kdComparer = compareX ? 'distX' : 'dist';\n\n            // Set the one and two dimensional distance on the point object\n            function setDistance(p1, p2) {\n                var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n                    y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n                    r = (x || 0) + (y || 0);\n\n                p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n                p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n            }\n            function _search(search, tree, depth, dimensions) {\n                var point = tree.point,\n                    axis = series.kdAxisArray[depth % dimensions],\n                    tdist,\n                    sideA,\n                    sideB,\n                    ret = point,\n                    nPoint1,\n                    nPoint2;\n\n                setDistance(search, point);\n\n                // Pick side based on distance to splitting point\n                tdist = search[axis] - point[axis];\n                sideA = tdist < 0 ? 'left' : 'right';\n                sideB = tdist < 0 ? 'right' : 'left';\n\n                // End of tree\n                if (tree[sideA]) {\n                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                    ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n                }\n                if (tree[sideB]) {\n                    // compare distance to current best to splitting point to decide wether to check side B or not\n                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                        nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n                        ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);\n                    }\n                }\n\n                return ret;\n            }\n\n            if (!this.kdTree) {\n                this.buildKDTree();\n            }\n\n            if (this.kdTree) {\n                return _search(point,\n                    this.kdTree, this.kdDimensions, this.kdDimensions);\n            }\n        }\n\n    }; // end Series prototype\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            animate = H.animate,\n            Axis = H.Axis,\n            Chart = H.Chart,\n            createElement = H.createElement,\n            css = H.css,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isObject = H.isObject,\n            merge = H.merge,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            setAnimation = H.setAnimation,\n            splat = H.splat;\n        \n    // Extend the Chart prototype for dynamic methods\n    extend(Chart.prototype, {\n\n        /**\n         * Add a series dynamically after  time\n         *\n         * @param {Object} options The config options\n         * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         *\n         * @return {Object} series The newly created series object\n         */\n        addSeries: function (options, redraw, animation) {\n            var series,\n                chart = this;\n\n            if (options) {\n                redraw = pick(redraw, true); // defaults to true\n\n                fireEvent(chart, 'addSeries', { options: options }, function () {\n                    series = chart.initSeries(options);\n\n                    chart.isDirtyLegend = true; // the series array is out of sync with the display\n                    chart.linkSeries();\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                });\n            }\n\n            return series;\n        },\n\n        /**\n         * Add an axis to the chart\n         * @param {Object} options The axis option\n         * @param {Boolean} isX Whether it is an X axis or a value axis\n         */\n        addAxis: function (options, isX, redraw, animation) {\n            var key = isX ? 'xAxis' : 'yAxis',\n                chartOptions = this.options;\n\n            new Axis(this, merge(options, { // eslint-disable-line no-new\n                index: this[key].length,\n                isX: isX\n            }));\n\n            // Push the new axis options to the chart options\n            chartOptions[key] = splat(chartOptions[key] || {});\n            chartOptions[key].push(options);\n\n            if (pick(redraw, true)) {\n                this.redraw(animation);\n            }\n        },\n\n        /**\n         * Dim the chart and show a loading text or symbol\n         * @param {String} str An optional text to show in the loading label instead of the default one\n         */\n        showLoading: function (str) {\n            var chart = this,\n                options = chart.options,\n                loadingDiv = chart.loadingDiv,\n                loadingOptions = options.loading,\n                setLoadingSize = function () {\n                    if (loadingDiv) {\n                        css(loadingDiv, {\n                            left: chart.plotLeft + 'px',\n                            top: chart.plotTop + 'px',\n                            width: chart.plotWidth + 'px',\n                            height: chart.plotHeight + 'px'\n                        });\n                    }\n                },\n                style,\n                labelStyle;\n\n            ";
if (build.classic) { 
s += "\n            style = extend(loadingOptions.style, {\n                zIndex: 10,\n                display: 'none'\n            });\n            labelStyle = loadingOptions.labelStyle;\n            ";
} 
s += "\n\n            // create the layer at the first call\n            if (!loadingDiv) {\n                chart.loadingDiv = loadingDiv = createElement('div', {\n                    className: 'highcharts-loading highcharts-loading-hidden'\n                }, style, chart.container);\n\n                chart.loadingSpan = createElement(\n                    'span',\n                    { className: 'highcharts-loading-inner' },\n                    labelStyle,\n                    loadingDiv\n                );\n                addEvent(chart, 'redraw', setLoadingSize); // #1080\n            }\n            setTimeout(function () {\n                loadingDiv.className = 'highcharts-loading';\n            });\n\n            // update text\n            chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n            ";
if (build.classic) { 
s += "\n            // show it\n            if (!chart.loadingShown) {\n                css(loadingDiv, {\n                    opacity: 0,\n                    display: ''\n                });\n                animate(loadingDiv, {\n                    opacity: style.opacity || 0.5\n                }, {\n                    duration: loadingOptions.showDuration || 0\n                });\n            }\n            ";
} 
s += "\n\n            chart.loadingShown = true;\n            setLoadingSize();\n        },\n\n        /**\n         * Hide the loading layer\n         */\n        hideLoading: function () {\n            var options = this.options,\n                loadingDiv = this.loadingDiv;\n\n            if (loadingDiv) {\n                loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';\n                ";
if (build.classic) { 
s += "\n                animate(loadingDiv, {\n                    opacity: 0\n                }, {\n                    duration: options.loading.hideDuration || 100,\n                    complete: function () {\n                        css(loadingDiv, { display: 'none' });\n                    }\n                });\n                ";
} 
s += "\n            }\n            this.loadingShown = false;\n        }\n    });\n\n    // extend the Point prototype for dynamic methods\n    extend(Point.prototype, {\n        /**\n         * Update the point with new options (typically x/y data) and optionally redraw the series.\n         *\n         * @param {Object} options Point options as defined in the series.data array\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         *\n         */\n        update: function (options, redraw, animation, runEvent) {\n            var point = this,\n                series = point.series,\n                graphic = point.graphic,\n                i,\n                chart = series.chart,\n                seriesOptions = series.options,\n                names = series.xAxis && series.xAxis.names;\n\n            redraw = pick(redraw, true);\n\n            function update() {\n\n                point.applyOptions(options);\n\n                // Update visuals\n                if (point.y === null && graphic) { // #4146\n                    point.graphic = graphic.destroy();\n                }\n                if (isObject(options) && !isArray(options)) {\n                    // Defer the actual redraw until getAttribs has been called (#3260)\n                    point.redraw = function () {\n                        if (graphic && graphic.element) {\n                            if (options && options.marker && options.marker.symbol) {\n                                point.graphic = graphic.destroy();\n                            }\n                        }\n                        if (options && options.dataLabels && point.dataLabel) { // #2468\n                            point.dataLabel = point.dataLabel.destroy();\n                        }\n                        point.redraw = null;\n                    };\n                }\n\n                // record changes in the parallel arrays\n                i = point.index;\n                series.updateParallelArrays(point, i);\n                if (names && point.name) {\n                    names[point.x] = point.name;\n                }\n\n                // Record the options to options.data. If there is an object from before,\n                // use point options, otherwise use raw options. (#4701)\n                seriesOptions.data[i] = isObject(seriesOptions.data[i]) ? point.options : options;\n\n                // redraw\n                series.isDirty = series.isDirtyData = true;\n                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                    chart.isDirtyBox = true;\n                }\n\n                if (seriesOptions.legendType === 'point') { // #1831, #1885\n                    chart.isDirtyLegend = true;\n                }\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            }\n\n            // Fire the event with a default handler of doing the update\n            if (runEvent === false) { // When called from setData\n                update();\n            } else {\n                point.firePointEvent('update', { options: options }, update);\n            }\n        },\n\n        /**\n         * Remove a point and optionally redraw the series and if necessary the axes\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        remove: function (redraw, animation) {\n            this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n        }\n    });\n\n    // Extend the series prototype for dynamic methods\n    extend(Series.prototype, {\n        /**\n         * Add a point dynamically after chart load time\n         * @param {Object} options Point options as given in series.data\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean} shift If shift is true, a point is shifted off the start\n         *    of the series as one is appended to the end.\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        addPoint: function (options, redraw, shift, animation) {\n            var series = this,\n                seriesOptions = series.options,\n                data = series.data,\n                graph = series.graph,\n                area = series.area,\n                chart = series.chart,\n                names = series.xAxis && series.xAxis.names,\n                currentShift = (graph && graph.shift) || 0,\n                shiftShapes = ['graph', 'area'],\n                dataOptions = seriesOptions.data,\n                point,\n                isInTheMiddle,\n                xData = series.xData,\n                i,\n                x;\n\n            setAnimation(animation, chart);\n\n            // Make graph animate sideways\n            if (shift) {\n                i = series.zones.length;\n                while (i--) {\n                    shiftShapes.push('zone-graph-' + i, 'zone-area-' + i);\n                }\n                each(shiftShapes, function (shape) {\n                    if (series[shape]) {\n                        series[shape].shift = currentShift + (seriesOptions.step ? 2 : 1);\n                    }\n                });\n            }\n            if (area) {\n                area.isArea = true; // needed in animation, both with and without shift\n            }\n\n            // Optional redraw, defaults to true\n            redraw = pick(redraw, true);\n\n            // Get options and push the point to xData, yData and series.options. In series.generatePoints\n            // the Point instance will be created on demand and pushed to the series.data array.\n            point = { series: series };\n            series.pointClass.prototype.applyOptions.apply(point, [options]);\n            x = point.x;\n\n            // Get the insertion point\n            i = xData.length;\n            if (series.requireSorting && x < xData[i - 1]) {\n                isInTheMiddle = true;\n                while (i && xData[i - 1] > x) {\n                    i--;\n                }\n            }\n\n            series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n            series.updateParallelArrays(point, i); // update it\n\n            if (names && point.name) {\n                names[x] = point.name;\n            }\n            dataOptions.splice(i, 0, options);\n\n            if (isInTheMiddle) {\n                series.data.splice(i, 0, null);\n                series.processData();\n            }\n\n            // Generate points to be added to the legend (#1329)\n            if (seriesOptions.legendType === 'point') {\n                series.generatePoints();\n            }\n\n            // Shift the first point off the parallel arrays\n            if (shift) {\n                if (data[0] && data[0].remove) {\n                    data[0].remove(false);\n                } else {\n                    data.shift();\n                    series.updateParallelArrays(point, 'shift');\n\n                    dataOptions.shift();\n                }\n            }\n\n            // redraw\n            series.isDirty = true;\n            series.isDirtyData = true;\n            if (redraw) {\n                ";
if (build.clasic) { 
s += "\n                series.getAttribs(); // #1937\n                ";
} 
s += "\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Remove a point (rendered or not), by index\n         */\n        removePoint: function (i, redraw, animation) {\n\n            var series = this,\n                data = series.data,\n                point = data[i],\n                points = series.points,\n                chart = series.chart,\n                remove = function () {\n\n                    if (data.length === points.length) {\n                        points.splice(i, 1);\n                    }\n                    data.splice(i, 1);\n                    series.options.data.splice(i, 1);\n                    series.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n                    if (point) {\n                        point.destroy();\n                    }\n\n                    // redraw\n                    series.isDirty = true;\n                    series.isDirtyData = true;\n                    if (redraw) {\n                        chart.redraw();\n                    }\n                };\n\n            setAnimation(animation, chart);\n            redraw = pick(redraw, true);\n\n            // Fire the event with a default handler of removing the point\n            if (point) {\n                point.firePointEvent('remove', null, remove);\n            } else {\n                remove();\n            }\n        },\n\n        /**\n         * Remove a series and optionally redraw the chart\n         *\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        remove: function (redraw, animation) {\n            var series = this,\n                chart = series.chart;\n\n            // Fire the event with a default handler of removing the point\n            fireEvent(series, 'remove', null, function () {\n\n                // Destroy elements\n                series.destroy();\n\n                // Redraw\n                chart.isDirtyLegend = chart.isDirtyBox = true;\n                chart.linkSeries();\n\n                if (pick(redraw, true)) {\n                    chart.redraw(animation);\n                }\n            });\n        },\n\n        /**\n         * Update the series with a new set of options\n         */\n        update: function (newOptions, redraw) {\n            var series = this,\n                chart = this.chart,\n                // must use user options when changing type because this.options is merged\n                // in with type specific plotOptions\n                oldOptions = this.userOptions,\n                oldType = this.type,\n                proto = seriesTypes[oldType].prototype,\n                preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n                n;\n\n            // If we're changing type or zIndex, create new groups (#3380, #3404)\n            if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n                preserve.length = 0;\n            }\n\n            // Make sure groups are not destroyed (#3094)\n            each(preserve, function (prop) {\n                preserve[prop] = series[prop];\n                delete series[prop];\n            });\n\n            // Do the merge, with some forced options\n            newOptions = merge(oldOptions, {\n                animation: false,\n                index: this.index,\n                pointStart: this.xData[0] // when updating after addPoint\n            }, { data: this.options.data }, newOptions);\n\n            // Destroy the series and delete all properties. Reinsert all methods\n            // and properties from the new type prototype (#2270, #3719)\n            this.remove(false);\n            for (n in proto) {\n                this[n] = undefined;\n            }\n            extend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n            // Re-register groups (#3094)\n            each(preserve, function (prop) {\n                series[prop] = preserve[prop];\n            });\n\n            this.init(chart, newOptions);\n            chart.linkSeries(); // Links are lost in this.remove (#3028)\n            if (pick(redraw, true)) {\n                chart.redraw(false);\n            }\n        }\n    });\n\n    // Extend the Axis.prototype for dynamic methods\n    extend(Axis.prototype, {\n\n        /**\n         * Update the axis with a new options structure\n         */\n        update: function (newOptions, redraw) {\n            var chart = this.chart;\n\n            newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n            this.destroy(true);\n            this._addedPlotLB = this.chart._labelPanes = undefined; // #1611, #2887, #4314\n\n            this.init(chart, extend(newOptions, { events: undefined }));\n\n            chart.isDirtyBox = true;\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Remove the axis from the chart\n         */\n        remove: function (redraw) {\n            var chart = this.chart,\n                key = this.coll, // xAxis or yAxis\n                axisSeries = this.series,\n                i = axisSeries.length;\n\n            // Remove associated series (#2687)\n            while (i--) {\n                if (axisSeries[i]) {\n                    axisSeries[i].remove(false);\n                }\n            }\n\n            // Remove the axis\n            erase(chart.axes, this);\n            erase(chart[key], this);\n            chart.options[key].splice(this.options.index, 1);\n            each(chart[key], function (axis, i) { // Re-index, #1706\n                axis.options.index = i;\n            });\n            this.destroy();\n            chart.isDirtyBox = true;\n\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Update the axis title by options\n         */\n        setTitle: function (newTitleOptions, redraw) {\n            this.update({ title: newTitleOptions }, redraw);\n        },\n\n        /**\n         * Set new axis categories and optionally redraw\n         * @param {Array} categories\n         * @param {Boolean} redraw\n         */\n        setCategories: function (categories, redraw) {\n            this.update({ categories: categories }, redraw);\n        }\n\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var extendClass = H.extendClass,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes;\n    /**\n     * LineSeries object\n     */\n    seriesTypes.line = extendClass(Series);\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Color = H.Color,\n            defaultPlotOptions = H.defaultPlotOptions,\n            defaultSeriesOptions = H.defaultSeriesOptions,\n            each = H.each,\n            extendClass = H.extendClass,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            stop = H.stop,\n            svg = H.svg;\n    /**\n     * Set the default options for column\n     */\n    defaultPlotOptions.column = merge(defaultSeriesOptions, {\n        ";
if (build.classic) { 
s += "\n        borderColor: '#FFFFFF',\n        //borderWidth: 1,\n        ";
} 
s += "\n        borderRadius: 0,\n        //colorByPoint: undefined,\n        groupPadding: 0.2,\n        //grouping: true,\n        marker: null, // point options are specified in the base options\n        pointPadding: 0.1,\n        //pointWidth: null,\n        minPointLength: 0,\n        cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n        pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n        states: {\n            hover: {\n                halo: false,\n                ";
if (build.classic) { 
s += "\n                brightness: 0.1,\n                shadow: false\n                ";
} 
s += "\n            },\n            ";
if (build.classic) { 
s += "\n            select: {\n                color: '#C0C0C0',\n                borderColor: '#000000',\n                shadow: false\n            }\n            ";
} 
s += "\n        },\n        dataLabels: {\n            align: null, // auto\n            verticalAlign: null, // auto\n            y: null\n        },\n        softThreshold: false,\n        startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/\n        stickyTracking: false,\n        tooltip: {\n            distance: 6\n        },\n        threshold: 0\n    });\n\n    /**\n     * ColumnSeries object\n     */\n    seriesTypes.column = extendClass(Series, {\n        type: 'column',\n        cropShoulder: 0,\n        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        negStacks: true, // use separate negative stacks, unlike area stacks where a negative\n            // point is substracted from previous (#1910)\n\n        /**\n         * Initialize the series\n         */\n        init: function () {\n            Series.prototype.init.apply(this, arguments);\n\n            var series = this,\n                chart = series.chart;\n\n            // if the series is added dynamically, force redraw of other\n            // series affected by a new column\n            if (chart.hasRendered) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.type === series.type) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n        },\n\n        /**\n         * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n         * pointWidth etc.\n         */\n        getColumnMetrics: function () {\n\n            var series = this,\n                options = series.options,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                reversedXAxis = xAxis.reversed,\n                stackKey,\n                stackGroups = {},\n                columnCount = 0;\n\n            // Get the total number of column type series.\n            // This is called on every series. Consider moving this logic to a\n            // chart.orderStacks() function and call it on init, addSeries and removeSeries\n            if (options.grouping === false) {\n                columnCount = 1;\n            } else {\n                each(series.chart.series, function (otherSeries) {\n                    var otherOptions = otherSeries.options,\n                        otherYAxis = otherSeries.yAxis,\n                        columnIndex;\n                    if (otherSeries.type === series.type && otherSeries.visible &&\n                            yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n                        if (otherOptions.stacking) {\n                            stackKey = otherSeries.stackKey;\n                            if (stackGroups[stackKey] === undefined) {\n                                stackGroups[stackKey] = columnCount++;\n                            }\n                            columnIndex = stackGroups[stackKey];\n                        } else if (otherOptions.grouping !== false) { // #1162\n                            columnIndex = columnCount++;\n                        }\n                        otherSeries.columnIndex = columnIndex;\n                    }\n                });\n            }\n\n            var categoryWidth = Math.min(\n                    Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n                    xAxis.len // #1535\n                ),\n                groupPadding = categoryWidth * options.groupPadding,\n                groupWidth = categoryWidth - 2 * groupPadding,\n                pointOffsetWidth = groupWidth / columnCount,\n                pointWidth = Math.min(\n                    options.maxPointWidth || xAxis.len,\n                    pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))\n                ),\n                pointPadding = (pointOffsetWidth - pointWidth) / 2,\n                colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737\n                pointXOffset = pointPadding + (groupPadding + colIndex *\n                    pointOffsetWidth - (categoryWidth / 2)) *\n                    (reversedXAxis ? -1 : 1);\n\n            // Save it for reading in linked series (Error bars particularly)\n            series.columnMetrics = {\n                width: pointWidth,\n                offset: pointXOffset\n            };\n            return series.columnMetrics;\n\n        },\n\n        /**\n         * Make the columns crisp. The edges are rounded to the nearest full pixel.\n         */\n        crispCol: function (x, y, w, h) {\n            var chart = this.chart,\n                borderWidth = this.borderWidth,\n                xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n                yCrisp = borderWidth % 2 ? 0.5 : 1,\n                right,\n                bottom,\n                fromTop;\n\n            if (chart.inverted && chart.renderer.isVML) {\n                yCrisp += 1;\n            }\n\n            // Horizontal. We need to first compute the exact right edge, then round it\n            // and compute the width from there.\n            right = Math.round(x + w) + xCrisp;\n            x = Math.round(x) + xCrisp;\n            w = right - x;\n\n            // Vertical\n            bottom = Math.round(y + h) + yCrisp;\n            fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n            y = Math.round(y) + yCrisp;\n            h = bottom - y;\n\n            // Top edges are exceptions\n            if (fromTop) {\n                y -= 1;\n                h += 1;\n            }\n\n            return {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n        },\n\n        /**\n         * Translate each point to the plot area coordinate system and find shape positions\n         */\n        translate: function () {\n            var series = this,\n                chart = series.chart,\n                options = series.options,\n                dense = series.closestPointRange * series.xAxis.transA < 2,\n                borderWidth = series.borderWidth = pick(\n                    options.borderWidth, \n                    dense ? 0 : 1  // #3635\n                ),\n                yAxis = series.yAxis,\n                threshold = options.threshold,\n                translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n                minPointLength = pick(options.minPointLength, 5),\n                metrics = series.getColumnMetrics(),\n                pointWidth = metrics.width,\n                seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n                pointXOffset = series.pointXOffset = metrics.offset;\n\n            if (chart.inverted) {\n                translatedThreshold -= 0.5; // #3355\n            }\n\n            // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n            // columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n            // columns (#2694).\n            if (options.pointPadding) {\n                seriesBarW = Math.ceil(seriesBarW);\n            }\n\n            Series.prototype.translate.apply(series);\n\n            // Record the new values\n            each(series.points, function (point) {\n                var yBottom = pick(point.yBottom, translatedThreshold),\n                    safeDistance = 999 + Math.abs(yBottom),\n                    plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                    barX = point.plotX + pointXOffset,\n                    barW = seriesBarW,\n                    barY = Math.min(plotY, yBottom),\n                    up,\n                    barH = Math.max(plotY, yBottom) - barY;\n\n                // Handle options.minPointLength\n                if (Math.abs(barH) < minPointLength) {\n                    if (minPointLength) {\n                        barH = minPointLength;\n                        up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);\n                        barY = Math.abs(barY - translatedThreshold) > minPointLength ? // stacked\n                                yBottom - minPointLength : // keep position\n                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051\n                    }\n                }\n\n                // Cache for access in polar\n                point.barX = barX;\n                point.pointWidth = pointWidth;\n\n                // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n                point.tooltipPos = chart.inverted ?\n                    [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :\n                    [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n                // Register shape type and arguments to be used in drawPoints\n                point.shapeType = 'rect';\n                point.shapeArgs = series.crispCol(barX, barY, barW, barH);\n            });\n\n        },\n\n        getSymbol: noop,\n\n        /**\n         * Use a solid rectangle like the area series types\n         */\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n        /**\n         * Columns have no graph\n         */\n        drawGraph: noop,\n\n        /**\n         * Get presentational attributes\n         */\n        pointAttribs: function (point, state) {\n            var options = this.options,\n                stateOptions,\n                ret,\n                p2o = this.pointAttrToOptions || {},\n                strokeOption = p2o.stroke || 'borderColor',\n                strokeWidthOption = p2o['stroke-width'] || 'borderWidth',\n                fill = (point && point.color) || this.color,\n                stroke = options[strokeOption] || this.color,\n                dashstyle = options.dashStyle,\n                zone,\n                brightness;\n        \n            if (point && this.zones.length) {\n                zone = point.getZone();\n                if (zone && zone.color) {\n                    fill = zone.color;\n                }\n            }\n\n            // Select or hover states\n            if (state) {\n                stateOptions = options.states[state];\n                brightness = stateOptions.brightness;\n                fill = stateOptions.color || \n                    (brightness !== undefined && Color(fill).brighten(stateOptions.brightness).get()) ||\n                    fill;\n                stroke = stateOptions[strokeOption] || stroke;\n                dashstyle = stateOptions.dashStyle || dashstyle;\n            }\n\n            ret = {\n                'fill': fill,\n                'stroke': stroke,\n                'stroke-width': point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0\n            };\n            if (options.borderRadius) {\n                ret.r = options.borderRadius;\n            }\n\n            if (dashstyle) {\n                ret.dashstyle = dashstyle;\n            }\n\n            return ret;\n        },\n\n        /**\n         * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n         * apply for columns and bars. This method is inherited by scatter series.\n         *\n         */\n        drawPoints: function () {\n            var series = this,\n                chart = this.chart,\n                options = series.options,\n                renderer = chart.renderer,\n                animationLimit = options.animationLimit || 250,\n                shapeArgs;\n\n            // draw the columns\n            each(series.points, function (point) {\n                var plotY = point.plotY,\n                    graphic = point.graphic;\n\n                if (plotY !== undefined && !isNaN(plotY) && point.y !== null) {\n                    shapeArgs = point.shapeArgs;\n\n                    if (graphic) { // update\n                        stop(graphic);\n                        graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](\n                            merge(shapeArgs)\n                        );\n\n                    } else {\n                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                            .addClass('highcharts-point' + (point.selected ? ' highcharts-point-select' : ''))\n                            .add(point.group || series.group);\n\n                        ";
if (build.classic) { 
s += "\n                        // Presentational\n                        graphic\n                            .attr(series.pointAttribs(point, point.selected && 'select'))\n                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);\n                        ";
} 
s += "\n                    }\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            });\n        },\n\n        /**\n         * Animate the column heights one by one from zero\n         * @param {Boolean} init Whether to initialize the animation or run it\n         */\n        animate: function (init) {\n            var series = this,\n                yAxis = this.yAxis,\n                options = series.options,\n                inverted = this.chart.inverted,\n                attr = {},\n                translatedThreshold;\n\n            if (svg) { // VML is too slow anyway\n                if (init) {\n                    attr.scaleY = 0.001;\n                    translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));\n                    if (inverted) {\n                        attr.translateX = translatedThreshold - yAxis.len;\n                    } else {\n                        attr.translateY = translatedThreshold;\n                    }\n                    series.group.attr(attr);\n\n                } else { // run the animation\n\n                    attr.scaleY = 1;\n                    attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n                    series.group.animate(attr, series.options.animation);\n\n                    // delete this function to allow it only once\n                    series.animate = null;\n                }\n            }\n        },\n\n        /**\n         * Remove this series from the chart\n         */\n        remove: function () {\n            var series = this,\n                chart = series.chart;\n\n            // column and bar series affects other series of the same type\n            // as they are either stacked or grouped\n            if (chart.hasRendered) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.type === series.type) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n\n            Series.prototype.remove.apply(series, arguments);\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            defaultSeriesOptions = H.defaultSeriesOptions,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes;\n    /**\n     * Set the default options for scatter\n     */\n    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n        lineWidth: 0,\n        marker: {\n            enabled: true // Overrides auto-enabling in line series (#3647)\n        },\n        tooltip: {\n            headerFormat: '<span style=___doublequote___color:{point.color}___doublequote___>\\u25CF</span> <span style=___doublequote___font-size: 0.85em___doublequote___> {series.name}</span><br/>',\n            pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n        }\n    });\n\n    /**\n     * The scatter series class\n     */\n    seriesTypes.scatter = extendClass(Series, {\n        type: 'scatter',\n        sorted: false,\n        requireSorting: false,\n        noSharedTooltip: true,\n        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n        takeOrdinalPosition: false, // #2342\n        kdDimensions: 2,\n        drawGraph: function () {\n            if (this.options.lineWidth) {\n                Series.prototype.drawGraph.call(this);\n            }\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            arrayMax = H.arrayMax,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            relativeLength = H.relativeLength,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            stop = H.stop;\n    /**\n     * Draw the data labels\n     */\n    Series.prototype.drawDataLabels = function () {\n\n        var series = this,\n            seriesOptions = series.options,\n            options = seriesOptions.dataLabels,\n            points = series.points,\n            pointOptions,\n            generalOptions,\n            hasRendered = series.hasRendered || 0,\n            str,\n            dataLabelsGroup,\n            renderer = series.chart.renderer;\n\n        if (options.enabled || series._hasPointLabels) {\n\n            // Process default alignment of data labels for columns\n            if (series.dlProcessOptions) {\n                series.dlProcessOptions(options);\n            }\n\n            // Create a separate group for the data labels to avoid rotation\n            dataLabelsGroup = series.plotGroup(\n                'dataLabelsGroup',\n                'data-labels',\n                options.defer ? 'hidden' : 'visible',\n                options.zIndex || 6\n            );\n\n            if (pick(options.defer, true)) {\n                dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n                if (!hasRendered) {\n                    addEvent(series, 'afterAnimate', function () {\n                        if (series.visible) { // #3023, #3024\n                            dataLabelsGroup.show();\n                        }\n                        dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n                    });\n                }\n            }\n\n            // Make the labels for each point\n            generalOptions = options;\n            each(points, function (point) {\n\n                var enabled,\n                    dataLabel = point.dataLabel,\n                    labelConfig,\n                    attr,\n                    name,\n                    rotation,\n                    connector = point.connector,\n                    isNew = true,\n                    style,\n                    moreStyle = {};\n\n                // Determine if each data label is enabled\n                pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n                enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641\n\n\n                // If the point is outside the plot area, destroy it. #678, #820\n                if (dataLabel && !enabled) {\n                    point.dataLabel = dataLabel.destroy();\n\n                // Individual labels are disabled if the are explicitly disabled\n                // in the point options, or if they fall outside the plot area.\n                } else if (enabled) {\n\n                    // Create individual options structure that can be extended without\n                    // affecting others\n                    options = merge(generalOptions, pointOptions);\n                    style = options.style;\n\n                    rotation = options.rotation;\n\n                    // Get the string\n                    labelConfig = point.getLabelConfig();\n                    str = options.format ?\n                        format(options.format, labelConfig) :\n                        options.formatter.call(labelConfig, options);\n\n                    ";
if (build.classic) { 
s += "\n                    // Determine the color\n                    style.color = pick(options.color, style.color, series.color, 'black');\n                    ";
} 
s += "\n\n                    // update existing label\n                    if (dataLabel) {\n\n                        if (defined(str)) {\n                            dataLabel\n                                .attr({\n                                    text: str\n                                });\n                            isNew = false;\n\n                        } else { // #1437 - the label is shown conditionally\n                            point.dataLabel = dataLabel = dataLabel.destroy();\n                            if (connector) {\n                                point.connector = connector.destroy();\n                            }\n                        }\n\n                    // create new label\n                    } else if (defined(str)) {\n                        attr = {\n                            //align: align,\n                            ";
if (build.classic) { 
s += "\n                            fill: options.backgroundColor,\n                            stroke: options.borderColor,\n                            'stroke-width': options.borderWidth,\n                            ";
} 
s += "\n                            r: options.borderRadius || 0,\n                            rotation: rotation,\n                            padding: options.padding,\n                            zIndex: 1\n                        };\n                    \n                        ";
if (build.classic) { 
s += "\n                        // Get automated contrast color\n                        if (style.color === 'contrast') {\n                            moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?\n                                renderer.getContrast(point.color || series.color) :\n                                '#000000';\n                        }\n\n                        if (seriesOptions.cursor) {\n                            moreStyle.cursor = seriesOptions.cursor;\n                        }\n                        ";
} 
s += "\n\n\n                        // Remove unused attributes (#947)\n                        for (name in attr) {\n                            if (attr[name] === undefined) {\n                                delete attr[name];\n                            }\n                        }\n\n                        dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n                            str,\n                            0,\n                            -9999,\n                            options.shape,\n                            null,\n                            null,\n                            options.useHTML,\n                            null, \n                            'data-label'\n                        )\n                        .attr(attr)\n                        .css(extend(style, moreStyle))\n                        .add(dataLabelsGroup);\n\n                        if (options.className) { // docs\n                            dataLabel.addClass(options.className);\n                        }\n\n                        ";
if (build.classic) { 
s += "\n                        dataLabel.shadow(options.shadow);\n                        ";
} 
s += "\n\n                    }\n\n                    if (dataLabel) {\n                        // Now the data label is created and placed at 0,0, so we need to align it\n                        series.alignDataLabel(point, dataLabel, options, null, isNew);\n                    }\n                }\n            });\n        }\n    };\n\n    /**\n     * Align each individual data label\n     */\n    Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n        var chart = this.chart,\n            inverted = chart.inverted,\n            plotX = pick(point.plotX, -9999),\n            plotY = pick(point.plotY, -9999),\n            bBox = dataLabel.getBBox(),\n            fontSize,\n            baseline,\n            rotCorr, // rotation correction\n            // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n            visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||\n                (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n            alignAttr, // the final position;\n            justify = pick(options.overflow, 'justify') === 'justify';\n\n        if (visible) {\n\n            ";
if (build.classic) { 
s += "\n            fontSize = options.style.fontSize;\n            ";
} 
s += "\n\n            baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;\n\n            // The alignment box is a singular point\n            alignTo = extend({\n                x: inverted ? chart.plotWidth - plotY : plotX,\n                y: Math.round(inverted ? chart.plotHeight - plotX : plotY),\n                width: 0,\n                height: 0\n            }, alignTo);\n\n            // Add the text size for alignment calculation\n            extend(options, {\n                width: bBox.width,\n                height: bBox.height\n            });\n\n            // Allow a hook for changing alignment in the last moment, then do the alignment\n            if (options.rotation) {\n                justify = false; // Not supported for rotated text\n                rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723\n                alignAttr = {\n                    x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                    y: alignTo.y + options.y + alignTo.height / 2\n                };\n                dataLabel\n                    [isNew ? 'attr' : 'animate'](alignAttr)\n                    .attr({ // #3003\n                        align: options.align\n                    });\n\n            } else {\n                dataLabel.align(options, null, alignTo);\n                alignAttr = dataLabel.alignAttr;\n\n                // When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n                if (options.shape) {\n                    dataLabel.attr({\n                        anchorX: point.plotX,\n                        anchorY: point.plotY\n                    });\n                }\n            }\n\n            // Handle justify or crop\n            if (justify) {\n                this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n            \n            // Now check that the data label is within the plot area\n            } else if (pick(options.crop, true)) {\n                visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n            }\n        }\n\n        // Show or hide based on the final aligned position\n        if (!visible) {\n            stop(dataLabel);\n            dataLabel.attr({ y: -9999 });\n            dataLabel.placed = false; // don't animate back in\n        }\n\n    };\n\n    /**\n     * If data labels fall partly outside the plot area, align them back in, in a way that\n     * doesn't hide the point.\n     */\n    Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n        var chart = this.chart,\n            align = options.align,\n            verticalAlign = options.verticalAlign,\n            off,\n            justified,\n            padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n        // Off left\n        off = alignAttr.x + padding;\n        if (off < 0) {\n            if (align === 'right') {\n                options.align = 'left';\n            } else {\n                options.x = -off;\n            }\n            justified = true;\n        }\n\n        // Off right\n        off = alignAttr.x + bBox.width - padding;\n        if (off > chart.plotWidth) {\n            if (align === 'left') {\n                options.align = 'right';\n            } else {\n                options.x = chart.plotWidth - off;\n            }\n            justified = true;\n        }\n\n        // Off top\n        off = alignAttr.y + padding;\n        if (off < 0) {\n            if (verticalAlign === 'bottom') {\n                options.verticalAlign = 'top';\n            } else {\n                options.y = -off;\n            }\n            justified = true;\n        }\n\n        // Off bottom\n        off = alignAttr.y + bBox.height - padding;\n        if (off > chart.plotHeight) {\n            if (verticalAlign === 'top') {\n                options.verticalAlign = 'bottom';\n            } else {\n                options.y = chart.plotHeight - off;\n            }\n            justified = true;\n        }\n\n        if (justified) {\n            dataLabel.placed = !isNew;\n            dataLabel.align(options, null, alignTo);\n        }\n    };\n\n    /**\n     * Override the base drawDataLabels method by pie specific functionality\n     */\n    if (seriesTypes.pie) {\n        seriesTypes.pie.prototype.drawDataLabels = function () {\n            var series = this,\n                data = series.data,\n                point,\n                chart = series.chart,\n                options = series.options.dataLabels,\n                connectorPadding = pick(options.connectorPadding, 10),\n                connectorWidth = pick(options.connectorWidth, 1),\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                connector,\n                connectorPath,\n                softConnector = pick(options.softConnector, true),\n                distanceOption = options.distance,\n                seriesCenter = series.center,\n                radius = seriesCenter[2] / 2,\n                centerY = seriesCenter[1],\n                outside = distanceOption > 0,\n                dataLabel,\n                dataLabelWidth,\n                labelPos,\n                labelHeight,\n                halves = [// divide the points into right and left halves for anti collision\n                    [], // right\n                    []  // left\n                ],\n                x,\n                y,\n                visibility,\n                rankArr,\n                i,\n                j,\n                overflow = [0, 0, 0, 0], // top, right, bottom, left\n                sort = function (a, b) {\n                    return b.y - a.y;\n                };\n\n            // get out if not enabled\n            if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n                return;\n            }\n\n            // run parent method\n            Series.prototype.drawDataLabels.apply(series);\n\n            each(data, function (point) {\n                if (point.dataLabel && point.visible) { // #407, #2510\n\n                    // Arrange points for detection collision\n                    halves[point.half].push(point);\n\n                    // Reset positions (#4905)\n                    point.dataLabel._pos = null;\n                }\n            });\n\n            /* Loop over the points in each half, starting from the top and bottom\n             * of the pie to detect overlapping labels.\n             */\n            i = 2;\n            while (i--) {\n\n                var slots = [],\n                    slotsLength,\n                    usedSlots = [],\n                    points = halves[i],\n                    pos,\n                    bottom,\n                    length = points.length,\n                    slotIndex;\n\n                if (!length) {\n                    continue;\n                }\n\n                // Sort by angle\n                series.sortByAngle(points, i - 0.5);\n\n                // Assume equal label heights on either hemisphere (#2630)\n                j = labelHeight = 0;\n                while (!labelHeight && points[j]) { // #1569\n                    labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n                    j++;\n                }\n\n                // Only do anti-collision when we are outside the pie and have connectors (#856)\n                if (distanceOption > 0) {\n\n                    // Build the slots\n                    bottom = Math.min(centerY + radius + distanceOption, chart.plotHeight);\n                    for (pos = Math.max(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n                        slots.push(pos);\n                    }\n                    slotsLength = slots.length;\n\n\n                    /* Visualize the slots\n                    if (!series.slotElements) {\n                        series.slotElements = [];\n                    }\n                    if (i === 1) {\n                        series.slotElements.forEach(function (elem) {\n                            elem.destroy();\n                        });\n                        series.slotElements.length = 0;\n                    }\n\n                    slots.forEach(function (pos, no) {\n                        var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n                            slotY = pos + chart.plotTop;\n\n                        if (!isNaN(slotX)) {\n                            series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n                                .attr({\n                                    'stroke-width': 1,\n                                    stroke: 'silver',\n                                    fill: 'rgba(0,0,255,0.1)'\n                                })\n                                .add());\n                            series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n                                .attr({\n                                    fill: 'silver'\n                                }).add());\n                        }\n                    });\n                    // */\n\n                    // if there are more values than available slots, remove lowest values\n                    if (length > slotsLength) {\n                        // create an array for sorting and ranking the points within each quarter\n                        rankArr = [].concat(points);\n                        rankArr.sort(sort);\n                        j = length;\n                        while (j--) {\n                            rankArr[j].rank = j;\n                        }\n                        j = length;\n                        while (j--) {\n                            if (points[j].rank >= slotsLength) {\n                                points.splice(j, 1);\n                            }\n                        }\n                        length = points.length;\n                    }\n\n                    // The label goes to the nearest open slot, but not closer to the edge than\n                    // the label's index.\n                    for (j = 0; j < length; j++) {\n\n                        point = points[j];\n                        labelPos = point.labelPos;\n\n                        var closest = 9999,\n                            distance,\n                            slotI;\n\n                        // find the closest slot index\n                        for (slotI = 0; slotI < slotsLength; slotI++) {\n                            distance = Math.abs(slots[slotI] - labelPos[1]);\n                            if (distance < closest) {\n                                closest = distance;\n                                slotIndex = slotI;\n                            }\n                        }\n\n                        // if that slot index is closer to the edges of the slots, move it\n                        // to the closest appropriate slot\n                        if (slotIndex < j && slots[j] !== null) { // cluster at the top\n                            slotIndex = j;\n                        } else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n                            slotIndex = slotsLength - length + j;\n                            while (slots[slotIndex] === null) { // make sure it is not taken\n                                slotIndex++;\n                            }\n                        } else {\n                            // Slot is taken, find next free slot below. In the next run, the next slice will find the\n                            // slot above these, because it is the closest one\n                            while (slots[slotIndex] === null) { // make sure it is not taken\n                                slotIndex++;\n                            }\n                        }\n\n                        usedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n                        slots[slotIndex] = null; // mark as taken\n                    }\n                    // sort them in order to fill in from the top\n                    usedSlots.sort(sort);\n                }\n\n                // now the used slots are sorted, fill them up sequentially\n                for (j = 0; j < length; j++) {\n\n                    var slot, naturalY;\n\n                    point = points[j];\n                    labelPos = point.labelPos;\n                    dataLabel = point.dataLabel;\n                    visibility = point.visible === false ? 'hidden' : 'inherit';\n                    naturalY = labelPos[1];\n\n                    if (distanceOption > 0) {\n                        slot = usedSlots.pop();\n                        slotIndex = slot.i;\n\n                        // if the slot next to currrent slot is free, the y value is allowed\n                        // to fall back to the natural position\n                        y = slot.y;\n                        if ((naturalY > y && slots[slotIndex + 1] !== null) ||\n                                (naturalY < y &&  slots[slotIndex - 1] !== null)) {\n                            y = Math.min(Math.max(0, naturalY), chart.plotHeight);\n                        }\n\n                    } else {\n                        y = naturalY;\n                    }\n\n                    // get the x - use the natural x position for first and last slot, to prevent the top\n                    // and botton slice connectors from touching each other on either side\n                    x = options.justify ?\n                        seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n                        series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n                    // Record the placement and visibility\n                    dataLabel._attr = {\n                        visibility: visibility,\n                        align: labelPos[6]\n                    };\n                    dataLabel._pos = {\n                        x: x + options.x +\n                            ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n                        y: y + options.y - 10 // 10 is for the baseline (label vs text)\n                    };\n                    dataLabel.connX = x;\n                    dataLabel.connY = y;\n\n\n                    // Detect overflowing data labels\n                    if (this.options.size === null) {\n                        dataLabelWidth = dataLabel.width;\n                        // Overflow left\n                        if (x - dataLabelWidth < connectorPadding) {\n                            overflow[3] = Math.max(Math.round(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n                        // Overflow right\n                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n                            overflow[1] = Math.max(Math.round(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n                        }\n\n                        // Overflow top\n                        if (y - labelHeight / 2 < 0) {\n                            overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);\n\n                        // Overflow left\n                        } else if (y + labelHeight / 2 > plotHeight) {\n                            overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);\n                        }\n                    }\n                } // for each point\n            } // for each half\n\n            // Do not apply the final placement and draw the connectors until we have verified\n            // that labels are not spilling over.\n            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n                // Place the labels in the final position\n                this.placeDataLabels();\n\n                // Draw the connectors\n                if (outside && connectorWidth) {\n                    each(this.points, function (point) {\n                        connector = point.connector;\n                        labelPos = point.labelPos;\n                        dataLabel = point.dataLabel;\n\n                        if (dataLabel && dataLabel._pos && point.visible) {\n                            visibility = dataLabel._attr.visibility;\n                            x = dataLabel.connX;\n                            y = dataLabel.connY;\n                            connectorPath = softConnector ? [\n                                'M',\n                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                                'C',\n                                x, y, // first break, next to the label\n                                2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n                                labelPos[2], labelPos[3], // second break\n                                'L',\n                                labelPos[4], labelPos[5] // base\n                            ] : [\n                                'M',\n                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                                'L',\n                                labelPos[2], labelPos[3], // second break\n                                'L',\n                                labelPos[4], labelPos[5] // base\n                            ];\n\n                            if (connector) {\n                                connector.animate({ d: connectorPath });\n                                connector.attr('visibility', visibility);\n\n                            } else {\n                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({\n                                    'stroke-width': connectorWidth,\n                                    stroke: options.connectorColor || point.color || '#606060',\n                                    visibility: visibility\n                                    //zIndex: 0 // #2722 (reversed)\n                                })\n                                .add(series.dataLabelsGroup);\n                            }\n                        } else if (connector) {\n                            point.connector = connector.destroy();\n                        }\n                    });\n                }\n            }\n        };\n        /**\n         * Perform the final placement of the data labels after we have verified that they\n         * fall within the plot area.\n         */\n        seriesTypes.pie.prototype.placeDataLabels = function () {\n            each(this.points, function (point) {\n                var dataLabel = point.dataLabel,\n                    _pos;\n\n                if (dataLabel && point.visible) {\n                    _pos = dataLabel._pos;\n                    if (_pos) {\n                        dataLabel.attr(dataLabel._attr);\n                        dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                        dataLabel.moved = true;\n                    } else if (dataLabel) {\n                        dataLabel.attr({ y: -9999 });\n                    }\n                }\n            });\n        };\n\n        seriesTypes.pie.prototype.alignDataLabel =  noop;\n\n        /**\n         * Verify whether the data labels are allowed to draw, or we should run more translation and data\n         * label positioning to keep them inside the plot area. Returns true when data labels are ready\n         * to draw.\n         */\n        seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n            var center = this.center,\n                options = this.options,\n                centerOption = options.center,\n                minSize = options.minSize || 80,\n                newSize = minSize,\n                ret;\n\n            // Handle horizontal size and center\n            if (centerOption[0] !== null) { // Fixed center\n                newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);\n\n            } else { // Auto center\n                newSize = Math.max(\n                    center[2] - overflow[1] - overflow[3], // horizontal overflow\n                    minSize\n                );\n                center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n            }\n\n            // Handle vertical size and center\n            if (centerOption[1] !== null) { // Fixed center\n                newSize = Math.max(Math.min(newSize, center[2] - Math.max(overflow[0], overflow[2])), minSize);\n\n            } else { // Auto center\n                newSize = Math.max(\n                    Math.min(\n                        newSize,\n                        center[2] - overflow[0] - overflow[2] // vertical overflow\n                    ),\n                    minSize\n                );\n                center[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n            }\n\n            // If the size must be decreased, we need to run translate and drawDataLabels again\n            if (newSize < center[2]) {\n                center[2] = newSize;\n                center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632\n                this.translate(center);\n            \n                if (this.drawDataLabels) {\n                    this.drawDataLabels();\n                }\n            // Else, return true to indicate that the pie and its labels is within the plot area\n            } else {\n                ret = true;\n            }\n            return ret;\n        };\n    }\n\n    if (seriesTypes.column) {\n\n        /**\n         * Override the basic data label alignment by adjusting for the position of the column\n         */\n        seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n            var inverted = this.chart.inverted,\n                series = point.series,\n                dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n                below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series\n                inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?\n                overshoot;\n\n            // Align to the column itself, or the top of it\n            if (dlBox) { // Area range uses this method but not alignTo\n                alignTo = merge(dlBox);\n\n                if (alignTo.y < 0) {\n                    alignTo.height += alignTo.y;\n                    alignTo.y = 0;\n                }\n                overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n                if (overshoot > 0) {\n                    alignTo.height -= overshoot;\n                }\n\n                if (inverted) {\n                    alignTo = {\n                        x: series.yAxis.len - alignTo.y - alignTo.height,\n                        y: series.xAxis.len - alignTo.x - alignTo.width,\n                        width: alignTo.height,\n                        height: alignTo.width\n                    };\n                }\n\n                // Compute the alignment box\n                if (!inside) {\n                    if (inverted) {\n                        alignTo.x += below ? 0 : alignTo.width;\n                        alignTo.width = 0;\n                    } else {\n                        alignTo.y += below ? alignTo.height : 0;\n                        alignTo.height = 0;\n                    }\n                }\n            }\n\n\n            // When alignment is undefined (typically columns and bars), display the individual\n            // point below or above the point depending on the threshold\n            options.align = pick(\n                options.align,\n                !inverted || inside ? 'center' : below ? 'right' : 'left'\n            );\n            options.verticalAlign = pick(\n                options.verticalAlign,\n                inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n            );\n\n            // Call the parent method\n            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n        };\n    }\n\n        return H;\n    }(Highcharts));\n    /**\n     * Highcharts module to hide overlapping data labels. This module is included in Highcharts.\n     */\n    (function (H) {\n        var Chart = H.Chart,\n            each = H.each,\n            pick = H.pick,\n            addEvent = H.addEvent;\n\n        // Collect potensial overlapping data labels. Stack labels probably don't need to be \n        // considered because they are usually accompanied by data labels that lie inside the columns.\n        Chart.prototype.callbacks.push(function (chart) {\n            function collectAndHide() {\n                var labels = [];\n\n                each(chart.series, function (series) {\n                    var dlOptions = series.options.dataLabels,\n                        collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections\n                    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n                        each(collections, function (coll) {\n                            each(series.points, function (point) {\n                                if (point[coll]) {\n                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118\n                                    labels.push(point[coll]);\n                                }\n                            });\n                        });\n                    }\n                });\n                chart.hideOverlappingLabels(labels);\n            }\n\n            // Do it now ...\n            collectAndHide();\n\n            // ... and after each chart redraw\n            addEvent(chart, 'redraw', collectAndHide);\n\n        });\n\n        /**\n         * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n         * visual imression.\n         */    \n        Chart.prototype.hideOverlappingLabels = function (labels) {\n\n            var len = labels.length,\n                label,\n                i,\n                j,\n                label1,\n                label2,\n                isIntersecting,\n                pos1,\n                pos2,\n                parent1,\n                parent2,\n                padding,\n                intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {\n                    return !(\n                        x2 > x1 + w1 ||\n                        x2 + w2 < x1 ||\n                        y2 > y1 + h1 ||\n                        y2 + h2 < y1\n                    );\n                };\n    \n            // Mark with initial opacity\n            for (i = 0; i < len; i++) {\n                label = labels[i];\n                if (label) {\n                    label.oldOpacity = label.opacity;\n                    label.newOpacity = 1;\n                }\n            }\n\n            // Prevent a situation in a gradually rising slope, that each label\n            // will hide the previous one because the previous one always has\n            // lower rank.\n            labels.sort(function (a, b) {\n                return (b.labelrank || 0) - (a.labelrank || 0);\n            });\n\n            // Detect overlapping labels\n            for (i = 0; i < len; i++) {\n                label1 = labels[i];\n\n                for (j = i + 1; j < len; ++j) {\n                    label2 = labels[j];\n                    if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {\n                        pos1 = label1.alignAttr;\n                        pos2 = label2.alignAttr;\n                        parent1 = label1.parentGroup; // Different panes have different positions\n                        parent2 = label2.parentGroup;\n                        padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)\n                        isIntersecting = intersectRect(\n                            pos1.x + parent1.translateX,\n                            pos1.y + parent1.translateY,\n                            label1.width - padding,\n                            label1.height - padding,\n                            pos2.x + parent2.translateX,\n                            pos2.y + parent2.translateY,\n                            label2.width - padding,\n                            label2.height - padding\n                        );\n\n                        if (isIntersecting) {\n                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n                        }\n                    }\n                }\n            }\n\n            // Hide or show\n            each(labels, function (label) {\n                var complete,\n                    newOpacity;\n\n                if (label) {\n                    newOpacity = label.newOpacity;\n\n                    if (label.oldOpacity !== newOpacity && label.placed) {\n\n                        // Make sure the label is completely hidden to avoid catching clicks (#4362)\n                        if (newOpacity) {\n                            label.show(true);\n                        } else {\n                            complete = function () {\n                                label.hide();\n                            };\n                        }\n\n                        // Animate or set the opacity                \n                        label.alignAttr.opacity = newOpacity;\n                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n                    \n                    }\n                    label.isOld = true;\n                }\n            });\n        };\n    }(Highcharts));\n    (function (H) {\n        var Axis = H.Axis,\n            each = H.each,\n            pick = H.pick,\n            wrap = H.wrap;\n    /**\n     * Override to use the extreme coordinates from the SVG shape, not the\n     * data values\n     */\n    wrap(Axis.prototype, 'getSeriesExtremes', function (proceed) {\n        var isXAxis = this.isXAxis,\n            dataMin,\n            dataMax,\n            xData = [],\n            useMapGeometry;\n\n        // Remove the xData array and cache it locally so that the proceed method doesn't use it\n        if (isXAxis) {\n            each(this.series, function (series, i) {\n                if (series.useMapGeometry) {\n                    xData[i] = series.xData;\n                    series.xData = [];\n                }\n            });\n        }\n\n        // Call base to reach normal cartesian series (like mappoint)\n        proceed.call(this);\n\n        // Run extremes logic for map and mapline\n        if (isXAxis) {\n            dataMin = pick(this.dataMin, Number.MAX_VALUE);\n            dataMax = pick(this.dataMax, -Number.MAX_VALUE);\n            each(this.series, function (series, i) {\n                if (series.useMapGeometry) {\n                    dataMin = Math.min(dataMin, pick(series.minX, dataMin));\n                    dataMax = Math.max(dataMax, pick(series.maxX, dataMin));\n                    series.xData = xData[i]; // Reset xData array\n                    useMapGeometry = true;\n                }\n            });\n            if (useMapGeometry) {\n                this.dataMin = dataMin;\n                this.dataMax = dataMax;\n            }\n        }\n    });\n\n    /**\n     * Override axis translation to make sure the aspect ratio is always kept\n     */\n    wrap(Axis.prototype, 'setAxisTranslation', function (proceed) {\n        var chart = this.chart,\n            mapRatio,\n            plotRatio = chart.plotWidth / chart.plotHeight,\n            adjustedAxisLength,\n            xAxis = chart.xAxis[0],\n            padAxis,\n            fixTo,\n            fixDiff,\n            preserveAspectRatio;\n\n\n        // Run the parent method\n        proceed.call(this);\n\n        // Check for map-like series\n        if (this.coll === 'yAxis' && xAxis.transA !== undefined) {\n            each(this.series, function (series) {\n                if (series.preserveAspectRatio) {\n                    preserveAspectRatio = true;\n                }\n            });\n        }\n\n        // On Y axis, handle both\n        if (preserveAspectRatio) {\n\n            // Use the same translation for both axes\n            this.transA = xAxis.transA = Math.min(this.transA, xAxis.transA);\n\n            mapRatio = plotRatio / ((xAxis.max - xAxis.min) / (this.max - this.min));\n\n            // What axis to pad to put the map in the middle\n            padAxis = mapRatio < 1 ? this : xAxis;\n\n            // Pad it\n            adjustedAxisLength = (padAxis.max - padAxis.min) * padAxis.transA;\n            padAxis.pixelPadding = padAxis.len - adjustedAxisLength;\n            padAxis.minPixelPadding = padAxis.pixelPadding / 2;\n\n            fixTo = padAxis.fixTo;\n            if (fixTo) {\n                fixDiff = fixTo[1] - padAxis.toValue(fixTo[0], true);\n                fixDiff *= padAxis.transA;\n                if (Math.abs(fixDiff) > padAxis.minPixelPadding || (padAxis.min === padAxis.dataMin && padAxis.max === padAxis.dataMax)) { // zooming out again, keep within restricted area\n                    fixDiff = 0;\n                }\n                padAxis.minPixelPadding -= fixDiff;\n            }\n        }\n    });\n\n    /**\n     * Override Axis.render in order to delete the fixTo prop\n     */\n    wrap(Axis.prototype, 'render', function (proceed) {\n        proceed.call(this);\n        this.fixTo = null;\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Axis = H.Axis,\n            Chart = H.Chart,\n            Color = H.Color,\n            ColorAxis,\n            each = H.each,\n            extend = H.extend,\n            Legend = H.Legend,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            noop = H.noop,\n            merge = H.merge,\n            pick = H.pick,\n            wrap = H.wrap;\n\n    /**\n     * The ColorAxis object for inclusion in gradient legends\n     */\n    ColorAxis = H.ColorAxis = function () {\n        this.isColorAxis = true;\n        this.init.apply(this, arguments);\n    };\n    extend(ColorAxis.prototype, Axis.prototype);\n    extend(ColorAxis.prototype, {\n        defaultColorAxisOptions: {\n            lineWidth: 0,\n            minPadding: 0,\n            maxPadding: 0,\n            gridLineWidth: 1,\n            tickPixelInterval: 72,\n            startOnTick: true,\n            endOnTick: true,\n            offset: 0,\n            marker: {\n                animation: {\n                    duration: 50\n                },\n                color: 'gray',\n                width: 0.01\n            },\n            labels: {\n                overflow: 'justify'\n            },\n            minColor: '#EFEFFF',\n            maxColor: '#003875',\n            tickLength: 5\n        },\n        init: function (chart, userOptions) {\n            var horiz = chart.options.legend.layout !== 'vertical',\n                options;\n\n            // Build the options\n            options = merge(this.defaultColorAxisOptions, {\n                side: horiz ? 2 : 1,\n                reversed: !horiz\n            }, userOptions, {\n                opposite: !horiz,\n                showEmpty: false,\n                title: null,\n                isColor: true\n            });\n\n            Axis.prototype.init.call(this, chart, options);\n\n            // Base init() pushes it to the xAxis array, now pop it again\n            //chart[this.isXAxis ? 'xAxis' : 'yAxis'].pop();\n\n            // Prepare data classes\n            if (userOptions.dataClasses) {\n                this.initDataClasses(userOptions);\n            }\n            this.initStops(userOptions);\n\n            // Override original axis properties\n            this.horiz = horiz;\n            this.zoomEnabled = false;\n        },\n\n        /*\n         * Return an intermediate color between two colors, according to pos where 0\n         * is the from color and 1 is the to color.\n         * NOTE: Changes here should be copied\n         * to the same function in drilldown.src.js and solid-gauge-src.js.\n         */\n        tweenColors: function (from, to, pos) {\n            // Check for has alpha, because rgba colors perform worse due to lack of\n            // support in WebKit.\n            var hasAlpha,\n                ret;\n\n            // Unsupported color, return to-color (#3920)\n            if (!to.rgba.length || !from.rgba.length) {\n                ret = to.input || 'none';\n\n            // Interpolate\n            } else {\n                from = from.rgba;\n                to = to.rgba;\n                hasAlpha = (to[3] !== 1 || from[3] !== 1);\n                ret = (hasAlpha ? 'rgba(' : 'rgb(') +\n                    Math.round(to[0] + (from[0] - to[0]) * (1 - pos)) + ',' +\n                    Math.round(to[1] + (from[1] - to[1]) * (1 - pos)) + ',' +\n                    Math.round(to[2] + (from[2] - to[2]) * (1 - pos)) +\n                    (hasAlpha ? (',' + (to[3] + (from[3] - to[3]) * (1 - pos))) : '') + ')';\n            }\n            return ret;\n        },\n\n        initDataClasses: function (userOptions) {\n            var axis = this,\n                chart = this.chart,\n                dataClasses,\n                colorCounter = 0,\n                options = this.options,\n                len = userOptions.dataClasses.length;\n            this.dataClasses = dataClasses = [];\n            this.legendItems = [];\n\n            each(userOptions.dataClasses, function (dataClass, i) {\n                var colors;\n\n                dataClass = merge(dataClass);\n                dataClasses.push(dataClass);\n                if (!dataClass.color) {\n                    if (options.dataClassColor === 'category') {\n                        colors = chart.options.colors;\n                        dataClass.color = colors[colorCounter++];\n                        // loop back to zero\n                        if (colorCounter === colors.length) {\n                            colorCounter = 0;\n                        }\n                    } else {\n                        dataClass.color = axis.tweenColors(\n                            Color(options.minColor),\n                            Color(options.maxColor),\n                            len < 2 ? 0.5 : i / (len - 1) // #3219\n                        );\n                    }\n                }\n            });\n        },\n\n        initStops: function (userOptions) {\n            this.stops = userOptions.stops || [\n                [0, this.options.minColor],\n                [1, this.options.maxColor]\n            ];\n            each(this.stops, function (stop) {\n                stop.color = Color(stop[1]);\n            });\n        },\n\n        /**\n         * Extend the setOptions method to process extreme colors and color\n         * stops.\n         */\n        setOptions: function (userOptions) {\n            Axis.prototype.setOptions.call(this, userOptions);\n\n            this.options.crosshair = this.options.marker;\n            this.coll = 'colorAxis';\n        },\n\n        setAxisSize: function () {\n            var symbol = this.legendSymbol,\n                chart = this.chart,\n                x,\n                y,\n                width,\n                height;\n\n            if (symbol) {\n                this.left = x = symbol.attr('x');\n                this.top = y = symbol.attr('y');\n                this.width = width = symbol.attr('width');\n                this.height = height = symbol.attr('height');\n                this.right = chart.chartWidth - x - width;\n                this.bottom = chart.chartHeight - y - height;\n\n                this.len = this.horiz ? width : height;\n                this.pos = this.horiz ? x : y;\n            }\n        },\n\n        /**\n         * Translate from a value to a color\n         */\n        toColor: function (value, point) {\n            var pos,\n                stops = this.stops,\n                from,\n                to,\n                color,\n                dataClasses = this.dataClasses,\n                dataClass,\n                i;\n\n            if (dataClasses) {\n                i = dataClasses.length;\n                while (i--) {\n                    dataClass = dataClasses[i];\n                    from = dataClass.from;\n                    to = dataClass.to;\n                    if ((from === undefined || value >= from) && (to === undefined || value <= to)) {\n                        color = dataClass.color;\n                        if (point) {\n                            point.dataClass = i;\n                        }\n                        break;\n                    }\n                }\n\n            } else {\n\n                if (this.isLog) {\n                    value = this.val2lin(value);\n                }\n                pos = 1 - ((this.max - value) / ((this.max - this.min) || 1));\n                i = stops.length;\n                while (i--) {\n                    if (pos > stops[i][0]) {\n                        break;\n                    }\n                }\n                from = stops[i] || stops[i + 1];\n                to = stops[i + 1] || from;\n\n                // The position within the gradient\n                pos = 1 - (to[0] - pos) / ((to[0] - from[0]) || 1);\n\n                color = this.tweenColors(\n                    from.color,\n                    to.color,\n                    pos\n                );\n            }\n            return color;\n        },\n\n        /**\n         * Override the getOffset method to add the whole axis groups inside the legend.\n         */\n        getOffset: function () {\n            var group = this.legendGroup,\n                sideOffset = this.chart.axisOffset[this.side];\n\n            if (group) {\n\n                // Hook for the getOffset method to add groups to this parent group\n                this.axisParent = group;\n\n                // Call the base\n                Axis.prototype.getOffset.call(this);\n\n                // First time only\n                if (!this.added) {\n\n                    this.added = true;\n\n                    this.labelLeft = 0;\n                    this.labelRight = this.width;\n                }\n                // Reset it to avoid color axis reserving space\n                this.chart.axisOffset[this.side] = sideOffset;\n            }\n        },\n\n        /**\n         * Create the color gradient\n         */\n        setLegendColor: function () {\n            var grad,\n                horiz = this.horiz,\n                options = this.options,\n                reversed = this.reversed,\n                one = reversed ? 1 : 0,\n                zero = reversed ? 0 : 1;\n\n            grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one]; // #3190\n            this.legendColor = {\n                linearGradient: { x1: grad[0], y1: grad[1], x2: grad[2], y2: grad[3] },\n                stops: options.stops || [\n                    [0, options.minColor],\n                    [1, options.maxColor]\n                ]\n            };\n        },\n\n        /**\n         * The color axis appears inside the legend and has its own legend symbol\n         */\n        drawLegendSymbol: function (legend, item) {\n            var padding = legend.padding,\n                legendOptions = legend.options,\n                horiz = this.horiz,\n                width = pick(legendOptions.symbolWidth, horiz ? 200 : 12),\n                height = pick(legendOptions.symbolHeight, horiz ? 12 : 200),\n                labelPadding = pick(legendOptions.labelPadding, horiz ? 16 : 30),\n                itemDistance = pick(legendOptions.itemDistance, 10);\n\n            this.setLegendColor();\n\n            // Create the gradient\n            item.legendSymbol = this.chart.renderer.rect(\n                0,\n                legend.baseline - 11,\n                width,\n                height\n            ).attr({\n                zIndex: 1\n            }).add(item.legendGroup);\n\n            // Set how much space this legend item takes up\n            this.legendItemWidth = width + padding + (horiz ? itemDistance : labelPadding);\n            this.legendItemHeight = height + padding + (horiz ? labelPadding : 0);\n        },\n        /**\n         * Fool the legend\n         */\n        setState: noop,\n        visible: true,\n        setVisible: noop,\n        getSeriesExtremes: function () {\n            var series;\n            if (this.series.length) {\n                series = this.series[0];\n                this.dataMin = series.valueMin;\n                this.dataMax = series.valueMax;\n            }\n        },\n        drawCrosshair: function (e, point) {\n            var plotX = point && point.plotX,\n                plotY = point && point.plotY,\n                crossPos,\n                axisPos = this.pos,\n                axisLen = this.len;\n\n            if (point) {\n                crossPos = this.toPixels(point[point.series.colorKey]);\n                if (crossPos < axisPos) {\n                    crossPos = axisPos - 2;\n                } else if (crossPos > axisPos + axisLen) {\n                    crossPos = axisPos + axisLen + 2;\n                }\n\n                point.plotX = crossPos;\n                point.plotY = this.len - crossPos;\n                Axis.prototype.drawCrosshair.call(this, e, point);\n                point.plotX = plotX;\n                point.plotY = plotY;\n\n                if (this.cross) {\n                    this.cross\n                        .attr({\n                            fill: this.crosshair.color\n                        })\n                        .add(this.legendGroup);\n                }\n            }\n        },\n        getPlotLinePath: function (a, b, c, d, pos) {\n            return typeof pos === 'number' ? // crosshairs only // #3969 pos can be 0 !!\n                (this.horiz ?\n                    ['M', pos - 4, this.top - 6, 'L', pos + 4, this.top - 6, pos, this.top, 'Z'] :\n                    ['M', this.left, pos, 'L', this.left - 6, pos + 6, this.left - 6, pos - 6, 'Z']\n                ) :\n                Axis.prototype.getPlotLinePath.call(this, a, b, c, d);\n        },\n\n        update: function (newOptions, redraw) {\n            var chart = this.chart,\n                legend = chart.legend;\n\n            each(this.series, function (series) {\n                series.isDirtyData = true; // Needed for Axis.update when choropleth colors change\n            });\n\n            // When updating data classes, destroy old items and make sure new ones are created (#3207)\n            if (newOptions.dataClasses && legend.allItems) {\n                each(legend.allItems, function (item) {\n                    if (item.isDataClass) {\n                        item.legendGroup.destroy();\n                    }\n                });\n                chart.isDirtyLegend = true;\n            }\n\n            // Keep the options structure updated for export. Unlike xAxis and yAxis, the colorAxis is\n            // not an array. (#3207)\n            chart.options[this.coll] = merge(this.userOptions, newOptions);\n\n            Axis.prototype.update.call(this, newOptions, redraw);\n            if (this.legendItem) {\n                this.setLegendColor();\n                legend.colorizeItem(this, true);\n            }\n        },\n\n        /**\n         * Get the legend item symbols for data classes\n         */\n        getDataClassLegendSymbols: function () {\n            var axis = this,\n                chart = this.chart,\n                legendItems = this.legendItems,\n                legendOptions = chart.options.legend,\n                valueDecimals = legendOptions.valueDecimals,\n                valueSuffix = legendOptions.valueSuffix || '',\n                name;\n\n            if (!legendItems.length) {\n                each(this.dataClasses, function (dataClass, i) {\n                    var vis = true,\n                        from = dataClass.from,\n                        to = dataClass.to;\n\n                    // Assemble the default name. This can be overridden by legend.options.labelFormatter\n                    name = '';\n                    if (from === undefined) {\n                        name = '< ';\n                    } else if (to === undefined) {\n                        name = '> ';\n                    }\n                    if (from !== undefined) {\n                        name += H.numberFormat(from, valueDecimals) + valueSuffix;\n                    }\n                    if (from !== undefined && to !== undefined) {\n                        name += ' - ';\n                    }\n                    if (to !== undefined) {\n                        name += H.numberFormat(to, valueDecimals) + valueSuffix;\n                    }\n                    // Add a mock object to the legend items\n                    legendItems.push(extend({\n                        chart: chart,\n                        name: name,\n                        options: {},\n                        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n                        visible: true,\n                        setState: noop,\n                        isDataClass: true,\n                        setVisible: function () {\n                            vis = this.visible = !vis;\n                            each(axis.series, function (series) {\n                                each(series.points, function (point) {\n                                    if (point.dataClass === i) {\n                                        point.setVisible(vis);\n                                    }\n                                });\n                            });\n\n                            chart.legend.colorizeItem(this, vis);\n                        }\n                    }, dataClass));\n                });\n            }\n            return legendItems;\n        },\n        name: '' // Prevents 'undefined' in legend in IE8\n    });\n\n    /**\n     * Handle animation of the color attributes directly\n     */\n    each(['fill', 'stroke'], function (prop) {\n        Highcharts.Fx.prototype[prop + 'Setter'] = function () {\n            this.elem.attr(prop, ColorAxis.prototype.tweenColors(Color(this.start), Color(this.end), this.pos));\n        };\n    });\n\n    /**\n     * Extend the chart getAxes method to also get the color axis\n     */\n    wrap(Chart.prototype, 'getAxes', function (proceed) {\n\n        var options = this.options,\n            colorAxisOptions = options.colorAxis;\n\n        proceed.call(this);\n\n        this.colorAxis = [];\n        if (colorAxisOptions) {\n            new ColorAxis(this, colorAxisOptions); // eslint-disable-line no-new\n        }\n    });\n\n\n    /**\n     * Wrap the legend getAllItems method to add the color axis. This also removes the\n     * axis' own series to prevent them from showing up individually.\n     */\n    wrap(Legend.prototype, 'getAllItems', function (proceed) {\n        var allItems = [],\n            colorAxis = this.chart.colorAxis[0];\n\n        if (colorAxis) {\n\n            // Data classes\n            if (colorAxis.options.dataClasses) {\n                allItems = allItems.concat(colorAxis.getDataClassLegendSymbols());\n            // Gradient legend\n            } else {\n                // Add this axis on top\n                allItems.push(colorAxis);\n            }\n\n            // Don't add the color axis' series\n            each(colorAxis.series, function (series) {\n                series.options.showInLegend = false;\n            });\n        }\n\n        return allItems.concat(proceed.call(this));\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var each = H.each,\n            noop = H.noop,\n            seriesTypes = H.seriesTypes;\n\n    /**\n     * Mixin for maps and heatmaps\n     */\n    H.colorPointMixin = {\n        /**\n         * Set the visibility of a single point\n         */\n        setVisible: function (vis) {\n            var point = this,\n                method = vis ? 'show' : 'hide';\n\n            // Show and hide associated elements\n            each(['graphic', 'dataLabel'], function (key) {\n                if (point[key]) {\n                    point[key][method]();\n                }\n            });\n        }\n    };\n\n    H.colorSeriesMixin = {\n        pointArrayMap: ['value'],\n        axisTypes: ['xAxis', 'yAxis', 'colorAxis'],\n        optionalAxis: 'colorAxis',\n        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n        getSymbol: noop,\n        parallelArrays: ['x', 'y', 'value'],\n        colorKey: 'value',\n\n        pointAttribs: seriesTypes.column.prototype.pointAttribs,\n    \n        /**\n         * In choropleth maps, the color is a result of the value, so this needs translation too\n         */\n        translateColors: function () {\n            var series = this,\n                nullColor = this.options.nullColor,\n                colorAxis = this.colorAxis,\n                colorKey = this.colorKey;\n\n            each(this.data, function (point) {\n                var value = point[colorKey],\n                    color;\n\n                color = point.options.color ||\n                    (value === null ? nullColor : (colorAxis && value !== undefined) ? colorAxis.toColor(value, point) : point.color || series.color);\n\n                if (color) {\n                    point.color = color;\n                }\n            });\n        }\n    };\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Color = H.Color,\n            ColorAxis = H.ColorAxis,\n            colorPointMixin = H.colorPointMixin,\n            colorSeriesMixin = H.colorSeriesMixin,\n            defaultPlotOptions = H.defaultPlotOptions,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            splat = H.splat;\n\n    // The vector-effect attribute is not supported in IE <= 11 (at least), so we need\n    // diffent logic (#3218)\n    var supportsVectorEffect = doc.documentElement.style.vectorEffect !== undefined;\n\n    /**\n     * Extend the default options with map options\n     */\n    defaultPlotOptions.map = merge(defaultPlotOptions.scatter, {\n        allAreas: true,\n\n        animation: false, // makes the complex shapes slow\n        nullColor: '#F8F8F8',\n        borderColor: 'silver',\n        borderWidth: 1,\n        marker: null,\n        stickyTracking: false,\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.value;\n            },\n            inside: true, // for the color\n            verticalAlign: 'middle',\n            crop: false,\n            overflow: false,\n            padding: 0\n        },\n        turboThreshold: 0,\n        tooltip: {\n            followPointer: true,\n            pointFormat: '{point.name}: {point.value}<br/>'\n        },\n        states: {\n            normal: {\n                animation: true\n            },\n            hover: {\n                brightness: 0.2,\n                halo: null\n            },\n            select: {\n                color: '#C0C0C0'\n            }\n        }\n    });\n\n    /**\n     * The MapAreaPoint object\n     */\n    var MapAreaPoint = H.MapAreaPoint = extendClass(Point, extend({\n        /**\n         * Extend the Point object to split paths\n         */\n        applyOptions: function (options, x) {\n\n            var point = Point.prototype.applyOptions.call(this, options, x),\n                series = this.series,\n                joinBy = series.joinBy,\n                mapPoint;\n\n            if (series.mapData) {\n                mapPoint = point[joinBy[1]] !== undefined && series.mapMap[point[joinBy[1]]];\n                if (mapPoint) {\n                    // This applies only to bubbles\n                    if (series.xyFromShape) {\n                        point.x = mapPoint._midX;\n                        point.y = mapPoint._midY;\n                    }\n                    extend(point, mapPoint); // copy over properties\n                } else {\n                    point.value = point.value || null;\n                }\n            }\n\n            return point;\n        },\n\n        /**\n         * Stop the fade-out\n         */\n        onMouseOver: function (e) {\n            clearTimeout(this.colorInterval);\n            if (this.value !== null) {\n                Point.prototype.onMouseOver.call(this, e);\n            } else { //#3401 Tooltip doesn't hide when hovering over null points\n                this.series.onMouseOut(e);\n            }\n        },\n        ";
if (build.classic) { 
s += "\n        // Todo: check unstyled\n        /**\n         * Custom animation for tweening out the colors. Animation reduces blinking when hovering\n         * over islands and coast lines. We run a custom implementation of animation becuase we\n         * need to be able to run this independently from other animations like zoom redraw. Also,\n         * adding color animation to the adapters would introduce almost the same amount of code.\n         */\n        onMouseOut: function () {\n            var point = this,\n                start = +new Date(),\n                normalColor = Color(point.color),\n                hoverColor = Color(point.series.pointAttribs(point, 'hover').fill),\n                animation = point.series.options.states.normal.animation,\n                duration = animation && (animation.duration || 500);\n\n            if (duration && normalColor.rgba.length === 4 && hoverColor.rgba.length === 4 && point.state !== 'select') {\n                clearTimeout(point.colorInterval);\n                point.colorInterval = setInterval(function () {\n                    var pos = (new Date() - start) / duration,\n                        graphic = point.graphic;\n                    if (pos > 1) {\n                        pos = 1;\n                    }\n                    if (graphic) {\n                        graphic.attr('fill', ColorAxis.prototype.tweenColors.call(0, hoverColor, normalColor, pos));\n                    }\n                    if (pos >= 1) {\n                        clearTimeout(point.colorInterval);\n                    }\n                }, 13);\n            }\n            point.isFading = true;\n            Point.prototype.onMouseOut.call(point);\n            point.isFading = null;\n        },\n        ";
} 
s += "\n\n        /**\n         * Zoom the chart to view a specific area point\n         */\n        zoomTo: function () {\n            var point = this,\n                series = point.series;\n\n            series.xAxis.setExtremes(\n                point._minX,\n                point._maxX,\n                false\n            );\n            series.yAxis.setExtremes(\n                point._minY,\n                point._maxY,\n                false\n            );\n            series.chart.redraw();\n        }\n    }, colorPointMixin)\n    );\n\n    /**\n     * Add the series type\n     */\n    seriesTypes.map = extendClass(seriesTypes.scatter, merge(colorSeriesMixin, {\n        type: 'map',\n        pointClass: MapAreaPoint,\n        supportsDrilldown: true,\n        getExtremesFromAll: true,\n        useMapGeometry: true, // get axis extremes from paths, not values\n        forceDL: true,\n        searchPoint: noop,\n        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n        preserveAspectRatio: true, // X axis and Y axis must have same translation slope\n        /**\n         * Get the bounding box of all paths in the map combined.\n         */\n        getBox: function (paths) {\n            var MAX_VALUE = Number.MAX_VALUE,\n                maxX = -MAX_VALUE,\n                minX =  MAX_VALUE,\n                maxY = -MAX_VALUE,\n                minY =  MAX_VALUE,\n                minRange = MAX_VALUE,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                hasBox;\n\n            // Find the bounding box\n            each(paths || [], function (point) {\n\n                if (point.path) {\n                    if (typeof point.path === 'string') {\n                        point.path = H.splitPath(point.path);\n                    }\n\n                    var path = point.path || [],\n                        i = path.length,\n                        even = false, // while loop reads from the end\n                        pointMaxX = -MAX_VALUE,\n                        pointMinX =  MAX_VALUE,\n                        pointMaxY = -MAX_VALUE,\n                        pointMinY =  MAX_VALUE,\n                        properties = point.properties;\n\n                    // The first time a map point is used, analyze its box\n                    if (!point._foundBox) {\n                        while (i--) {\n                            if (typeof path[i] === 'number' && !isNaN(path[i])) {\n                                if (even) { // even = x\n                                    pointMaxX = Math.max(pointMaxX, path[i]);\n                                    pointMinX = Math.min(pointMinX, path[i]);\n                                } else { // odd = Y\n                                    pointMaxY = Math.max(pointMaxY, path[i]);\n                                    pointMinY = Math.min(pointMinY, path[i]);\n                                }\n                                even = !even;\n                            }\n                        }\n                        // Cache point bounding box for use to position data labels, bubbles etc\n                        point._midX = pointMinX + (pointMaxX - pointMinX) *\n                            (point.middleX || (properties && properties['hc-middle-x']) || 0.5); // pick is slower and very marginally needed\n                        point._midY = pointMinY + (pointMaxY - pointMinY) *\n                            (point.middleY || (properties && properties['hc-middle-y']) || 0.5);\n                        point._maxX = pointMaxX;\n                        point._minX = pointMinX;\n                        point._maxY = pointMaxY;\n                        point._minY = pointMinY;\n                        point.labelrank = pick(point.labelrank, (pointMaxX - pointMinX) * (pointMaxY - pointMinY));\n                        point._foundBox = true;\n                    }\n\n                    maxX = Math.max(maxX, point._maxX);\n                    minX = Math.min(minX, point._minX);\n                    maxY = Math.max(maxY, point._maxY);\n                    minY = Math.min(minY, point._minY);\n                    minRange = Math.min(point._maxX - point._minX, point._maxY - point._minY, minRange);\n                    hasBox = true;\n                }\n            });\n\n            // Set the box for the whole series\n            if (hasBox) {\n                this.minY = Math.min(minY, pick(this.minY, MAX_VALUE));\n                this.maxY = Math.max(maxY, pick(this.maxY, -MAX_VALUE));\n                this.minX = Math.min(minX, pick(this.minX, MAX_VALUE));\n                this.maxX = Math.max(maxX, pick(this.maxX, -MAX_VALUE));\n\n                // If no minRange option is set, set the default minimum zooming range to 5 times the\n                // size of the smallest element\n                if (xAxis && xAxis.options.minRange === undefined) {\n                    xAxis.minRange = Math.min(5 * minRange, (this.maxX - this.minX) / 5, xAxis.minRange || MAX_VALUE);\n                }\n                if (yAxis && yAxis.options.minRange === undefined) {\n                    yAxis.minRange = Math.min(5 * minRange, (this.maxY - this.minY) / 5, yAxis.minRange || MAX_VALUE);\n                }\n            }\n        },\n\n        getExtremes: function () {\n            // Get the actual value extremes for colors\n            Series.prototype.getExtremes.call(this, this.valueData);\n\n            // Recalculate box on updated data\n            if (this.chart.hasRendered && this.isDirtyData) {\n                this.getBox(this.options.data);\n            }\n\n            this.valueMin = this.dataMin;\n            this.valueMax = this.dataMax;\n\n            // Extremes for the mock Y axis\n            this.dataMin = this.minY;\n            this.dataMax = this.maxY;\n        },\n\n        /**\n         * Translate the path so that it automatically fits into the plot area box\n         * @param {Object} path\n         */\n        translatePath: function (path) {\n\n            var series = this,\n                even = false, // while loop reads from the end\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                xMin = xAxis.min,\n                xTransA = xAxis.transA,\n                xMinPixelPadding = xAxis.minPixelPadding,\n                yMin = yAxis.min,\n                yTransA = yAxis.transA,\n                yMinPixelPadding = yAxis.minPixelPadding,\n                i,\n                ret = []; // Preserve the original\n\n            // Do the translation\n            if (path) {\n                i = path.length;\n                while (i--) {\n                    if (typeof path[i] === 'number') {\n                        ret[i] = even ?\n                            (path[i] - xMin) * xTransA + xMinPixelPadding :\n                            (path[i] - yMin) * yTransA + yMinPixelPadding;\n                        even = !even;\n                    } else {\n                        ret[i] = path[i];\n                    }\n                }\n            }\n\n            return ret;\n        },\n\n        /**\n         * Extend setData to join in mapData. If the allAreas option is true, all areas\n         * from the mapData are used, and those that don't correspond to a data value\n         * are given null values.\n         */\n        setData: function (data, redraw) {\n            var options = this.options,\n                mapData = options.mapData,\n                joinBy = options.joinBy,\n                joinByNull = joinBy === null,\n                dataUsed = [],\n                mapPoint,\n                transform,\n                mapTransforms,\n                props,\n                i;\n\n            if (joinByNull) {\n                joinBy = '_i';\n            }\n            joinBy = this.joinBy = splat(joinBy);\n            if (!joinBy[1]) {\n                joinBy[1] = joinBy[0];\n            }\n\n            // Pick up numeric values, add index\n            if (data) {\n                each(data, function (val, i) {\n                    if (typeof val === 'number') {\n                        data[i] = {\n                            value: val\n                        };\n                    }\n                    if (joinByNull) {\n                        data[i]._i = i;\n                    }\n                });\n            }\n\n            this.getBox(data);\n            if (mapData) {\n                if (mapData.type === 'FeatureCollection') {\n                    if (mapData['hc-transform']) {\n                        this.chart.mapTransforms = mapTransforms = mapData['hc-transform'];\n                        // Cache cos/sin of transform rotation angle\n                        for (transform in mapTransforms) {\n                            if (mapTransforms.hasOwnProperty(transform) && transform.rotation) {\n                                transform.cosAngle = Math.cos(transform.rotation);\n                                transform.sinAngle = Math.sin(transform.rotation);\n                            }\n                        }\n                    }\n                    mapData = H.geojson(mapData, this.type, this);\n                }\n\n                this.getBox(mapData);\n                this.mapData = mapData;\n                this.mapMap = {};\n\n                for (i = 0; i < mapData.length; i++) {\n                    mapPoint = mapData[i];\n                    props = mapPoint.properties;\n\n                    mapPoint._i = i;\n                    // Copy the property over to root for faster access\n                    if (joinBy[0] && props && props[joinBy[0]]) {\n                        mapPoint[joinBy[0]] = props[joinBy[0]];\n                    }\n                    this.mapMap[mapPoint[joinBy[0]]] = mapPoint;\n                }\n\n                if (options.allAreas) {\n\n                    data = data || [];\n\n                    // Registered the point codes that actually hold data\n                    if (joinBy[1]) {\n                        each(data, function (point) {\n                            dataUsed.push(point[joinBy[1]]);\n                        });\n                    }\n\n                    // Add those map points that don't correspond to data, which will be drawn as null points\n                    dataUsed = '|' + dataUsed.join('|') + '|'; // String search is faster than array.indexOf\n\n                    each(mapData, function (mapPoint) {\n                        if (!joinBy[0] || dataUsed.indexOf('|' + mapPoint[joinBy[0]] + '|') === -1) {\n                            data.push(merge(mapPoint, { value: null }));\n                        }\n                    });\n                }\n            }\n            Series.prototype.setData.call(this, data, redraw);\n        },\n\n\n        /**\n         * No graph for the map series\n         */\n        drawGraph: noop,\n\n        /**\n         * We need the points' bounding boxes in order to draw the data labels, so\n         * we skip it now and call it from drawPoints instead.\n         */\n        drawDataLabels: noop,\n\n        /**\n         * Allow a quick redraw by just translating the area group. Used for zooming and panning\n         * in capable browsers.\n         */\n        doFullTranslate: function () {\n            return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;\n        },\n\n        /**\n         * Add the path option for data points. Find the max value for color calculation.\n         */\n        translate: function () {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                doFullTranslate = series.doFullTranslate();\n\n            series.generatePoints();\n\n            each(series.data, function (point) {\n\n                // Record the middle point (loosely based on centroid), determined\n                // by the middleX and middleY options.\n                point.plotX = xAxis.toPixels(point._midX, true);\n                point.plotY = yAxis.toPixels(point._midY, true);\n\n                if (doFullTranslate) {\n\n                    point.shapeType = 'path';\n                    point.shapeArgs = {\n                        d: series.translatePath(point.path)\n                    };\n                }\n            });\n\n            series.translateColors();\n        },\n\n        /**\n         * Get presentational attributes\n         */\n        pointAttribs: function (point, state) {\n            var attr = seriesTypes.column.prototype.pointAttribs.call(this, point, state);\n\n            // Prevent flickering whan called from setState\n            if (point.isFading) {\n                delete attr.fill;\n            }\n\n            // If vector-effect is not supported, we set the stroke-width on the group element\n            // and let all point graphics inherit. That way we don't have to iterate over all \n            // points to update the stroke-width on zooming. TODO: Check unstyled\n            if (supportsVectorEffect) {\n                attr['vector-effect'] = 'non-scaling-stroke';\n            } else {\n                attr['stroke-width'] = 'inherit';\n            }\n\n            return attr;\n        },\n    \n        /** \n         * Use the drawPoints method of column, that is able to handle simple shapeArgs.\n         * Extend it by assigning the tooltip position.\n         */\n        drawPoints: function () {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                group = series.group,\n                chart = series.chart,\n                renderer = chart.renderer,\n                scaleX,\n                scaleY,\n                translateX,\n                translateY,\n                baseTrans = this.baseTrans;\n\n            // Set a group that handles transform during zooming and panning in order to preserve clipping\n            // on series.group\n            if (!series.transformGroup) {\n                series.transformGroup = renderer.g()\n                    .attr({\n                        scaleX: 1,\n                        scaleY: 1\n                    })\n                    .add(group);\n                series.transformGroup.survive = true;\n            }\n\n            // Draw the shapes again\n            if (series.doFullTranslate()) {\n\n                // Individual point actions. TODO: Check unstyled.\n                ";
if (build.classic) { 
s += "\n                if (chart.hasRendered) {\n                    each(series.points, function (point) {\n\n                        // Restore state color on update/redraw (#3529)\n                        if (point.shapeArgs) {\n                            point.shapeArgs.fill = series.pointAttribs(point, point.state).fill;\n                        }\n                    });\n                }\n                ";
} 
s += "\n\n                // Draw them in transformGroup\n                series.group = series.transformGroup;\n                seriesTypes.column.prototype.drawPoints.apply(series);\n                series.group = group; // Reset\n\n                // Add class names\n                each(series.points, function (point) {\n                    if (point.graphic) {\n                        if (point.name) {\n                            point.graphic.addClass('highcharts-name-' + point.name.replace(' ', '-').toLowerCase());\n                        }\n                        if (point.properties && point.properties['hc-key']) {\n                            point.graphic.addClass('highcharts-key-' + point.properties['hc-key'].toLowerCase());\n                        }\n                    }\n                });\n\n                // Set the base for later scale-zooming. The originX and originY properties are the\n                // axis values in the plot area's upper left corner.\n                this.baseTrans = {\n                    originX: xAxis.min - xAxis.minPixelPadding / xAxis.transA,\n                    originY: yAxis.min - yAxis.minPixelPadding / yAxis.transA + (yAxis.reversed ? 0 : yAxis.len / yAxis.transA),\n                    transAX: xAxis.transA,\n                    transAY: yAxis.transA\n                };\n\n                // Reset transformation in case we're doing a full translate (#3789)\n                this.transformGroup.animate({\n                    translateX: 0,\n                    translateY: 0,\n                    scaleX: 1,\n                    scaleY: 1\n                });\n\n            // Just update the scale and transform for better performance\n            } else {\n                scaleX = xAxis.transA / baseTrans.transAX;\n                scaleY = yAxis.transA / baseTrans.transAY;\n                translateX = xAxis.toPixels(baseTrans.originX, true);\n                translateY = yAxis.toPixels(baseTrans.originY, true);\n\n                // Handle rounding errors in normal view (#3789)\n                if (scaleX > 0.99 && scaleX < 1.01 && scaleY > 0.99 && scaleY < 1.01) {\n                    scaleX = 1;\n                    scaleY = 1;\n                    translateX = Math.round(translateX);\n                    translateY = Math.round(translateY);\n                }\n\n                this.transformGroup.animate({\n                    translateX: translateX,\n                    translateY: translateY,\n                    scaleX: scaleX,\n                    scaleY: scaleY\n                });\n\n            }\n\n            // Set the stroke-width directly on the group element so the children inherit it. We need to use\n            // setAttribute directly, because the stroke-widthSetter method expects a stroke color also to be\n            // set.\n            if (!supportsVectorEffect) {\n                series.group.element.setAttribute('stroke-width', series.options.borderWidth / (scaleX || 1));\n            }\n\n            this.drawMapDataLabels();\n\n\n        },\n\n        /**\n         * Draw the data labels. Special for maps is the time that the data labels are drawn (after points),\n         * and the clipping of the dataLabelsGroup.\n         */\n        drawMapDataLabels: function () {\n\n            Series.prototype.drawDataLabels.call(this);\n            if (this.dataLabelsGroup) {\n                this.dataLabelsGroup.clip(this.chart.clipRect);\n            }\n        },\n\n        /**\n         * Override render to throw in an async call in IE8. Otherwise it chokes on the US counties demo.\n         */\n        render: function () {\n            var series = this,\n                render = Series.prototype.render;\n\n            // Give IE8 some time to breathe.\n            if (series.chart.renderer.isVML && series.data.length > 3000) {\n                setTimeout(function () {\n                    render.call(series);\n                });\n            } else {\n                render.call(series);\n            }\n        },\n\n        /**\n         * The initial animation for the map series. By default, animation is disabled.\n         * Animation of map shapes is not at all supported in VML browsers.\n         */\n        animate: function (init) {\n            var chart = this.chart,\n                animation = this.options.animation,\n                group = this.group,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                left = xAxis.pos,\n                top = yAxis.pos;\n\n            if (chart.renderer.isSVG) {\n\n                if (animation === true) {\n                    animation = {\n                        duration: 1000\n                    };\n                }\n\n                // Initialize the animation\n                if (init) {\n\n                    // Scale down the group and place it in the center\n                    group.attr({\n                        translateX: left + xAxis.len / 2,\n                        translateY: top + yAxis.len / 2,\n                        scaleX: 0.001, // #1499\n                        scaleY: 0.001\n                    });\n\n                // Run the animation\n                } else {\n                    group.animate({\n                        translateX: left,\n                        translateY: top,\n                        scaleX: 1,\n                        scaleY: 1\n                    }, animation);\n\n                    // Delete this function to allow it only once\n                    this.animate = null;\n                }\n            }\n        },\n\n        /**\n         * Animate in the new series from the clicked point in the old series.\n         * Depends on the drilldown.js module\n         */\n        animateDrilldown: function (init) {\n            var toBox = this.chart.plotBox,\n                level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],\n                fromBox = level.bBox,\n                animationOptions = this.chart.options.drilldown.animation,\n                scale;\n\n            if (!init) {\n\n                scale = Math.min(fromBox.width / toBox.width, fromBox.height / toBox.height);\n                level.shapeArgs = {\n                    scaleX: scale,\n                    scaleY: scale,\n                    translateX: fromBox.x,\n                    translateY: fromBox.y\n                };\n\n                each(this.points, function (point) {\n                    if (point.graphic) {\n                        point.graphic\n                            .attr(level.shapeArgs)\n                            .animate({\n                                scaleX: 1,\n                                scaleY: 1,\n                                translateX: 0,\n                                translateY: 0\n                            }, animationOptions);\n                    }\n                });\n\n                this.animate = null;\n            }\n\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n        /**\n         * When drilling up, pull out the individual point graphics from the lower series\n         * and animate them into the origin point in the upper series.\n         */\n        animateDrillupFrom: function (level) {\n            seriesTypes.column.prototype.animateDrillupFrom.call(this, level);\n        },\n\n\n        /**\n         * When drilling up, keep the upper series invisible until the lower series has\n         * moved into place\n         */\n        animateDrillupTo: function (init) {\n            seriesTypes.column.prototype.animateDrillupTo.call(this, init);\n        }\n    }));\n\n        return H;\n    }(Highcharts));\n    /**\n     * Highcharts module to hide overlapping data labels. This module is included in Highcharts.\n     */\n    (function (H) {\n        var Chart = H.Chart,\n            each = H.each,\n            pick = H.pick,\n            addEvent = H.addEvent;\n\n        // Collect potensial overlapping data labels. Stack labels probably don't need to be \n        // considered because they are usually accompanied by data labels that lie inside the columns.\n        Chart.prototype.callbacks.push(function (chart) {\n            function collectAndHide() {\n                var labels = [];\n\n                each(chart.series, function (series) {\n                    var dlOptions = series.options.dataLabels,\n                        collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections\n                    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n                        each(collections, function (coll) {\n                            each(series.points, function (point) {\n                                if (point[coll]) {\n                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118\n                                    labels.push(point[coll]);\n                                }\n                            });\n                        });\n                    }\n                });\n                chart.hideOverlappingLabels(labels);\n            }\n\n            // Do it now ...\n            collectAndHide();\n\n            // ... and after each chart redraw\n            addEvent(chart, 'redraw', collectAndHide);\n\n        });\n\n        /**\n         * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n         * visual imression.\n         */    \n        Chart.prototype.hideOverlappingLabels = function (labels) {\n\n            var len = labels.length,\n                label,\n                i,\n                j,\n                label1,\n                label2,\n                isIntersecting,\n                pos1,\n                pos2,\n                parent1,\n                parent2,\n                padding,\n                intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {\n                    return !(\n                        x2 > x1 + w1 ||\n                        x2 + w2 < x1 ||\n                        y2 > y1 + h1 ||\n                        y2 + h2 < y1\n                    );\n                };\n    \n            // Mark with initial opacity\n            for (i = 0; i < len; i++) {\n                label = labels[i];\n                if (label) {\n                    label.oldOpacity = label.opacity;\n                    label.newOpacity = 1;\n                }\n            }\n\n            // Prevent a situation in a gradually rising slope, that each label\n            // will hide the previous one because the previous one always has\n            // lower rank.\n            labels.sort(function (a, b) {\n                return (b.labelrank || 0) - (a.labelrank || 0);\n            });\n\n            // Detect overlapping labels\n            for (i = 0; i < len; i++) {\n                label1 = labels[i];\n\n                for (j = i + 1; j < len; ++j) {\n                    label2 = labels[j];\n                    if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {\n                        pos1 = label1.alignAttr;\n                        pos2 = label2.alignAttr;\n                        parent1 = label1.parentGroup; // Different panes have different positions\n                        parent2 = label2.parentGroup;\n                        padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)\n                        isIntersecting = intersectRect(\n                            pos1.x + parent1.translateX,\n                            pos1.y + parent1.translateY,\n                            label1.width - padding,\n                            label1.height - padding,\n                            pos2.x + parent2.translateX,\n                            pos2.y + parent2.translateY,\n                            label2.width - padding,\n                            label2.height - padding\n                        );\n\n                        if (isIntersecting) {\n                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n                        }\n                    }\n                }\n            }\n\n            // Hide or show\n            each(labels, function (label) {\n                var complete,\n                    newOpacity;\n\n                if (label) {\n                    newOpacity = label.newOpacity;\n\n                    if (label.oldOpacity !== newOpacity && label.placed) {\n\n                        // Make sure the label is completely hidden to avoid catching clicks (#4362)\n                        if (newOpacity) {\n                            label.show(true);\n                        } else {\n                            complete = function () {\n                                label.hide();\n                            };\n                        }\n\n                        // Animate or set the opacity                \n                        label.alignAttr.opacity = newOpacity;\n                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n                    \n                    }\n                    label.isOld = true;\n                }\n            });\n        };\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            merge = H.merge,\n            pick = H.pick,\n            wrap = H.wrap;\n\n    // Add events to the Chart object itself\n    extend(Chart.prototype, {\n        renderMapNavigation: function () {\n            var chart = this,\n                options = this.options.mapNavigation,\n                buttons = options.buttons,\n                n,\n                button,\n                buttonOptions,\n                attr,\n                states,\n                stopEvent = function (e) {\n                    if (e) {\n                        if (e.preventDefault) {\n                            e.preventDefault();\n                        }\n                        if (e.stopPropagation) {\n                            e.stopPropagation();\n                        }\n                        e.cancelBubble = true;\n                    }\n                },\n                outerHandler = function (e) {\n                    this.handler.call(chart, e);\n                    stopEvent(e); // Stop default click event (#4444)\n                };\n\n            if (pick(options.enableButtons, options.enabled) && !chart.renderer.forExport) {\n                for (n in buttons) {\n                    if (buttons.hasOwnProperty(n)) {\n                        buttonOptions = merge(options.buttonOptions, buttons[n]);\n                        attr = buttonOptions.theme;\n                        attr.style = merge(buttonOptions.theme.style, buttonOptions.style); // #3203\n                        states = attr.states;\n                        button = chart.renderer.button(\n                                buttonOptions.text,\n                                0,\n                                0,\n                                outerHandler,\n                                attr,\n                                states && states.hover,\n                                states && states.select,\n                                0,\n                                n === 'zoomIn' ? 'topbutton' : 'bottombutton'\n                            )\n                            .attr({\n                                width: buttonOptions.width,\n                                height: buttonOptions.height,\n                                title: chart.options.lang[n],\n                                zIndex: 5\n                            })\n                            .add();\n                        button.handler = buttonOptions.onclick;\n                        button.align(extend(buttonOptions, { width: button.width, height: 2 * button.height }), null, buttonOptions.alignTo);\n                        addEvent(button.element, 'dblclick', stopEvent); // Stop double click event (#4444)\n                    }\n                }\n            }\n        },\n\n        /**\n         * Fit an inner box to an outer. If the inner box overflows left or right, align it to the sides of the\n         * outer. If it overflows both sides, fit it within the outer. This is a pattern that occurs more places\n         * in Highcharts, perhaps it should be elevated to a common utility function.\n         */\n        fitToBox: function (inner, outer) {\n            each([['x', 'width'], ['y', 'height']], function (dim) {\n                var pos = dim[0],\n                    size = dim[1];\n\n                if (inner[pos] + inner[size] > outer[pos] + outer[size]) { // right overflow\n                    if (inner[size] > outer[size]) { // the general size is greater, fit fully to outer\n                        inner[size] = outer[size];\n                        inner[pos] = outer[pos];\n                    } else { // align right\n                        inner[pos] = outer[pos] + outer[size] - inner[size];\n                    }\n                }\n                if (inner[size] > outer[size]) {\n                    inner[size] = outer[size];\n                }\n                if (inner[pos] < outer[pos]) {\n                    inner[pos] = outer[pos];\n                }\n            });\n\n\n            return inner;\n        },\n\n        /**\n         * Zoom the map in or out by a certain amount. Less than 1 zooms in, greater than 1 zooms out.\n         */\n        mapZoom: function (howMuch, centerXArg, centerYArg, mouseX, mouseY) {\n            /*if (this.isMapZooming) {\n                this.mapZoomQueue = arguments;\n                return;\n            }*/\n\n            var chart = this,\n                xAxis = chart.xAxis[0],\n                xRange = xAxis.max - xAxis.min,\n                centerX = pick(centerXArg, xAxis.min + xRange / 2),\n                newXRange = xRange * howMuch,\n                yAxis = chart.yAxis[0],\n                yRange = yAxis.max - yAxis.min,\n                centerY = pick(centerYArg, yAxis.min + yRange / 2),\n                newYRange = yRange * howMuch,\n                fixToX = mouseX ? ((mouseX - xAxis.pos) / xAxis.len) : 0.5,\n                fixToY = mouseY ? ((mouseY - yAxis.pos) / yAxis.len) : 0.5,\n                newXMin = centerX - newXRange * fixToX,\n                newYMin = centerY - newYRange * fixToY,\n                newExt = chart.fitToBox({\n                    x: newXMin,\n                    y: newYMin,\n                    width: newXRange,\n                    height: newYRange\n                }, {\n                    x: xAxis.dataMin,\n                    y: yAxis.dataMin,\n                    width: xAxis.dataMax - xAxis.dataMin,\n                    height: yAxis.dataMax - yAxis.dataMin\n                });\n\n            // When mousewheel zooming, fix the point under the mouse\n            if (mouseX) {\n                xAxis.fixTo = [mouseX - xAxis.pos, centerXArg];\n            }\n            if (mouseY) {\n                yAxis.fixTo = [mouseY - yAxis.pos, centerYArg];\n            }\n\n            // Zoom\n            if (howMuch !== undefined) {\n                xAxis.setExtremes(newExt.x, newExt.x + newExt.width, false);\n                yAxis.setExtremes(newExt.y, newExt.y + newExt.height, false);\n\n            // Reset zoom\n            } else {\n                xAxis.setExtremes(undefined, undefined, false);\n                yAxis.setExtremes(undefined, undefined, false);\n            }\n\n            // Prevent zooming until this one is finished animating\n            /*chart.holdMapZoom = true;\n            setTimeout(function () {\n                chart.holdMapZoom = false;\n            }, 200);*/\n            /*delay = animation ? animation.duration || 500 : 0;\n            if (delay) {\n                chart.isMapZooming = true;\n                setTimeout(function () {\n                    chart.isMapZooming = false;\n                    if (chart.mapZoomQueue) {\n                        chart.mapZoom.apply(chart, chart.mapZoomQueue);\n                    }\n                    chart.mapZoomQueue = null;\n                }, delay);\n            }*/\n\n            chart.redraw();\n        }\n    });\n\n    /**\n     * Extend the Chart.render method to add zooming and panning\n     */\n    wrap(Chart.prototype, 'render', function (proceed) {\n        var chart = this,\n            mapNavigation = chart.options.mapNavigation;\n\n        // Render the plus and minus buttons. Doing this before the shapes makes getBBox much quicker, at least in Chrome.\n        chart.renderMapNavigation();\n\n        proceed.call(chart);\n\n        // Add the double click event\n        if (pick(mapNavigation.enableDoubleClickZoom, mapNavigation.enabled) || mapNavigation.enableDoubleClickZoomTo) {\n            addEvent(chart.container, 'dblclick', function (e) {\n                chart.pointer.onContainerDblClick(e);\n            });\n        }\n\n        // Add the mousewheel event\n        if (pick(mapNavigation.enableMouseWheelZoom, mapNavigation.enabled)) {\n            addEvent(chart.container, doc.onmousewheel === undefined ? 'DOMMouseScroll' : 'mousewheel', function (e) {\n                chart.pointer.onContainerMouseWheel(e);\n                return false;\n            });\n        }\n    });\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var extend = H.extend,\n            pick = H.pick,\n            Pointer = H.Pointer,\n            wrap = H.wrap;\n        \n    // Extend the Pointer\n    extend(Pointer.prototype, {\n\n        /**\n         * The event handler for the doubleclick event\n         */\n        onContainerDblClick: function (e) {\n            var chart = this.chart;\n\n            e = this.normalize(e);\n\n            if (chart.options.mapNavigation.enableDoubleClickZoomTo) {\n                if (chart.pointer.inClass(e.target, 'highcharts-tracker')) {\n                    chart.hoverPoint.zoomTo();\n                }\n            } else if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                chart.mapZoom(\n                    0.5,\n                    chart.xAxis[0].toValue(e.chartX),\n                    chart.yAxis[0].toValue(e.chartY),\n                    e.chartX,\n                    e.chartY\n                );\n            }\n        },\n\n        /**\n         * The event handler for the mouse scroll event\n         */\n        onContainerMouseWheel: function (e) {\n            var chart = this.chart,\n                delta;\n\n            e = this.normalize(e);\n\n            // Firefox uses e.detail, WebKit and IE uses wheelDelta\n            delta = e.detail || -(e.wheelDelta / 120);\n            if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                chart.mapZoom(\n                    //delta > 0 ? 2 : 0.5,\n                    Math.pow(2, delta),\n                    chart.xAxis[0].toValue(e.chartX),\n                    chart.yAxis[0].toValue(e.chartY),\n                    e.chartX,\n                    e.chartY\n                );\n            }\n        }\n    });\n\n    // Implement the pinchType option\n    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n\n        proceed.call(this, chart, options);\n\n        // Pinch status\n        if (pick(options.mapNavigation.enableTouchZoom, options.mapNavigation.enabled)) {\n            this.pinchX = this.pinchHor = this.pinchY = this.pinchVert = this.hasZoom = true;\n        }\n    });\n\n    // Extend the pinchTranslate method to preserve fixed ratio when zooming\n    wrap(Pointer.prototype, 'pinchTranslate', function (proceed, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n        var xBigger;\n        proceed.call(this, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n        // Keep ratio\n        if (this.chart.options.chart.type === 'map' && this.hasZoom) {\n            xBigger = transform.scaleX > transform.scaleY;\n            this.pinchTranslateDirection(\n                !xBigger,\n                pinchDown,\n                touches,\n                transform,\n                selectionMarker,\n                clip,\n                lastValidTouch,\n                xBigger ? transform.scaleX : transform.scaleY\n            );\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            seriesTypes = H.seriesTypes;\n\n    // The mapline series type\n    defaultPlotOptions.mapline = merge(defaultPlotOptions.map, {\n        lineWidth: 1,\n        fillColor: 'none'\n    });\n    seriesTypes.mapline = extendClass(seriesTypes.map, {\n        type: 'mapline',\n        pointAttrToOptions: {\n            'stroke-width': 'lineWidth'\n        },\n        /**\n         * Get presentational attributes\n         */\n        pointAttribs: function (point, state) {\n            var attr = seriesTypes.map.prototype.pointAttribs.call(this, point, state);\n\n            // The difference from a map series is that the stroke takes the point color\n            attr.stroke = attr.fill;\n            attr.fill = this.options.fillColor;\n\n            return attr;\n        },\n        drawLegendSymbol: seriesTypes.line.prototype.drawLegendSymbol\n    });\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            Point = H.Point,\n            seriesTypes = H.seriesTypes;\n\n    // The mappoint series type\n    defaultPlotOptions.mappoint = merge(defaultPlotOptions.scatter, {\n        dataLabels: {\n            enabled: true,\n            formatter: function () { // #2945\n                return this.point.name;\n            },\n            crop: false,\n            defer: false,\n            overflow: false,\n            style: {\n                color: '#000000'\n            }\n        }\n    });\n    seriesTypes.mappoint = extendClass(seriesTypes.scatter, {\n        type: 'mappoint',\n        forceDL: true,\n        pointClass: extendClass(Point, {\n            applyOptions: function (options, x) {\n                var point = Point.prototype.applyOptions.call(this, options, x);\n                if (options.lat !== undefined && options.lon !== undefined) {\n                    point = extend(point, this.series.chart.fromLatLonToPoint(point));\n                }\n                return point;\n            }\n        })\n    });\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            defaultPlotOptions = H.defaultPlotOptions,\n            Axis = H.Axis,\n            Color = H.Color,\n            each = H.each,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            pInt = H.pInt,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes;\n\n    /* ****************************************************************************\n     * Start Bubble series code                                                      *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.bubble = merge(defaultPlotOptions.scatter, {\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.z;\n            },\n            inside: true,\n            verticalAlign: 'middle'\n        },\n        // displayNegative: true,\n        marker: {\n            // fillOpacity: 0.5,\n            lineColor: null, // inherit from series.color\n            lineWidth: 1\n        },\n        minSize: 8,\n        maxSize: '20%',\n        // negativeColor: null,\n        // sizeBy: 'area'\n        softThreshold: false,\n        states: {\n            hover: {\n                halo: {\n                    size: 5\n                }\n            }\n        },\n        tooltip: {\n            pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: 'z'\n    });\n\n    var BubblePoint = extendClass(Point, {\n        haloPath: function () {\n            return Point.prototype.haloPath.call(this, this.shapeArgs.r + this.series.options.states.hover.halo.size);\n        },\n        ttBelow: false\n    });\n\n    // 2 - Create the series object\n    seriesTypes.bubble = extendClass(seriesTypes.scatter, {\n        type: 'bubble',\n        pointClass: BubblePoint,\n        pointArrayMap: ['y', 'z'],\n        parallelArrays: ['x', 'y', 'z'],\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        bubblePadding: true,\n        zoneAxis: 'z',\n    \n        pointAttribs: function (point, state) {\n            var markerOptions = this.options.marker,\n                fillOpacity = pick(markerOptions.fillOpacity, 0.5),\n                attr = Series.prototype.pointAttribs.call(this, point, state);\n\n            if (fillOpacity !== 1) {\n                attr.fill = Color(attr.fill).setOpacity(fillOpacity).get('rgba');\n            }\n\n            return attr;\n        },\n\n        /**\n         * Get the radius for each point based on the minSize, maxSize and each point's Z value. This\n         * must be done prior to Series.translate because the axis needs to add padding in\n         * accordance with the point sizes.\n         */\n        getRadii: function (zMin, zMax, minSize, maxSize) {\n            var len,\n                i,\n                pos,\n                zData = this.zData,\n                radii = [],\n                options = this.options,\n                sizeByArea = options.sizeBy !== 'width',\n                zThreshold = options.zThreshold,\n                zRange = zMax - zMin,\n                value,\n                radius;\n\n            // Set the shape type and arguments to be picked up in drawPoints\n            for (i = 0, len = zData.length; i < len; i++) {\n\n                value = zData[i];\n\n                // When sizing by threshold, the absolute value of z determines the size\n                // of the bubble.\n                if (options.sizeByAbsoluteValue && value !== null) {\n                    value = Math.abs(value - zThreshold);\n                    zMax = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                    zMin = 0;\n                }\n\n                if (value === null) {\n                    radius = null;\n                // Issue #4419 - if value is less than zMin, push a radius that's always smaller than the minimum size\n                } else if (value < zMin) {\n                    radius = minSize / 2 - 1;\n                } else {\n                    // Relative size, a number between 0 and 1\n                    pos = zRange > 0 ? (value - zMin) / zRange : 0.5;\n\n                    if (sizeByArea && pos >= 0) {\n                        pos = Math.sqrt(pos);\n                    }\n                    radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n                }\n                radii.push(radius);\n            }\n            this.radii = radii;\n        },\n\n        /**\n         * Perform animation on the bubbles\n         */\n        animate: function (init) {\n            var animation = this.options.animation;\n\n            if (!init) { // run the animation\n                each(this.points, function (point) {\n                    var graphic = point.graphic,\n                        shapeArgs = point.shapeArgs;\n\n                    if (graphic && shapeArgs) {\n                        // start values\n                        graphic.attr('r', 1);\n\n                        // animate\n                        graphic.animate({\n                            r: shapeArgs.r\n                        }, animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                this.animate = null;\n            }\n        },\n\n        /**\n         * Extend the base translate method to handle bubble size\n         */\n        translate: function () {\n\n            var i,\n                data = this.data,\n                point,\n                radius,\n                radii = this.radii;\n\n            // Run the parent method\n            seriesTypes.scatter.prototype.translate.call(this);\n\n            // Set the shape type and arguments to be picked up in drawPoints\n            i = data.length;\n\n            while (i--) {\n                point = data[i];\n                radius = radii ? radii[i] : 0; // #1737\n\n                if (typeof radius === 'number' && radius >= this.minPxSize / 2) {\n                    // Shape arguments\n                    point.shapeType = 'circle';\n                    point.shapeArgs = {\n                        x: point.plotX,\n                        y: point.plotY,\n                        r: radius\n                    };\n\n                    // Alignment box for the data label\n                    point.dlBox = {\n                        x: point.plotX - radius,\n                        y: point.plotY - radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    };\n                } else { // below zThreshold\n                    point.shapeArgs = point.plotY = point.dlBox = undefined; // #1691\n                }\n            }\n        },\n\n        /**\n         * Get the series' symbol in the legend\n         *\n         * @param {Object} legend The legend object\n         * @param {Object} item The series (this) or point\n         */\n        drawLegendSymbol: function (legend, item) {\n            var renderer = this.chart.renderer,\n                radius = renderer.fontMetrics(legend.itemStyle.fontSize).f / 2;\n\n            item.legendSymbol = renderer.circle(\n                radius,\n                legend.baseline - radius,\n                radius\n            ).attr({\n                zIndex: 3\n            }).add(item.legendGroup);\n            item.legendSymbol.isMarker = true;\n\n        },\n\n        drawPoints: seriesTypes.column.prototype.drawPoints,\n        alignDataLabel: seriesTypes.column.prototype.alignDataLabel,\n        buildKDTree: noop,\n        applyZones: noop\n    });\n\n    /**\n     * Add logic to pad each axis with the amount of pixels\n     * necessary to avoid the bubbles to overflow.\n     */\n    Axis.prototype.beforePadding = function () {\n        var axis = this,\n            axisLength = this.len,\n            chart = this.chart,\n            pxMin = 0,\n            pxMax = axisLength,\n            isXAxis = this.isXAxis,\n            dataKey = isXAxis ? 'xData' : 'yData',\n            min = this.min,\n            extremes = {},\n            smallestSize = Math.min(chart.plotWidth, chart.plotHeight),\n            zMin = Number.MAX_VALUE,\n            zMax = -Number.MAX_VALUE,\n            range = this.max - min,\n            transA = axisLength / range,\n            activeSeries = [];\n\n        // Handle padding on the second pass, or on redraw\n        each(this.series, function (series) {\n\n            var seriesOptions = series.options,\n                zData;\n\n            if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {\n\n                // Correction for #1673\n                axis.allowZoomOutside = true;\n\n                // Cache it\n                activeSeries.push(series);\n\n                if (isXAxis) { // because X axis is evaluated first\n\n                    // For each series, translate the size extremes to pixel values\n                    each(['minSize', 'maxSize'], function (prop) {\n                        var length = seriesOptions[prop],\n                            isPercent = /%$/.test(length);\n\n                        length = pInt(length);\n                        extremes[prop] = isPercent ?\n                            smallestSize * length / 100 :\n                            length;\n\n                    });\n                    series.minPxSize = extremes.minSize;\n                    series.maxPxSize = extremes.maxSize;\n\n                    // Find the min and max Z\n                    zData = series.zData;\n                    if (zData.length) { // #1735\n                        zMin = pick(seriesOptions.zMin, Math.min(\n                            zMin,\n                            Math.max(\n                                arrayMin(zData), \n                                seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE\n                            )\n                        ));\n                        zMax = pick(seriesOptions.zMax, Math.max(zMax, arrayMax(zData)));\n                    }\n                }\n            }\n        });\n\n        each(activeSeries, function (series) {\n\n            var data = series[dataKey],\n                i = data.length,\n                radius;\n\n            if (isXAxis) {\n                series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);\n            }\n\n            if (range > 0) {\n                while (i--) {\n                    if (typeof data[i] === 'number') {\n                        radius = series.radii[i];\n                        pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                        pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                    }\n                }\n            }\n        });\n\n        if (activeSeries.length && range > 0 && !this.isLog) {\n            pxMax -= axisLength;\n            transA *= (axisLength + pxMin - pxMax) / axisLength;\n            each([['min', 'userMin', pxMin], ['max', 'userMax', pxMax]], function (keys) {\n                if (pick(axis.options[keys[0]], axis[keys[1]]) === undefined) {\n                    axis[keys[0]] += keys[2] / transA; \n                }\n            });\n        }\n    };\n\n    /* ****************************************************************************\n     * End Bubble series code                                                     *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            MapAreaPoint = H.MapAreaPoint,\n            merge = H.merge,\n            Point = H.Point,\n            seriesTypes = H.seriesTypes;\n\n    // The mapbubble series type\n    if (seriesTypes.bubble) {\n\n        defaultPlotOptions.mapbubble = merge(defaultPlotOptions.bubble, {\n            animationLimit: 500,\n            tooltip: {\n                pointFormat: '{point.name}: {point.z}'\n            }\n        });\n        seriesTypes.mapbubble = extendClass(seriesTypes.bubble, {\n            pointClass: extendClass(Point, {\n                applyOptions: function (options, x) {\n                    var point;\n                    if (options && options.lat !== undefined && options.lon !== undefined) {\n                        point = Point.prototype.applyOptions.call(this, options, x);\n                        point = extend(point, this.series.chart.fromLatLonToPoint(point));\n                    } else {\n                        point = MapAreaPoint.prototype.applyOptions.call(this, options, x);\n                    }\n                    return point;\n                },\n                ttBelow: false\n            }),\n            xyFromShape: true,\n            type: 'mapbubble',\n            pointArrayMap: ['z'], // If one single value is passed, it is interpreted as z\n            /**\n             * Return the map area identified by the dataJoinBy option\n             */\n            getMapData: seriesTypes.map.prototype.getMapData,\n            getBox: seriesTypes.map.prototype.getBox,\n            setData: seriesTypes.map.prototype.setData\n        });\n    }\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultOptions = H.defaultOptions,\n            Chart = H.Chart,\n            each = H.each,\n            extend = H.extend,\n            error = H.error,\n            win = H.win,\n            wrap = H.wrap;\n    /** \n     * Test for point in polygon. Polygon defined as array of [x,y] points.\n     */\n    function pointInPolygon(point, polygon) {\n        var i, j, rel1, rel2, c = false,\n            x = point.x,\n            y = point.y;\n\n        for (i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n            rel1 = polygon[i][1] > y;\n            rel2 = polygon[j][1] > y;\n            if (rel1 !== rel2 && (x < (polygon[j][0] - polygon[i][0]) * (y - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0])) {\n                c = !c;\n            }\n        }\n\n        return c;\n    }\n\n    /**\n     * Get point from latLon using specified transform definition\n     */\n    Chart.prototype.transformFromLatLon = function (latLon, transform) {\n        if (win.proj4 === undefined) {\n            error(21);\n            return {\n                x: 0,\n                y: null\n            };\n        }\n\n        var projected = win.proj4(transform.crs, [latLon.lon, latLon.lat]),\n            cosAngle = transform.cosAngle || (transform.rotation && Math.cos(transform.rotation)),\n            sinAngle = transform.sinAngle || (transform.rotation && Math.sin(transform.rotation)),\n            rotated = transform.rotation ? [projected[0] * cosAngle + projected[1] * sinAngle, -projected[0] * sinAngle + projected[1] * cosAngle] : projected;\n\n        return {\n            x: ((rotated[0] - (transform.xoffset || 0)) * (transform.scale || 1) + (transform.xpan || 0)) * (transform.jsonres || 1) + (transform.jsonmarginX || 0),\n            y: (((transform.yoffset || 0) - rotated[1]) * (transform.scale || 1) + (transform.ypan || 0)) * (transform.jsonres || 1) - (transform.jsonmarginY || 0)\n        };\n    };\n\n    /**\n     * Get latLon from point using specified transform definition\n     */\n    Chart.prototype.transformToLatLon = function (point, transform) {\n        if (win.proj4 === undefined) {\n            error(21);\n            return;\n        }\n\n        var normalized = {\n                x: ((point.x - (transform.jsonmarginX || 0)) / (transform.jsonres || 1) - (transform.xpan || 0)) / (transform.scale || 1) + (transform.xoffset || 0),\n                y: ((-point.y - (transform.jsonmarginY || 0)) / (transform.jsonres || 1) + (transform.ypan || 0)) / (transform.scale || 1) + (transform.yoffset || 0)\n            },\n            cosAngle = transform.cosAngle || (transform.rotation && Math.cos(transform.rotation)),\n            sinAngle = transform.sinAngle || (transform.rotation && Math.sin(transform.rotation)),\n            // Note: Inverted sinAngle to reverse rotation direction\n            projected = win.proj4(transform.crs, 'WGS84', transform.rotation ? {\n                x: normalized.x * cosAngle + normalized.y * -sinAngle,\n                y: normalized.x * sinAngle + normalized.y * cosAngle\n            } : normalized);\n\n        return { lat: projected.y, lon: projected.x };\n    };\n\n    Chart.prototype.fromPointToLatLon = function (point) {\n        var transforms = this.mapTransforms,\n            transform;\n\n        if (!transforms) {\n            error(22);\n            return;\n        }\n\n        for (transform in transforms) {\n            if (transforms.hasOwnProperty(transform) && transforms[transform].hitZone && \n                    pointInPolygon({ x: point.x, y: -point.y }, transforms[transform].hitZone.coordinates[0])) {\n                return this.transformToLatLon(point, transforms[transform]);\n            }\n        }\n\n        return this.transformToLatLon(point, transforms['default']); // eslint-disable-line dot-notation\n    };\n\n    Chart.prototype.fromLatLonToPoint = function (latLon) {\n        var transforms = this.mapTransforms,\n            transform,\n            coords;\n\n        if (!transforms) {\n            error(22);\n            return {\n                x: 0,\n                y: null\n            };\n        }\n\n        for (transform in transforms) {\n            if (transforms.hasOwnProperty(transform) && transforms[transform].hitZone) {\n                coords = this.transformFromLatLon(latLon, transforms[transform]);\n                if (pointInPolygon({ x: coords.x, y: -coords.y }, transforms[transform].hitZone.coordinates[0])) {\n                    return coords;\n                }\n            }\n        }\n\n        return this.transformFromLatLon(latLon, transforms['default']); // eslint-disable-line dot-notation\n    };\n\n    /**\n     * Convert a geojson object to map data of a given Highcharts type (map, mappoint or mapline).\n     */\n    H.geojson = function (geojson, hType, series) {\n        var mapData = [],\n            path = [],\n            polygonToPath = function (polygon) {\n                var i,\n                    len = polygon.length;\n                path.push('M');\n                for (i = 0; i < len; i++) {\n                    if (i === 1) {\n                        path.push('L');\n                    }\n                    path.push(polygon[i][0], -polygon[i][1]);\n                }\n            };\n\n        hType = hType || 'map';\n\n        each(geojson.features, function (feature) {\n\n            var geometry = feature.geometry,\n                type = geometry.type,\n                coordinates = geometry.coordinates,\n                properties = feature.properties,\n                point;\n\n            path = [];\n\n            if (hType === 'map' || hType === 'mapbubble') {\n                if (type === 'Polygon') {\n                    each(coordinates, polygonToPath);\n                    path.push('Z');\n\n                } else if (type === 'MultiPolygon') {\n                    each(coordinates, function (items) {\n                        each(items, polygonToPath);\n                    });\n                    path.push('Z');\n                }\n\n                if (path.length) {\n                    point = { path: path };\n                }\n\n            } else if (hType === 'mapline') {\n                if (type === 'LineString') {\n                    polygonToPath(coordinates);\n                } else if (type === 'MultiLineString') {\n                    each(coordinates, polygonToPath);\n                }\n\n                if (path.length) {\n                    point = { path: path };\n                }\n\n            } else if (hType === 'mappoint') {\n                if (type === 'Point') {\n                    point = {\n                        x: coordinates[0],\n                        y: -coordinates[1]\n                    };\n                }\n            }\n            if (point) {\n                mapData.push(extend(point, {\n                    name: properties.name || properties.NAME,\n                    properties: properties\n                }));\n            }\n\n        });\n\n        // Create a credits text that includes map source, to be picked up in Chart.showCredits\n        if (series && geojson.copyrightShort) {\n            series.chart.mapCredits = '<a href=___doublequote___http://www.highcharts.com___doublequote___>Highcharts</a> \\u00A9 ' +\n                '<a href=___doublequote___' + geojson.copyrightUrl + '___doublequote___>' + geojson.copyrightShort + '</a>';\n            series.chart.mapCreditsFull = geojson.copyright;\n        }\n\n        return mapData;\n    };\n\n    /**\n     * Override showCredits to include map source by default\n     */\n    wrap(Chart.prototype, 'showCredits', function (proceed, credits) {\n\n        if (defaultOptions.credits.text === this.options.credits.text && this.mapCredits) { // default text and mapCredits is set\n            credits.text = this.mapCredits;\n            credits.href = null;\n        }\n\n        proceed.call(this, credits);\n\n        if (this.credits && this.mapCreditsFull) {\n            this.credits.attr({\n                title: this.mapCreditsFull\n            });\n        }\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var Chart = H.Chart,\n            defaultOptions = H.defaultOptions,\n            each = H.each,\n            extend = H.extend,\n            merge = H.merge,\n            Renderer = H.Renderer,\n            SVGRenderer = H.SVGRenderer,\n            VMLRenderer = H.VMLRenderer;\n\n\n    // Add language\n    extend(defaultOptions.lang, {\n        zoomIn: 'Zoom in',\n        zoomOut: 'Zoom out'\n    });\n\n\n    // Set the default map navigation options\n    defaultOptions.mapNavigation = {\n        buttonOptions: {\n            alignTo: 'plotBox',\n            align: 'left',\n            verticalAlign: 'top',\n            x: 0,\n            width: 18,\n            height: 18,\n            style: {\n                fontSize: '15px',\n                fontWeight: 'bold',\n                textAlign: 'center'\n            },\n            theme: {\n                'stroke-width': 1\n            }\n        },\n        buttons: {\n            zoomIn: {\n                onclick: function () {\n                    this.mapZoom(0.5);\n                },\n                text: '+',\n                y: 0\n            },\n            zoomOut: {\n                onclick: function () {\n                    this.mapZoom(2);\n                },\n                text: '-',\n                y: 28\n            }\n        }\n        // enabled: false,\n        // enableButtons: null, // inherit from enabled\n        // enableTouchZoom: null, // inherit from enabled\n        // enableDoubleClickZoom: null, // inherit from enabled\n        // enableDoubleClickZoomTo: false\n        // enableMouseWheelZoom: null, // inherit from enabled\n    };\n\n    /**\n     * Utility for reading SVG paths directly.\n     */\n    H.splitPath = function (path) {\n        var i;\n\n        // Move letters apart\n        path = path.replace(/([A-Za-z])/g, ' $1 ');\n        // Trim\n        path = path.replace(/^\\s*/, '').replace(/\\s*$/, '');\n\n        // Split on spaces and commas\n        path = path.split(/[ ,,]+/); // Extra comma to escape gulp.scripts task\n    \n        // Parse numbers\n        for (i = 0; i < path.length; i++) {\n            if (!/[a-zA-Z]/.test(path[i])) {\n                path[i] = parseFloat(path[i]);\n            }\n        }\n        return path;\n    };\n\n    // A placeholder for map definitions\n    H.maps = {};\n\n\n\n\n\n    // Create symbols for the zoom buttons\n    function selectiveRoundedRect(x, y, w, h, rTopLeft, rTopRight, rBottomRight, rBottomLeft) {\n        return ['M', x + rTopLeft, y,\n            // top side\n            'L', x + w - rTopRight, y,\n            // top right corner\n            'C', x + w - rTopRight / 2, y, x + w, y + rTopRight / 2, x + w, y + rTopRight,\n            // right side\n            'L', x + w, y + h - rBottomRight,\n            // bottom right corner\n            'C', x + w, y + h - rBottomRight / 2, x + w - rBottomRight / 2, y + h, x + w - rBottomRight, y + h,\n            // bottom side\n            'L', x + rBottomLeft, y + h,\n            // bottom left corner\n            'C', x + rBottomLeft / 2, y + h, x, y + h - rBottomLeft / 2, x, y + h - rBottomLeft,\n            // left side\n            'L', x, y + rTopLeft,\n            // top left corner\n            'C', x, y + rTopLeft / 2, x + rTopLeft / 2, y, x + rTopLeft, y,\n            'Z'\n        ];\n    }\n    SVGRenderer.prototype.symbols.topbutton = function (x, y, w, h, attr) {\n        return selectiveRoundedRect(x - 1, y - 1, w, h, attr.r, attr.r, 0, 0);\n    };\n    SVGRenderer.prototype.symbols.bottombutton = function (x, y, w, h, attr) {\n        return selectiveRoundedRect(x - 1, y - 1, w, h, 0, 0, attr.r, attr.r);\n    };\n    // The symbol callbacks are generated on the SVGRenderer object in all browsers. Even\n    // VML browsers need this in order to generate shapes in export. Now share\n    // them with the VMLRenderer.\n    if (Renderer === VMLRenderer) {\n        each(['topbutton', 'bottombutton'], function (shape) {\n            VMLRenderer.prototype.symbols[shape] = SVGRenderer.prototype.symbols[shape];\n        });\n    }\n\n\n    /**\n     * A wrapper for Chart with all the default values for a Map\n     */\n    Highcharts.Map = Highcharts.mapChart = function (a, b, c) {\n\n        var hasRenderToArg = typeof a === 'string' || a.nodeName,\n            options = arguments[hasRenderToArg ? 1 : 0],\n            hiddenAxis = {\n                endOnTick: false,\n                gridLineWidth: 0,\n                lineWidth: 0,\n                minPadding: 0,\n                maxPadding: 0,\n                startOnTick: false,\n                title: null,\n                tickPositions: []\n            },\n            seriesOptions;\n\n        /* For visual testing\n        hiddenAxis.gridLineWidth = 1;\n        hiddenAxis.gridZIndex = 10;\n        hiddenAxis.tickPositions = undefined;\n        // */\n\n        // Don't merge the data\n        seriesOptions = options.series;\n        options.series = null;\n\n        options = merge(\n            {\n                chart: {\n                    panning: 'xy',\n                    type: 'map'\n                },\n                xAxis: hiddenAxis,\n                yAxis: merge(hiddenAxis, { reversed: true })\n            },\n            options, // user's options\n\n            { // forced options\n                chart: {\n                    inverted: false,\n                    alignTicks: false\n                }\n            }\n        );\n\n        options.series = seriesOptions;\n\n\n        return hasRenderToArg ? \n            new Chart(a, options, c) :\n            new Chart(options, b);\n    };\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var colorPointMixin = H.colorPointMixin,\n            colorSeriesMixin = H.colorSeriesMixin,\n            defaultOptions = H.defaultOptions,\n            each = H.each,\n            extendClass = H.extendClass,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes;\n    /**\n     * Extend the default options with map options\n     */\n    defaultOptions.plotOptions.heatmap = merge(defaultOptions.plotOptions.scatter, {\n        animation: false,\n        borderWidth: 0,\n        nullColor: '#F8F8F8',\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.value;\n            },\n            inside: true,\n            verticalAlign: 'middle',\n            crop: false,\n            overflow: false,\n            padding: 0 // #3837\n        },\n        marker: null,\n        pointRange: null, // dynamically set to colsize by default\n        tooltip: {\n            pointFormat: '{point.x}, {point.y}: {point.value}<br/>'\n        },\n        states: {\n            normal: {\n                animation: true\n            },\n            hover: {\n                halo: false,  // #3406, halo is not required on heatmaps\n                brightness: 0.2\n            }\n        }\n    });\n\n    // The Heatmap series type\n    seriesTypes.heatmap = extendClass(seriesTypes.scatter, merge(colorSeriesMixin, {\n        type: 'heatmap',\n        pointArrayMap: ['y', 'value'],\n        hasPointSpecificOptions: true,\n        pointClass: extendClass(Point, colorPointMixin),\n        supportsDrilldown: true,\n        getExtremesFromAll: true,\n        directTouch: true,\n\n        /**\n         * Override the init method to add point ranges on both axes.\n         */\n        init: function () {\n            var options;\n            seriesTypes.scatter.prototype.init.apply(this, arguments);\n\n            options = this.options;\n            options.pointRange = pick(options.pointRange, options.colsize || 1); // #3758, prevent resetting in setData\n            this.yAxis.axisPointRange = options.rowsize || 1; // general point range\n        },\n        translate: function () {\n            var series = this,\n                options = series.options,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                between = function (x, a, b) {\n                    return Math.min(Math.max(a, x), b);\n                };\n\n            series.generatePoints();\n\n            each(series.points, function (point) {\n                var xPad = (options.colsize || 1) / 2,\n                    yPad = (options.rowsize || 1) / 2,\n                    x1 = between(Math.round(xAxis.len - xAxis.translate(point.x - xPad, 0, 1, 0, 1)), 0, xAxis.len),\n                    x2 = between(Math.round(xAxis.len - xAxis.translate(point.x + xPad, 0, 1, 0, 1)), 0, xAxis.len),\n                    y1 = between(Math.round(yAxis.translate(point.y - yPad, 0, 1, 0, 1)), 0, yAxis.len),\n                    y2 = between(Math.round(yAxis.translate(point.y + yPad, 0, 1, 0, 1)), 0, yAxis.len);\n\n                // Set plotX and plotY for use in K-D-Tree and more\n                point.plotX = point.clientX = (x1 + x2) / 2;\n                point.plotY = (y1 + y2) / 2;\n\n                point.shapeType = 'rect';\n                point.shapeArgs = {\n                    x: Math.min(x1, x2),\n                    y: Math.min(y1, y2),\n                    width: Math.abs(x2 - x1),\n                    height: Math.abs(y2 - y1)\n                };\n            });\n\n            series.translateColors();\n\n            // Make sure colors are updated on colorAxis update (#2893)\n            if (this.chart.hasRendered) {\n                each(series.points, function (point) {\n                    point.shapeArgs.fill = point.options.color || point.color; // #3311\n                });\n            }\n        },\n        drawPoints: seriesTypes.column.prototype.drawPoints,\n        animate: noop,\n        getBox: noop,\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n        getExtremes: function () {\n            // Get the extremes from the value data\n            Series.prototype.getExtremes.call(this, this.valueData);\n            this.valueMin = this.dataMin;\n            this.valueMax = this.dataMax;\n\n            // Get the extremes from the y data\n            Series.prototype.getExtremes.call(this);\n        }\n\n    }));\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            createElement = H.createElement,\n            css = H.css,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            hasTouch = H.hasTouch,\n            inArray = H.inArray,\n            isObject = H.isObject,\n            Legend = H.Legend,\n            merge = H.merge,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            svg = H.svg,\n            TrackerMixin;\n    /**\n     * TrackerMixin for points and graphs\n     */\n    TrackerMixin = H.TrackerMixin = {\n\n        drawTrackerPoint: function () {\n            var series = this,\n                chart = series.chart,\n                pointer = chart.pointer,\n                onMouseOver = function (e) {\n                    var target = e.target,\n                        point;\n\n                    while (target && !point) {\n                        point = target.point;\n                        target = target.parentNode;\n                    }\n\n                    if (point !== undefined && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n                        point.onMouseOver(e);\n                    }\n                };\n\n            // Add reference to the point\n            each(series.points, function (point) {\n                if (point.graphic) {\n                    point.graphic.element.point = point;\n                }\n                if (point.dataLabel) {\n                    point.dataLabel.element.point = point;\n                }\n            });\n\n            // Add the event listeners, we need to do this only once\n            if (!series._hasTracking) {\n                each(series.trackerGroups, function (key) {\n                    if (series[key]) { // we don't always have dataLabelsGroup\n                        series[key]\n                            .addClass('highcharts-tracker')\n                            .on('mouseover', onMouseOver)\n                            .on('mouseout', function (e) {\n                                pointer.onTrackerMouseOut(e);\n                            })\n                            .css(css);\n                        if (hasTouch) {\n                            series[key].on('touchstart', onMouseOver);\n                        }\n\n                        ";
if (build.classic) { 
s += "\n                        if (series.options.cursor) {\n                            series[key].css({ cursor: series.options.cursor });\n                        }\n                        ";
} 
s += "\n                    }\n                });\n                series._hasTracking = true;\n            }\n        },\n\n        /**\n         * Draw the tracker object that sits above all data labels and markers to\n         * track mouse events on the graph or points. For the line type charts\n         * the tracker uses the same graphPath, but with a greater stroke width\n         * for better control.\n         */\n        drawTrackerGraph: function () {\n            var series = this,\n                options = series.options,\n                trackByArea = options.trackByArea,\n                trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n                trackerPathLength = trackerPath.length,\n                chart = series.chart,\n                pointer = chart.pointer,\n                renderer = chart.renderer,\n                snap = chart.options.tooltip.snap,\n                tracker = series.tracker,\n                i,\n                lineWidth,\n                onMouseOver = function () {\n                    if (chart.hoverSeries !== series) {\n                        series.onMouseOver();\n                    }\n                },\n                /*\n                 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n                 * IE6: 0.002\n                 * IE7: 0.002\n                 * IE8: 0.002\n                 * IE9: 0.00000000001 (unlimited)\n                 * IE10: 0.0001 (exporting only)\n                 * FF: 0.00000000001 (unlimited)\n                 * Chrome: 0.000001\n                 * Safari: 0.000001\n                 * Opera: 0.00000000001 (unlimited)\n                 */\n                TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n\n            ";
if (!build.classic) { 
s += "\n            lineWidth = series.graph.pxStyle('stroke-width');\n            ";
} else { 
s += "\n            lineWidth = options.lineWidth;\n            ";
} 
s += "\n\n            // Extend end points. A better way would be to use round linecaps,\n            // but those are not clickable in VML.\n            if (trackerPathLength && !trackByArea) {\n                i = trackerPathLength + 1;\n                while (i--) {\n                    if (trackerPath[i] === 'M') { // extend left side\n                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');\n                    }\n                    if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side\n                        trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);\n                    }\n                }\n            }\n\n            // handle single points\n            /*for (i = 0; i < singlePoints.length; i++) {\n                singlePoint = singlePoints[i];\n                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n                L, singlePoint.plotX + snap, singlePoint.plotY);\n            }*/\n\n            // draw the tracker\n            if (tracker) {\n                tracker.attr({ d: trackerPath });\n            } else { // create\n\n                series.tracker = renderer.path(trackerPath)\n                .attr({\n                    'stroke-linejoin': 'round', // #1225\n                    visibility: series.visible ? 'visible' : 'hidden',\n                    stroke: TRACKER_FILL,\n                    fill: trackByArea ? TRACKER_FILL : 'none',\n                    'stroke-width': lineWidth + (trackByArea ? 0 : 2 * snap),\n                    zIndex: 2\n                })\n                .add(series.group);\n\n                // The tracker is added to the series group, which is clipped, but is covered\n                // by the marker group. So the marker group also needs to capture events.\n                each([series.tracker, series.markerGroup], function (tracker) {\n                    tracker.addClass('highcharts-tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                            pointer.onTrackerMouseOut(e);\n                        });\n\n                    ";
if (build.classic) { 
s += "\n                    if (options.cursor) {\n                        tracker.css({ cursor: options.cursor });\n                    }\n                    ";
} 
s += "\n\n                    if (hasTouch) {\n                        tracker.on('touchstart', onMouseOver);\n                    }\n                });\n            }\n        }\n    };\n    /* End TrackerMixin */\n\n\n    /**\n     * Add tracking event listener to the series group, so the point graphics\n     * themselves act as trackers\n     */\n\n    if (seriesTypes.column) {\n        seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    if (seriesTypes.pie) {\n        seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    if (seriesTypes.scatter) {\n        seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    /*\n     * Extend Legend for item events\n     */\n    extend(Legend.prototype, {\n\n        setItemEvents: function (item, legendItem, useHTML) {\n            var legend = this,\n                chart = legend.chart,\n                activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';\n\n            // Set the events on the item group, or in case of useHTML, the item itself (#1249)\n            (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n                item.setState('hover');\n            \n                // A CSS class to dim or hide other than the hovered series\n                chart.seriesGroup.addClass(activeClass);\n            \n                ";
if (build.classic) { 
s += "\n                legendItem.css(legend.options.itemHoverStyle);\n                ";
} 
s += "\n            })\n            .on('mouseout', function () {\n                ";
if (build.classic) { 
s += "\n                legendItem.css(item.visible ? legend.itemStyle : legend.itemHiddenStyle);\n                ";
} 
s += "\n\n                // A CSS class to dim or hide other than the hovered series\n                chart.seriesGroup.removeClass(activeClass);\n            \n                item.setState();\n            })\n            .on('click', function (event) {\n                var strLegendItemClick = 'legendItemClick',\n                    fnLegendItemClick = function () {\n                        if (item.setVisible) {\n                            item.setVisible();\n                        }\n                    };\n\n                // Pass over the click/touch event. #4.\n                event = {\n                    browserEvent: event\n                };\n\n                // click the name or symbol\n                if (item.firePointEvent) { // point\n                    item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n                } else {\n                    fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n                }\n            });\n        },\n\n        createCheckboxForItem: function (item) {\n            var legend = this;\n\n            item.checkbox = createElement('input', {\n                type: 'checkbox',\n                checked: item.selected,\n                defaultChecked: item.selected // required by IE7\n            }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n            addEvent(item.checkbox, 'click', function (event) {\n                var target = event.target;\n                fireEvent(\n                    item.series || item, \n                    'checkboxClick', \n                    { // #3712\n                        checked: target.checked,\n                        item: item\n                    },\n                    function () {\n                        item.select();\n                    }\n                );\n            });\n        }\n    });\n\n\n    ";
if (build.classic) { 
s += "\n    // Add pointer cursor to legend itemstyle in defaultOptions\n    defaultOptions.legend.itemStyle.cursor = 'pointer';\n    ";
} 
s += "\n\n\n    /*\n     * Extend the Chart object with interaction\n     */\n\n    extend(Chart.prototype, {\n        /**\n         * Display the zoom button\n         */\n        showResetZoom: function () {\n            var chart = this,\n                lang = defaultOptions.lang,\n                btnOptions = chart.options.chart.resetZoomButton,\n                theme = btnOptions.theme,\n                states = theme.states,\n                alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n            function zoomOut() {\n                chart.zoomOut();\n            }\n\n            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)\n                .attr({\n                    align: btnOptions.position.align,\n                    title: lang.resetZoomTitle\n                })\n                .add()\n                .align(btnOptions.position, false, alignTo);\n\n        },\n\n        /**\n         * Zoom out to 1:1\n         */\n        zoomOut: function () {\n            var chart = this;\n            fireEvent(chart, 'selection', { resetSelection: true }, function () {\n                chart.zoom();\n            });\n        },\n\n        /**\n         * Zoom into a given portion of the chart given by axis coordinates\n         * @param {Object} event\n         */\n        zoom: function (event) {\n            var chart = this,\n                hasZoomed,\n                pointer = chart.pointer,\n                displayButton = false,\n                resetZoomButton;\n\n            // If zoom is called with no arguments, reset the axes\n            if (!event || event.resetSelection) {\n                each(chart.axes, function (axis) {\n                    hasZoomed = axis.zoom();\n                });\n            } else { // else, zoom in on all axes\n                each(event.xAxis.concat(event.yAxis), function (axisData) {\n                    var axis = axisData.axis,\n                        isXAxis = axis.isXAxis;\n\n                    // don't zoom more than minRange\n                    if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n                        hasZoomed = axis.zoom(axisData.min, axisData.max);\n                        if (axis.displayBtn) {\n                            displayButton = true;\n                        }\n                    }\n                });\n            }\n\n            // Show or hide the Reset zoom button\n            resetZoomButton = chart.resetZoomButton;\n            if (displayButton && !resetZoomButton) {\n                chart.showResetZoom();\n            } else if (!displayButton && isObject(resetZoomButton)) {\n                chart.resetZoomButton = resetZoomButton.destroy();\n            }\n\n\n            // Redraw\n            if (hasZoomed) {\n                chart.redraw(\n                    pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n                );\n            }\n        },\n\n        /**\n         * Pan the chart by dragging the mouse across the pane. This function is called\n         * on mouse move, and the distance to pan is computed from chartX compared to\n         * the first chartX position in the dragging operation.\n         */\n        pan: function (e, panning) {\n\n            var chart = this,\n                hoverPoints = chart.hoverPoints,\n                doRedraw;\n\n            // remove active points for shared tooltip\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n                var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                    horiz = axis.horiz,\n                    mousePos = e[horiz ? 'chartX' : 'chartY'],\n                    mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                    startPos = chart[mouseDown],\n                    halfPointRange = (axis.pointRange || 0) / 2,\n                    extremes = axis.getExtremes(),\n                    newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n                    newMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange,\n                    goingLeft = startPos > mousePos; // #3613\n            \n                if (axis.series.length &&\n                        (goingLeft || newMin > Math.min(extremes.dataMin, extremes.min)) &&    \n                        (!goingLeft || newMax < Math.max(extremes.dataMax, extremes.max))) {\n                    axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n                    doRedraw = true;\n                }\n\n                chart[mouseDown] = mousePos; // set new reference for next run\n            });\n\n            if (doRedraw) {\n                chart.redraw(false);\n            }\n            css(chart.container, { cursor: 'move' });\n        }\n    });\n\n    /*\n     * Extend the Point object with interaction\n     */\n    extend(Point.prototype, {\n        /**\n         * Toggle the selection status of a point\n         * @param {Boolean} selected Whether to select or unselect the point.\n         * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n         *         this happens if the control key (Cmd on Mac) was pressed during clicking.\n         */\n        select: function (selected, accumulate) {\n            var point = this,\n                series = point.series,\n                chart = series.chart;\n\n            selected = pick(selected, !point.selected);\n\n            // fire the event with the default handler\n            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n                point.selected = point.options.selected = selected;\n                series.options.data[inArray(point, series.data)] = point.options;\n\n                point.setState(selected && 'select');\n\n                // unselect all other points unless Ctrl or Cmd + click\n                if (!accumulate) {\n                    each(chart.getSelectedPoints(), function (loopPoint) {\n                        if (loopPoint.selected && loopPoint !== point) {\n                            loopPoint.selected = loopPoint.options.selected = false;\n                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n                            loopPoint.setState('');\n                            loopPoint.firePointEvent('unselect');\n                        }\n                    });\n                }\n            });\n        },\n\n        /**\n         * Runs on mouse over the point\n         *\n         * @param {Object} e The event arguments\n         * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to\n         *        actually hovered points. True for other points in shared tooltip.\n         */\n        onMouseOver: function (e, byProximity) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                tooltip = chart.tooltip,\n                hoverPoint = chart.hoverPoint;\n\n            if (chart.hoverSeries !== series) {\n                series.onMouseOver();\n            }\n\n            // set normal state to previous series\n            if (hoverPoint && hoverPoint !== point) {\n                hoverPoint.onMouseOut();\n            }\n\n            if (point.series) { // It may have been destroyed, #4130\n\n                // trigger the event\n                point.firePointEvent('mouseOver');\n\n                // update the tooltip\n                if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n                    tooltip.refresh(point, e);\n                }\n\n                // hover this\n                point.setState('hover');\n                if (!byProximity) {\n                    chart.hoverPoint = point;\n                }\n            }\n        },\n\n        /**\n         * Runs on mouse out from the point\n         */\n        onMouseOut: function () {\n            var chart = this.series.chart,\n                hoverPoints = chart.hoverPoints;\n\n            this.firePointEvent('mouseOut');\n\n            if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n                this.setState();\n                chart.hoverPoint = null;\n            }\n        },\n\n        /**\n         * Import events from the series' and point's options. Only do it on\n         * demand, to save processing time on hovering.\n         */\n        importEvents: function () {\n            if (!this.hasImportedEvents) {\n                var point = this,\n                    options = merge(point.series.options.point, point.options),\n                    events = options.events,\n                    eventType;\n\n                point.events = events;\n\n                for (eventType in events) {\n                    addEvent(point, eventType, events[eventType]);\n                }\n                this.hasImportedEvents = true;\n\n            }\n        },\n\n        /**\n         * Set the point's state\n         * @param {String} state\n         */\n        setState: function (state, move) {\n            var point = this,\n                plotX = Math.floor(point.plotX), // #4586\n                plotY = point.plotY,\n                series = point.series,\n                stateOptions = series.options.states[state] || {},\n                markerOptions = (defaultPlotOptions[series.type].marker && series.options.marker) || {},\n                normalDisabled = markerOptions.enabled === false,\n                markerStateOptions = (markerOptions.states && markerOptions.states[state]) || {},\n                stateDisabled = markerStateOptions.enabled === false,\n                stateMarkerGraphic = series.stateMarkerGraphic,\n                pointMarker = point.marker || {},\n                chart = series.chart,\n                radius,\n                halo = series.halo,\n                haloOptions,\n                newSymbol;\n\n            state = state || ''; // empty string\n\n            if (\n                    // already has this state\n                    (state === point.state && !move) ||\n                    // selected points don't respond to hover\n                    (point.selected && state !== 'select') ||\n                    // series' state options is disabled\n                    (stateOptions.enabled === false) ||\n                    // general point marker's state options is disabled\n                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n                    // individual point marker's state options is disabled\n                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n                ) {\n                return;\n            }\n\n            radius = markerStateOptions.radius || (markerOptions.radius + (markerStateOptions.radiusPlus || 0));\n        \n            // Apply hover styles to the existing point\n            if (point.graphic) {\n\n                point.graphic\n                    .removeClass('highcharts-point-' + point.state)\n                    .addClass('highcharts-point-' + state);\n\n                point.graphic.attr(merge(\n                    series.pointAttribs(point, state),\n                    radius ? { // new symbol attributes (#507, #612)\n                        x: plotX - radius,\n                        y: plotY - radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    } : {}\n                ));\n\n                // Zooming in from a range with no markers to a range with markers\n                if (stateMarkerGraphic) {\n                    stateMarkerGraphic.hide();\n                }\n            } else {\n                // if a graphic is not applied to each point in the normal state, create a shared\n                // graphic for the hover state\n                if (state && markerStateOptions) {\n                    newSymbol = pointMarker.symbol || series.symbol;\n\n                    // If the point has another symbol than the previous one, throw away the\n                    // state marker graphic and force a new one (#1459)\n                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n                        stateMarkerGraphic = stateMarkerGraphic.destroy();\n                    }\n\n                    // Add a new state marker graphic\n                    if (!stateMarkerGraphic) {\n                        if (newSymbol) {\n                            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n                                newSymbol,\n                                plotX - radius,\n                                plotY - radius,\n                                2 * radius,\n                                2 * radius\n                            )\n                            .attr(series.pointAttribs(point, state))\n                            .add(series.markerGroup);\n                            stateMarkerGraphic.currentSymbol = newSymbol;\n                        }\n\n                    // Move the existing graphic\n                    } else {\n                        stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                            x: plotX - radius,\n                            y: plotY - radius\n                        });\n                    }\n                }\n\n                if (stateMarkerGraphic) {\n                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n                    stateMarkerGraphic.element.point = point; // #4310\n                }\n            }\n\n            // Show me your halo\n            haloOptions = stateOptions.halo;\n            if (haloOptions && haloOptions.size) {\n                if (!halo) {\n                    series.halo = halo = chart.renderer.path()\n                        .add(chart.seriesGroup);\n                }\n                halo[move ? 'animate' : 'attr']({\n                    d: point.haloPath(haloOptions.size)\n                });\n                halo.attr({\n                    'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) \n                });\n\n                ";
if (build.classic) { 
s += "\n                halo.attr(extend({\n                    fill: point.color || series.color,\n                    'fill-opacity': haloOptions.opacity\n                },\n                haloOptions.attributes))[move ? 'animate' : 'attr']({\n                    d: point.haloPath(haloOptions.size)\n                });\n                ";
} 
s += "\n            } else if (halo) {\n                halo.attr({ d: [] });\n            }\n\n            point.state = state;\n        },\n\n        /**\n         * Get the circular path definition for the halo\n         * @param  {Number} size The radius of the circular halo\n         * @returns {Array} The path definition\n         */\n        haloPath: function (size) {\n            var series = this.series,\n                chart = series.chart,\n                plotBox = series.getPlotBox(),\n                inverted = chart.inverted,\n                plotX = Math.floor(this.plotX);\n\n            return chart.renderer.symbols.circle(\n                plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : plotX) - size, \n                plotBox.translateY + (inverted ? series.xAxis.len - plotX : this.plotY) - size, \n                size * 2, \n                size * 2\n            );\n        }\n    });\n\n    /*\n     * Extend the Series object with interaction\n     */\n\n    extend(Series.prototype, {\n        /**\n         * Series mouse over handler\n         */\n        onMouseOver: function () {\n            var series = this,\n                chart = series.chart,\n                hoverSeries = chart.hoverSeries;\n\n            // set normal state to previous series\n            if (hoverSeries && hoverSeries !== series) {\n                hoverSeries.onMouseOut();\n            }\n\n            // trigger the event, but to save processing time,\n            // only if defined\n            if (series.options.events.mouseOver) {\n                fireEvent(series, 'mouseOver');\n            }\n\n            // hover this\n            series.setState('hover');\n            chart.hoverSeries = series;\n        },\n\n        /**\n         * Series mouse out handler\n         */\n        onMouseOut: function () {\n            // trigger the event only if listeners exist\n            var series = this,\n                options = series.options,\n                chart = series.chart,\n                tooltip = chart.tooltip,\n                hoverPoint = chart.hoverPoint;\n\n            chart.hoverSeries = null; // #182, set to null before the mouseOut event fires\n\n            // trigger mouse out on the point, which must be in this series\n            if (hoverPoint) {\n                hoverPoint.onMouseOut();\n            }\n\n            // fire the mouse out event\n            if (series && options.events.mouseOut) {\n                fireEvent(series, 'mouseOut');\n            }\n\n\n            // hide the tooltip\n            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n                tooltip.hide();\n            }\n\n            // set normal state\n            series.setState();\n        },\n\n        /**\n         * Set the state of the graph\n         */\n        setState: function (state) {\n            var series = this,\n                options = series.options,\n                graph = series.graph,\n                stateOptions = options.states,\n                lineWidth = options.lineWidth,\n                attribs,\n                i = 0;\n\n            state = state || '';\n\n            if (series.state !== state) {\n\n                // Toggle class names\n                each([series.group, series.markerGroup], function (group) {\n                    if (group) {\n                        // Old state\n                        if (series.state) {\n                            group.removeClass('highcharts-series-' + series.state);\n                        }\n                        // New state\n                        if (state) {\n                            group.addClass('highcharts-series-' + state);\n                        }\n                    }\n                });\n\n                series.state = state;\n\n                ";
if (build.classic) { 
s += "\n\n                if (stateOptions[state] && stateOptions[state].enabled === false) {\n                    return;\n                }\n\n                if (state) {\n                    lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n                }\n\n                if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n                    attribs = {\n                        'stroke-width': lineWidth\n                    };\n                    // use attr because animate will cause any other animation on the graph to stop\n                    graph.attr(attribs);\n                    while (series['zone-graph-' + i]) {\n                        series['zone-graph-' + i].attr(attribs);\n                        i = i + 1;\n                    }\n                }\n                ";
} 
s += "\n            }\n        },\n\n        /**\n         * Set the visibility of the graph\n         *\n         * @param vis {Boolean} True to show the series, false to hide. If undefined,\n         *                the visibility is toggled.\n         */\n        setVisible: function (vis, redraw) {\n            var series = this,\n                chart = series.chart,\n                legendItem = series.legendItem,\n                showOrHide,\n                ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n                oldVisibility = series.visible;\n\n            // if called without an argument, toggle visibility\n            series.visible = vis = series.userOptions.visible = vis === undefined ? !oldVisibility : vis;\n            showOrHide = vis ? 'show' : 'hide';\n\n            // show or hide elements\n            each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n                if (series[key]) {\n                    series[key][showOrHide]();\n                }\n            });\n\n\n            // hide tooltip (#1361)\n            if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n                series.onMouseOut();\n            }\n\n\n            if (legendItem) {\n                chart.legend.colorizeItem(series, vis);\n            }\n\n\n            // rescale or adapt to resized chart\n            series.isDirty = true;\n            // in a stack, all other series are affected\n            if (series.options.stacking) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.options.stacking && otherSeries.visible) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n\n            // show or hide linked series\n            each(series.linkedSeries, function (otherSeries) {\n                otherSeries.setVisible(vis, false);\n            });\n\n            if (ignoreHiddenSeries) {\n                chart.isDirtyBox = true;\n            }\n            if (redraw !== false) {\n                chart.redraw();\n            }\n\n            fireEvent(series, showOrHide);\n        },\n\n        /**\n         * Show the graph\n         */\n        show: function () {\n            this.setVisible(true);\n        },\n\n        /**\n         * Hide the graph\n         */\n        hide: function () {\n            this.setVisible(false);\n        },\n\n\n        /**\n         * Set the selected state of the graph\n         *\n         * @param selected {Boolean} True to select the series, false to unselect. If\n         *                undefined, the selection state is toggled.\n         */\n        select: function (selected) {\n            var series = this;\n            // if called without an argument, toggle\n            series.selected = selected = (selected === undefined) ? !series.selected : selected;\n\n            if (series.checkbox) {\n                series.checkbox.checked = selected;\n            }\n\n            fireEvent(series, selected ? 'select' : 'unselect');\n        },\n\n        drawTracker: TrackerMixin.drawTrackerGraph\n    });\n\n        return H;\n    }(Highcharts));\n\n";
return s;ts.splice( // insert after this one\n                        i + 1,\n                        0,\n                        { isNull: true }\n                    );\n                }\n            }\n        }\n\n        // Call base method\n        //return proceed.call(this, points, a, b);\n        return this.getGraphPath(points);\n    };\n\n    /* ****************************************************************************\n     * End ordinal axis logic                                                   *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    /**\n     * Highstock JS v3.0-dev (2016-01-13)\n     * Highcharts Broken Axis module\n     * \n     * License: www.highcharts.com/license\n     */\n\n    (function (factory) {\n        ";
if (!build.assembly) { 
s += "\n        if (typeof module === 'object' && module.exports) {\n            module.exports = factory;\n            return;\n        }\n        ";
} 
s += "\n        factory(Highcharts);\n    \n    }(function (H) {\n\n        'use strict';\n\n        var pick = H.pick,\n            wrap = H.wrap,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            Axis = H.Axis,\n            Series = H.Series;\n\n        function stripArguments() {\n            return Array.prototype.slice.call(arguments, 1);\n        }\n\n        extend(Axis.prototype, {\n            isInBreak: function (brk, val) {\n                var ret,\n                    repeat = brk.repeat || Infinity,\n                    from = brk.from,\n                    length = brk.to - brk.from,\n                    test = (val >= from ? (val - from) % repeat :  repeat - ((from - val) % repeat));\n\n                if (!brk.inclusive) {\n                    ret = test < length && test !== 0;\n                } else {\n                    ret = test <= length;\n                }\n                return ret;\n            },\n\n            isInAnyBreak: function (val, testKeep) {\n\n                var breaks = this.options.breaks,\n                    i = breaks && breaks.length,\n                    inbrk,\n                    keep,\n                    ret;\n\n            \n                if (i) { \n\n                    while (i--) {\n                        if (this.isInBreak(breaks[i], val)) {\n                            inbrk = true;\n                            if (!keep) {\n                                keep = pick(breaks[i].showPoints, this.isXAxis ? false : true);\n                            }\n                        }\n                    }\n\n                    if (inbrk && testKeep) {\n                        ret = inbrk && !keep;\n                    } else {\n                        ret = inbrk;\n                    }\n                }\n                return ret;\n            }\n        });\n\n        wrap(Axis.prototype, 'setTickPositions', function (proceed) {\n            proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        \n            if (this.options.breaks) {\n                var axis = this,\n                    tickPositions = this.tickPositions,\n                    info = this.tickPositions.info,\n                    newPositions = [],\n                    i;\n\n                for (i = 0; i < tickPositions.length; i++) {\n                    if (!axis.isInAnyBreak(tickPositions[i])) {\n                        newPositions.push(tickPositions[i]);\n                    }\n                }\n\n                this.tickPositions = newPositions;\n                this.tickPositions.info = info;\n            }\n        });\n    \n        wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {\n            // Force Axis to be not-ordinal when breaks are defined\n            if (userOptions.breaks && userOptions.breaks.length) {\n                userOptions.ordinal = false;\n            }\n\n            proceed.call(this, chart, userOptions);\n\n            if (this.options.breaks) {\n\n                var axis = this;\n            \n                axis.doPostTranslate = true;\n\n                this.val2lin = function (val) {\n                    var nval = val,\n                        brk,\n                        i;\n\n                    for (i = 0; i < axis.breakArray.length; i++) {\n                        brk = axis.breakArray[i];\n                        if (brk.to <= val) {\n                            nval -= brk.len;\n                        } else if (brk.from >= val) {\n                            break;\n                        } else if (axis.isInBreak(brk, val)) {\n                            nval -= (val - brk.from);\n                            break;\n                        }\n                    }\n\n                    return nval;\n                };\n            \n                this.lin2val = function (val) {\n                    var nval = val,\n                        brk,\n                        i;\n\n                    for (i = 0; i < axis.breakArray.length; i++) {\n                        brk = axis.breakArray[i];\n                        if (brk.from >= nval) {\n                            break;\n                        } else if (brk.to < nval) {\n                            nval += brk.len;\n                        } else if (axis.isInBreak(brk, nval)) {\n                            nval += brk.len;\n                        }\n                    }\n                    return nval;\n                };\n\n                this.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                    // If trying to set extremes inside a break, extend it to before and after the break ( #3857 )\n                    while (this.isInAnyBreak(newMin)) {\n                        newMin -= this.closestPointRange;\n                    }            \n                    while (this.isInAnyBreak(newMax)) {\n                        newMax -= this.closestPointRange;\n                    }\n                    Axis.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                };\n\n                this.setAxisTranslation = function (saveOld) {\n                    Axis.prototype.setAxisTranslation.call(this, saveOld);\n\n                    var breaks = axis.options.breaks,\n                        breakArrayT = [],    // Temporary one\n                        breakArray = [],\n                        length = 0, \n                        inBrk,\n                        repeat,\n                        brk,\n                        min = axis.userMin || axis.min,\n                        max = axis.userMax || axis.max,\n                        start,\n                        i,\n                        j;\n\n                    // Min & max check (#4247)\n                    for (i in breaks) {\n                        brk = breaks[i];\n                        repeat = brk.repeat || Infinity;\n                        if (axis.isInBreak(brk, min)) {\n                            min += (brk.to % repeat) - (min % repeat);\n                        }\n                        if (axis.isInBreak(brk, max)) {\n                            max -= (max % repeat) - (brk.from % repeat);\n                        }\n                    }\n\n                    // Construct an array holding all breaks in the axis\n                    for (i in breaks) {\n                        brk = breaks[i];\n                        start = brk.from;\n                        repeat = brk.repeat || Infinity;\n\n                        while (start - repeat > min) {\n                            start -= repeat;\n                        }\n                        while (start < min) {\n                            start += repeat;\n                        }\n\n                        for (j = start; j < max; j += repeat) {\n                            breakArrayT.push({\n                                value: j,\n                                move: 'in'\n                            });\n                            breakArrayT.push({\n                                value: j + (brk.to - brk.from),\n                                move: 'out',\n                                size: brk.breakSize\n                            });\n                        }\n                    }\n\n                    breakArrayT.sort(function (a, b) {\n                        var ret;\n                        if (a.value === b.value) {\n                            ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);\n                        } else {\n                            ret = a.value - b.value;\n                        }\n                        return ret;\n                    });\n                \n                    // Simplify the breaks\n                    inBrk = 0;\n                    start = min;\n\n                    for (i in breakArrayT) {\n                        brk = breakArrayT[i];\n                        inBrk += (brk.move === 'in' ? 1 : -1);\n\n                        if (inBrk === 1 && brk.move === 'in') {\n                            start = brk.value;\n                        }\n                        if (inBrk === 0) {\n                            breakArray.push({\n                                from: start,\n                                to: brk.value,\n                                len: brk.value - start - (brk.size || 0)\n                            });\n                            length += brk.value - start - (brk.size || 0);\n                        }\n                    }\n\n                    axis.breakArray = breakArray;\n\n                    fireEvent(axis, 'afterBreaks');\n                \n                    axis.transA *= ((max - axis.min) / (max - min - length));\n\n                    axis.min = min;\n                    axis.max = max;\n                };\n            }\n        });\n\n        wrap(Series.prototype, 'generatePoints', function (proceed) {\n\n            proceed.apply(this, stripArguments(arguments));\n\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                points = series.points,\n                point,\n                i = points.length,\n                connectNulls = series.options.connectNulls,\n                nullGap;\n\n\n            if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {\n                while (i--) {\n                    point = points[i];\n\n                    nullGap = point.y === null && connectNulls === false; // respect nulls inside the break (#4275)\n                    if (!nullGap && (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true))) {\n                        points.splice(i, 1);\n                        if (this.data[i]) {\n                            this.data[i].destroyElements(); // removes the graphics for this point if they exist\n                        }\n                    }\n                }\n            }\n\n        });\n\n        function drawPointsWrapped(proceed) {\n            proceed.apply(this);\n            this.drawBreaks();\n        }\n\n        H.Series.prototype.drawBreaks = function () {\n            var series = this,\n                points = series.points,\n                axis,\n                breaks,\n                threshold,\n                axisName = 'Axis',\n                eventName,\n                y;\n\n            each(['y', 'x'], function (key) {\n                axis = series[key + axisName];\n                breaks = axis.breakArray || [];\n                threshold = axis.isXAxis ? axis.min : pick(series.options.threshold, axis.min);\n                each(points, function (point) {\n                    y = pick(point['stack' + key.toUpperCase()], point[key]);\n                    each(breaks, function (brk) {\n                        eventName = false;\n\n                        if ((threshold < brk.from && y > brk.to) || (threshold > brk.from && y < brk.from)) { \n                            eventName = 'pointBreak';\n                        } else if ((threshold < brk.from && y > brk.from && y < brk.to) || (threshold > brk.from && y > brk.to && y < brk.from)) { // point falls inside the break\n                            eventName = 'pointInBreak'; // docs\n                        } \n                        if (eventName) {\n                            fireEvent(axis, eventName, { point: point, brk: brk });\n                        }\n                    });\n                });\n            });\n        };\n\n        wrap(H.seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);\n        wrap(H.Series.prototype, 'drawPoints', drawPointsWrapped);\n\n    }));\n    (function (H) {\n\n        var arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            Axis = H.Axis,\n            defaultPlotOptions = H.defaultPlotOptions,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            isNumber = H.isNumber,\n            merge = H.merge,\n            pick = H.pick,\n            Series = H.Series,\n            Tooltip = H.Tooltip,\n            wrap = H.wrap;\n    \n    /* ****************************************************************************\n     * Start data grouping module                                                 *\n     ******************************************************************************/\n\n    var seriesProto = Series.prototype,\n        baseProcessData = seriesProto.processData,\n        baseGeneratePoints = seriesProto.generatePoints,\n        baseDestroy = seriesProto.destroy,\n\n        commonOptions = {\n            approximation: 'average', // average, open, high, low, close, sum\n            //enabled: null, // (true for stock charts, false for basic),\n            //forced: undefined,\n            groupPixelWidth: 2,\n            // the first one is the point or start value, the second is the start value if we're dealing with range,\n            // the third one is the end value if dealing with a range\n            dateTimeLabelFormats: {\n                millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],\n                second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],\n                minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],\n                hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],\n                day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],\n                week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],\n                month: ['%B %Y', '%B', '-%B %Y'],\n                year: ['%Y', '%Y', '-%Y']\n            }\n            // smoothed = false, // enable this for navigator series only\n        },\n\n        specificOptions = { // extends common options\n            line: {},\n            spline: {},\n            area: {},\n            areaspline: {},\n            column: {\n                approximation: 'sum',\n                groupPixelWidth: 10\n            },\n            arearange: {\n                approximation: 'range'\n            },\n            areasplinerange: {\n                approximation: 'range'\n            },\n            columnrange: {\n                approximation: 'range',\n                groupPixelWidth: 10\n            },\n            candlestick: {\n                approximation: 'ohlc',\n                groupPixelWidth: 10\n            },\n            ohlc: {\n                approximation: 'ohlc',\n                groupPixelWidth: 5\n            }\n        },\n\n        // units are defined in a separate array to allow complete overriding in case of a user option\n        defaultDataGroupingUnits = H.defaultDataGroupingUnits = [\n            [\n                'millisecond', // unit name\n                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n            ], [\n                'second',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'minute',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'hour',\n                [1, 2, 3, 4, 6, 8, 12]\n            ], [\n                'day',\n                [1]\n            ], [\n                'week',\n                [1]\n            ], [\n                'month',\n                [1, 3, 6]\n            ], [\n                'year',\n                null\n            ]\n        ],\n\n\n        /**\n         * Define the available approximation types. The data grouping approximations takes an array\n         * or numbers as the first parameter. In case of ohlc, four arrays are sent in as four parameters.\n         * Each array consists only of numbers. In case null values belong to the group, the property\n         * .hasNulls will be set to true on the array.\n         */\n        approximations = {\n            sum: function (arr) {\n                var len = arr.length,\n                    ret;\n\n                // 1. it consists of nulls exclusively\n                if (!len && arr.hasNulls) {\n                    ret = null;\n                // 2. it has a length and real values\n                } else if (len) {\n                    ret = 0;\n                    while (len--) {\n                        ret += arr[len];\n                    }\n                }\n                // 3. it has zero length, so just return undefined\n                // => doNothing()\n\n                return ret;\n            },\n            average: function (arr) {\n                var len = arr.length,\n                    ret = approximations.sum(arr);\n\n                // If we have a number, return it divided by the length. If not, return\n                // null or undefined based on what the sum method finds.\n                if (typeof ret === 'number' && len) {\n                    ret = ret / len;\n                }\n\n                return ret;\n            },\n            open: function (arr) {\n                return arr.length ? arr[0] : (arr.hasNulls ? null : undefined);\n            },\n            high: function (arr) {\n                return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : undefined);\n            },\n            low: function (arr) {\n                return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : undefined);\n            },\n            close: function (arr) {\n                return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : undefined);\n            },\n            // ohlc and range are special cases where a multidimensional array is input and an array is output\n            ohlc: function (open, high, low, close) {\n                open = approximations.open(open);\n                high = approximations.high(high);\n                low = approximations.low(low);\n                close = approximations.close(close);\n\n                if (typeof open === 'number' || typeof high === 'number' || typeof low === 'number' || typeof close === 'number') {\n                    return [open, high, low, close];\n                }\n                // else, return is undefined\n            },\n            range: function (low, high) {\n                low = approximations.low(low);\n                high = approximations.high(high);\n\n                if (typeof low === 'number' || typeof high === 'number') {\n                    return [low, high];\n                }\n                // else, return is undefined\n            }\n        };\n\n\n    /**\n     * Takes parallel arrays of x and y data and groups the data into intervals defined by groupPositions, a collection\n     * of starting x values for each group.\n     */\n    seriesProto.groupData = function (xData, yData, groupPositions, approximation) {\n        var series = this,\n            data = series.data,\n            dataOptions = series.options.data,\n            groupedXData = [],\n            groupedYData = [],\n            dataLength = xData.length,\n            pointX,\n            pointY,\n            groupedY,\n            handleYData = !!yData, // when grouping the fake extended axis for panning, we don't need to consider y\n            values = [[], [], [], []],\n            approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],\n            pointArrayMap = series.pointArrayMap,\n            pointArrayMapLength = pointArrayMap && pointArrayMap.length,\n            i;\n\n        // Start with the first point within the X axis range (#2696)\n        for (i = 0; i <= dataLength; i++) {\n            if (xData[i] >= groupPositions[0]) {\n                break;\n            }\n        }\n\n        for (i; i <= dataLength; i++) {\n\n            // when a new group is entered, summarize and initiate the previous group\n            while ((groupPositions[1] !== undefined && xData[i] >= groupPositions[1]) ||\n                    i === dataLength) { // get the last group\n\n                // get group x and y\n                pointX = groupPositions.shift();\n                groupedY = approximationFn.apply(0, values);\n\n                // push the grouped data\n                if (groupedY !== undefined) {\n                    groupedXData.push(pointX);\n                    groupedYData.push(groupedY);\n                }\n\n                // reset the aggregate arrays\n                values[0] = [];\n                values[1] = [];\n                values[2] = [];\n                values[3] = [];\n\n                // don't loop beyond the last group\n                if (i === dataLength) {\n                    break;\n                }\n            }\n\n            // break out\n            if (i === dataLength) {\n                break;\n            }\n\n            // for each raw data point, push it to an array that contains all values for this specific group\n            if (pointArrayMap) {\n\n                var index = series.cropStart + i,\n                    point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({ series: series }, [dataOptions[index]]),\n                    j,\n                    val;\n\n                for (j = 0; j < pointArrayMapLength; j++) {\n                    val = point[pointArrayMap[j]];\n                    if (typeof val === 'number') {\n                        values[j].push(val);\n                    } else if (val === null) {\n                        values[j].hasNulls = true;\n                    }\n                }\n\n            } else {\n                pointY = handleYData ? yData[i] : null;\n\n                if (typeof pointY === 'number') {\n                    values[0].push(pointY);\n                } else if (pointY === null) {\n                    values[0].hasNulls = true;\n                }\n            }\n        }\n\n        return [groupedXData, groupedYData];\n    };\n\n    /**\n     * Extend the basic processData method, that crops the data to the current zoom\n     * range, with data grouping logic.\n     */\n    seriesProto.processData = function () {\n        var series = this,\n            chart = series.chart,\n            options = series.options,\n            dataGroupingOptions = options.dataGrouping,\n            groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick(dataGroupingOptions.enabled, chart.options._stock),\n            hasGroupedData,\n            skip;\n\n        // run base method\n        series.forceCrop = groupingEnabled; // #334\n        series.groupPixelWidth = null; // #2110\n        series.hasProcessed = true; // #2692\n\n        // skip if processData returns false or if grouping is disabled (in that order)\n        skip = baseProcessData.apply(series, arguments) === false || !groupingEnabled;\n        if (!skip) {\n            series.destroyGroupedData();\n\n            var i,\n                processedXData = series.processedXData,\n                processedYData = series.processedYData,\n                plotSizeX = chart.plotSizeX,\n                xAxis = series.xAxis,\n                ordinal = xAxis.options.ordinal,\n                groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth();\n\n            // Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth\n            if (groupPixelWidth) {\n                hasGroupedData = true;\n\n                series.points = null; // force recreation of point instances in series.translate\n\n                var extremes = xAxis.getExtremes(),\n                    xMin = extremes.min,\n                    xMax = extremes.max,\n                    groupIntervalFactor = (ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series)) || 1,\n                    interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,\n                    groupPositions = xAxis.getTimeTicks(\n                        xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),\n                        Math.min(xMin, processedXData[0]), // Processed data may extend beyond axis (#4907)\n                        Math.max(xMax, processedXData[processedXData.length - 1]),\n                        xAxis.options.startOfWeek,\n                        processedXData,\n                        series.closestPointRange\n                    ),\n                    groupedXandY = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),\n                    groupedXData = groupedXandY[0],\n                    groupedYData = groupedXandY[1];\n\n                // prevent the smoothed data to spill out left and right, and make\n                // sure data is not shifted to the left\n                if (dataGroupingOptions.smoothed) {\n                    i = groupedXData.length - 1;\n                    groupedXData[i] = Math.min(groupedXData[i], xMax);\n                    while (i-- && i > 0) {\n                        groupedXData[i] += interval / 2;\n                    }\n                    groupedXData[0] = Math.max(groupedXData[0], xMin);\n                }\n\n                // record what data grouping values were used\n                series.currentDataGrouping = groupPositions.info;\n                series.closestPointRange = groupPositions.info.totalRange;\n\n                // Make sure the X axis extends to show the first group (#2533)\n                if (defined(groupedXData[0]) && groupedXData[0] < xAxis.dataMin) {\n                    if (xAxis.min === xAxis.dataMin) {\n                        xAxis.min = groupedXData[0];\n                    }\n                    xAxis.dataMin = groupedXData[0];\n                }\n\n                // set series props\n                series.processedXData = groupedXData;\n                series.processedYData = groupedYData;\n            } else {\n                series.currentDataGrouping = null;\n            }\n            series.hasGroupedData = hasGroupedData;\n        }\n    };\n\n    /**\n     * Destroy the grouped data points. #622, #740\n     */\n    seriesProto.destroyGroupedData = function () {\n\n        var groupedData = this.groupedData;\n\n        // clear previous groups\n        each(groupedData || [], function (point, i) {\n            if (point) {\n                groupedData[i] = point.destroy ? point.destroy() : null;\n            }\n        });\n        this.groupedData = null;\n    };\n\n    /**\n     * Override the generatePoints method by adding a reference to grouped data\n     */\n    seriesProto.generatePoints = function () {\n\n        baseGeneratePoints.apply(this);\n\n        // record grouped data in order to let it be destroyed the next time processData runs\n        this.destroyGroupedData(); // #622\n        this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    /**\n     * Extend the original method, make the tooltip's header reflect the grouped range\n     */\n    wrap(Tooltip.prototype, 'tooltipFooterHeaderFormatter', function (proceed, point, isFooter) {\n        var tooltip = this,\n            series = point.series,\n            options = series.options,\n            tooltipOptions = series.tooltipOptions,\n            dataGroupingOptions = options.dataGrouping,\n            xDateFormat = tooltipOptions.xDateFormat,\n            xDateFormatEnd,\n            xAxis = series.xAxis,\n            dateFormat = H.dateFormat,\n            currentDataGrouping,\n            dateTimeLabelFormats,\n            labelFormats,\n            formattedKey;\n\n        // apply only to grouped series\n        if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber(point.key)) {\n\n            // set variables\n            currentDataGrouping = series.currentDataGrouping;\n            dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;\n\n            // if we have grouped data, use the grouping information to get the right format\n            if (currentDataGrouping) {\n                labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];\n                if (currentDataGrouping.count === 1) {\n                    xDateFormat = labelFormats[0];\n                } else {\n                    xDateFormat = labelFormats[1];\n                    xDateFormatEnd = labelFormats[2];\n                }\n            // if not grouped, and we don't have set the xDateFormat option, get the best fit,\n            // so if the least distance between points is one minute, show it, but if the\n            // least distance is one day, skip hours and minutes etc.\n            } else if (!xDateFormat && dateTimeLabelFormats) {\n                xDateFormat = tooltip.getXDateFormat(point, tooltipOptions, xAxis);\n            }\n\n            // now format the key\n            formattedKey = dateFormat(xDateFormat, point.key);\n            if (xDateFormatEnd) {\n                formattedKey += dateFormat(xDateFormatEnd, point.key + currentDataGrouping.totalRange - 1);\n            }\n\n            // return the replaced format\n            return format(tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {\n                point: extend(point, { key: formattedKey }),\n                series: series\n            });\n    \n        }\n\n        // else, fall back to the regular formatter\n        return proceed.call(tooltip, point, isFooter);\n    });\n\n    /**\n     * Extend the series destroyer\n     */\n    seriesProto.destroy = function () {\n        var series = this,\n            groupedData = series.groupedData || [],\n            i = groupedData.length;\n\n        while (i--) {\n            if (groupedData[i]) {\n                groupedData[i].destroy();\n            }\n        }\n        baseDestroy.apply(series);\n    };\n\n\n    // Handle default options for data grouping. This must be set at runtime because some series types are\n    // defined after this.\n    wrap(seriesProto, 'setOptions', function (proceed, itemOptions) {\n\n        var options = proceed.call(this, itemOptions),\n            type = this.type,\n            plotOptions = this.chart.options.plotOptions,\n            defaultOptions = defaultPlotOptions[type].dataGrouping;\n\n        if (specificOptions[type]) { // #1284\n            if (!defaultOptions) {\n                defaultOptions = merge(commonOptions, specificOptions[type]);\n            }\n\n            options.dataGrouping = merge(\n                defaultOptions,\n                plotOptions.series && plotOptions.series.dataGrouping, // #1228\n                plotOptions[type].dataGrouping, // Set by the StockChart constructor\n                itemOptions.dataGrouping\n            );\n        }\n\n        if (this.chart.options._stock) {\n            this.requireSorting = true;\n        }\n\n        return options;\n    });\n\n\n    /**\n     * When resetting the scale reset the hasProccessed flag to avoid taking previous data grouping\n     * of neighbour series into accound when determining group pixel width (#2692).\n     */\n    wrap(Axis.prototype, 'setScale', function (proceed) {\n        proceed.call(this);\n        each(this.series, function (series) {\n            series.hasProcessed = false;\n        });\n    });\n\n    /**\n     * Get the data grouping pixel width based on the greatest defined individual width\n     * of the axis' series, and if whether one of the axes need grouping.\n     */\n    Axis.prototype.getGroupPixelWidth = function () {\n\n        var series = this.series,\n            len = series.length,\n            i,\n            groupPixelWidth = 0,\n            doGrouping = false,\n            dataLength,\n            dgOptions;\n\n        // If multiple series are compared on the same x axis, give them the same\n        // group pixel width (#334)\n        i = len;\n        while (i--) {\n            dgOptions = series[i].options.dataGrouping;\n            if (dgOptions) {\n                groupPixelWidth = Math.max(groupPixelWidth, dgOptions.groupPixelWidth);\n\n            }\n        }\n\n        // If one of the series needs grouping, apply it to all (#1634)\n        i = len;\n        while (i--) {\n            dgOptions = series[i].options.dataGrouping;\n\n            if (dgOptions && series[i].hasProcessed) { // #2692\n\n                dataLength = (series[i].processedXData || series[i].data).length;\n\n                // Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth\n                if (series[i].groupPixelWidth || dataLength > (this.chart.plotSizeX / groupPixelWidth) || (dataLength && dgOptions.forced)) {\n                    doGrouping = true;\n                }\n            }\n        }\n\n        return doGrouping ? groupPixelWidth : 0;\n    };\n\n    /**\n     * Force data grouping on all the axis' series.\n     */\n    Axis.prototype.setDataGrouping = function (dataGrouping, redraw) {\n        var i;\n\n        redraw = pick(redraw, true);\n\n        if (!dataGrouping) {\n            dataGrouping = {\n                forced: false,\n                units: null\n            };\n        }\n\n        // Axis is instantiated, update all series\n        if (this instanceof Axis) {\n            i = this.series.length;\n            while (i--) {\n                this.series[i].update({\n                    dataGrouping: dataGrouping\n                }, false);\n            }\n\n        // Axis not yet instanciated, alter series options\n        } else {\n            each(this.chart.options.series, function (seriesOptions) {\n                seriesOptions.dataGrouping = dataGrouping;\n            }, false);\n        }\n\n        if (redraw) {\n            this.chart.redraw();\n        }\n    };\n\n\n\n    /* ****************************************************************************\n     * End data grouping module                                                   *\n     ******************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            each = H.each,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            seriesTypes = H.seriesTypes;\n\n    /* ****************************************************************************\n     * Start OHLC series code                                                     *\n     *****************************************************************************/\n\n    // 1 - Set default options\n    defaultPlotOptions.ohlc = merge(defaultPlotOptions.column, {\n        lineWidth: 1,\n        tooltip: {\n            pointFormat: '<span style=___doublequote___color:{point.color}___doublequote___>\\u25CF</span> <b> {series.name}</b><br/>' + // docs\n                'Open: {point.open}<br/>' +\n                'High: {point.high}<br/>' +\n                'Low: {point.low}<br/>' +\n                'Close: {point.close}<br/>'\n        },\n        states: {\n            hover: {\n                lineWidth: 3\n            }\n        },\n        threshold: null\n        //upColor: undefined\n    });\n\n    // 2 - Create the OHLCSeries object\n    seriesTypes.ohlc = extendClass(seriesTypes.column, {\n        type: 'ohlc',\n        pointArrayMap: ['open', 'high', 'low', 'close'], // array point configs are mapped to this\n        toYData: function (point) { // return a plain array for speedy calculation\n            return [point.open, point.high, point.low, point.close];\n        },\n        pointValKey: 'high',\n\n        /**\n         * Postprocess mapping between options and SVG attributes\n         */\n        pointAttribs: function (point, state) {\n            var attribs = seriesTypes.column.prototype.pointAttribs.call(this, point, state),\n                options = this.options;\n\n            delete attribs.fill;\n            attribs['stroke-width'] = options.lineWidth;\n\n            attribs.stroke = point.options.color || (point.open < point.close ? (options.upColor || this.color) : this.color);\n\n            return attribs;\n        },\n\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         */\n        translate: function () {\n            var series = this,\n                yAxis = series.yAxis;\n\n            seriesTypes.column.prototype.translate.apply(series);\n\n            // do the translation\n            each(series.points, function (point) {\n                // the graphics\n                if (point.open !== null) {\n                    point.plotOpen = yAxis.translate(point.open, 0, 1, 0, 1);\n                }\n                if (point.close !== null) {\n                    point.plotClose = yAxis.translate(point.close, 0, 1, 0, 1);\n                }\n\n            });\n        },\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,\n                points = series.points,\n                chart = series.chart,\n                pointAttr,\n                plotOpen,\n                plotClose,\n                crispCorr,\n                halfWidth,\n                path,\n                graphic,\n                crispX;\n\n\n            each(points, function (point) {\n                if (point.plotY !== undefined) {\n\n                    graphic = point.graphic;\n                    pointAttr = series.pointAttribs(point, point.selected && 'select');\n\n                    // crisp vector coordinates\n                    crispCorr = (pointAttr['stroke-width'] % 2) / 2;\n                    crispX = Math.round(point.plotX) - crispCorr;  // #2596\n                    halfWidth = Math.round(point.shapeArgs.width / 2);\n\n                    // the vertical stem\n                    path = [\n                        'M',\n                        crispX, Math.round(point.yBottom),\n                        'L',\n                        crispX, Math.round(point.plotY)\n                    ];\n\n                    // open\n                    if (point.open !== null) {\n                        plotOpen = Math.round(point.plotOpen) + crispCorr;\n                        path.push(\n                            'M',\n                            crispX,\n                            plotOpen,\n                            'L',\n                            crispX - halfWidth,\n                            plotOpen\n                        );\n                    }\n\n                    // close\n                    if (point.close !== null) {\n                        plotClose = Math.round(point.plotClose) + crispCorr;\n                        path.push(\n                            'M',\n                            crispX,\n                            plotClose,\n                            'L',\n                            crispX + halfWidth,\n                            plotClose\n                        );\n                    }\n\n                    // create and/or update the graphic\n                    if (graphic) {\n                        graphic\n                            .attr(pointAttr) // #3897\n                            .animate({ d: path });\n                    } else {\n                        point.graphic = chart.renderer.path(path)\n                            .attr(pointAttr)\n                            .add(series.group);\n                    }\n\n                }\n\n\n            });\n\n        },\n\n        /**\n         * Disable animation\n         */\n        animate: null\n    });\n    /* ****************************************************************************\n     * End OHLC series code                                                       *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var defaultPlotOptions = H.defaultPlotOptions,\n            each = H.each,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            seriesTypes = H.seriesTypes;\n\n    /* ****************************************************************************\n     * Start Candlestick series code                                              *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {\n        lineColor: 'black',\n        lineWidth: 1,\n        states: {\n            hover: {\n                lineWidth: 2\n            }\n        },\n        tooltip: defaultPlotOptions.ohlc.tooltip,\n        threshold: null,\n        upColor: 'white'\n        // upLineColor: null\n    });\n\n    // 2 - Create the CandlestickSeries object\n    seriesTypes.candlestick = extendClass(seriesTypes.ohlc, {\n        type: 'candlestick',\n\n        /**\n         * Postprocess mapping between options and SVG attributes\n         */\n        pointAttribs: function (point, state) {\n            var attribs = seriesTypes.column.prototype.pointAttribs.call(this, point, state),\n                options = this.options,\n                isUp = point.open < point.close,\n                stroke = options.lineColor || this.color,\n                stateOptions;\n\n            attribs['stroke-width'] = options.lineWidth;\n\n            attribs.fill = point.options.color || (isUp ? (options.upColor || this.color) : this.color);\n            attribs.stroke = point.lineColor || (isUp ? (options.upLineColor || stroke) : stroke);\n\n            // Select or hover states\n            if (state) {\n                stateOptions = options.states[state];\n                attribs.fill = stateOptions.color || attribs.fill;\n                attribs.stroke = stateOptions.stroke || attribs.stroke;\n            }\n\n\n            return attribs;\n        },\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,  //state = series.state,\n                points = series.points,\n                chart = series.chart,\n                pointAttr,\n                plotOpen,\n                plotClose,\n                topBox,\n                bottomBox,\n                hasTopWhisker,\n                hasBottomWhisker,\n                crispCorr,\n                crispX,\n                graphic,\n                path,\n                halfWidth;\n\n\n            each(points, function (point) {\n\n                graphic = point.graphic;\n                if (point.plotY !== undefined) {\n\n                    pointAttr = series.pointAttribs(point, point.selected && 'select');\n\n                    // crisp vector coordinates\n                    crispCorr = (pointAttr['stroke-width'] % 2) / 2;\n                    crispX = Math.round(point.plotX) - crispCorr; // #2596\n                    plotOpen = point.plotOpen;\n                    plotClose = point.plotClose;\n                    topBox = Math.min(plotOpen, plotClose);\n                    bottomBox = Math.max(plotOpen, plotClose);\n                    halfWidth = Math.round(point.shapeArgs.width / 2);\n                    hasTopWhisker = Math.round(topBox) !== Math.round(point.plotY);\n                    hasBottomWhisker = bottomBox !== point.yBottom;\n                    topBox = Math.round(topBox) + crispCorr;\n                    bottomBox = Math.round(bottomBox) + crispCorr;\n\n                    // create the path\n                    path = [\n                        'M',\n                        crispX - halfWidth, bottomBox,\n                        'L',\n                        crispX - halfWidth, topBox,\n                        'L',\n                        crispX + halfWidth, topBox,\n                        'L',\n                        crispX + halfWidth, bottomBox,\n                        'Z', // Use a close statement to ensure a nice rectangle #2602\n                        'M',\n                        crispX, topBox,\n                        'L',\n                        crispX, hasTopWhisker ? Math.round(point.plotY) : topBox, // #460, #2094\n                        'M',\n                        crispX, bottomBox,\n                        'L',\n                        crispX, hasBottomWhisker ? Math.round(point.yBottom) : bottomBox // #460, #2094\n                    ];\n\n                    if (graphic) {\n                        graphic\n                            .attr(pointAttr) // #3897\n                            .animate({ d: path });\n                    } else {\n                        point.graphic = chart.renderer.path(path)\n                            .attr(pointAttr)\n                            .add(series.group)\n                            .shadow(series.options.shadow);\n                    }\n\n                }\n            });\n\n        }\n\n\n    });\n\n    /* ****************************************************************************\n     * End Candlestick series code                                                *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            defaultPlotOptions = H.defaultPlotOptions,\n            each = H.each,\n            extendClass = H.extendClass,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Renderer = H.Renderer,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            SVGRenderer = H.SVGRenderer,\n            TrackerMixin = H.TrackerMixin,\n            VMLRenderer = H.VMLRenderer,\n            symbols = SVGRenderer.prototype.symbols;\n    /* ****************************************************************************\n     * Start Flags series code                                                    *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.flags = merge(defaultPlotOptions.column, {\n        fillColor: 'white',\n        lineWidth: 1,\n        pointRange: 0, // #673\n        //radius: 2,\n        shape: 'flag',\n        stackDistance: 12,\n        states: {\n            hover: {\n                lineColor: 'black',\n                fillColor: '#FCFFC5'\n            }\n        },\n        style: {\n            fontSize: '11px',\n            fontWeight: 'bold',\n            textAlign: 'center'\n        },\n        tooltip: {\n            pointFormat: '{point.text}<br/>'\n        },\n        threshold: null,\n        y: -30\n    });\n\n    // 2 - Create the CandlestickSeries object\n    seriesTypes.flags = extendClass(seriesTypes.column, {\n        type: 'flags',\n        sorted: false,\n        noSharedTooltip: true,\n        allowDG: false,\n        takeOrdinalPosition: false, // #1074\n        trackerGroups: ['markerGroup'],\n        forceCrop: true,\n        /**\n         * Inherit the initialization from base Series\n         */\n        init: Series.prototype.init,\n        /**\n         * Get presentational attributes\n         */\n        pointAttribs: function (point, state) {\n            var options = this.options,\n                color = (point && point.color) || this.color,\n                fill = options.fillColor;\n\n            if (state) {\n                fill = options.states[state].fillColor;\n            }\n\n            return {\n                'fill': fill || color,\n                'stroke': options.lineColor || color,\n                'stroke-width': (point && point.lineWidth) || options.lineWidth || 0\n            };\n        },\n        /**\n         * Extend the translate method by placing the point on the related series\n         */\n        translate: function () {\n\n            seriesTypes.column.prototype.translate.apply(this);\n\n            var series = this,\n                options = series.options,\n                chart = series.chart,\n                points = series.points,\n                cursor = points.length - 1,\n                point,\n                lastPoint,\n                optionsOnSeries = options.onSeries,\n                onSeries = optionsOnSeries && chart.get(optionsOnSeries),\n                onKey = options.onKey || 'y', // docs. Added to API, marked next.\n                step = onSeries && onSeries.options.step,\n                onData = onSeries && onSeries.points,\n                i = onData && onData.length,\n                xAxis = series.xAxis,\n                xAxisExt = xAxis.getExtremes(),\n                leftPoint,\n                lastX,\n                rightPoint,\n                currentDataGrouping;\n\n            // relate to a master series\n            if (onSeries && onSeries.visible && i) {\n                currentDataGrouping = onSeries.currentDataGrouping;\n                lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374\n\n                // sort the data points\n                points.sort(function (a, b) {\n                    return (a.x - b.x);\n                });\n\n                onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);\n                while (i-- && points[cursor]) {\n                    point = points[cursor];\n                    leftPoint = onData[i];\n                    if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {\n                        if (point.x <= lastX) { // #803\n\n                            point.plotY = leftPoint[onKey];\n\n                            // interpolate between points, #666\n                            if (leftPoint.x < point.x && !step) {\n                                rightPoint = onData[i + 1];\n                                if (rightPoint && rightPoint[onKey] !== undefined) {\n                                    point.plotY +=\n                                        ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1\n                                        (rightPoint[onKey] - leftPoint[onKey]); // the y distance\n                                }\n                            }\n                        }\n                        cursor--;\n                        i++; // check again for points in the same x position\n                        if (cursor < 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Add plotY position and handle stacking\n            each(points, function (point, i) {\n\n                var stackIndex;\n\n                // Undefined plotY means the point is either on axis, outside series range or hidden series.\n                // If the series is outside the range of the x axis it should fall through with\n                // an undefined plotY, but then we must remove the shapeArgs (#847).\n                if (point.plotY === undefined) {\n                    if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) { // we're inside xAxis range\n                        point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : 0) + xAxis.offset - chart.plotTop;\n                    } else {\n                        point.shapeArgs = {}; // 847\n                    }\n                }\n                // if multiple flags appear at the same x, order them into a stack\n                lastPoint = points[i - 1];\n                if (lastPoint && lastPoint.plotX === point.plotX) {\n                    if (lastPoint.stackIndex === undefined) {\n                        lastPoint.stackIndex = 0;\n                    }\n                    stackIndex = lastPoint.stackIndex + 1;\n                }\n                point.stackIndex = stackIndex; // #3639\n            });\n\n\n        },\n\n        /**\n         * Draw the markers\n         */\n        drawPoints: function () {\n            var series = this,\n                pointAttr,\n                points = series.points,\n                chart = series.chart,\n                renderer = chart.renderer,\n                plotX,\n                plotY,\n                options = series.options,\n                optionsY = options.y,\n                shape,\n                i,\n                point,\n                graphic,\n                stackIndex,\n                anchorX,\n                anchorY,\n                outsideRight;\n\n            i = points.length;\n            while (i--) {\n                point = points[i];\n                outsideRight = point.plotX > series.xAxis.len;\n                plotX = point.plotX;\n                if (plotX > 0) { // #3119\n                    plotX -= pick(point.lineWidth, options.lineWidth) % 2; // #4285\n                }\n                stackIndex = point.stackIndex;\n                shape = point.options.shape || options.shape;\n                plotY = point.plotY;\n\n                if (plotY !== undefined) {\n                    plotY = point.plotY + optionsY - (stackIndex !== undefined && stackIndex * options.stackDistance);\n                }\n                anchorX = stackIndex ? undefined : point.plotX; // skip connectors for higher level stacked points\n                anchorY = stackIndex ? undefined : point.plotY;\n\n                graphic = point.graphic;\n\n                // only draw the point if y is defined and the flag is within the visible area\n                if (plotY !== undefined && plotX >= 0 && !outsideRight) {\n                    // shortcuts\n                    pointAttr = series.pointAttribs(point);\n                    if (graphic) { // update\n                        graphic.attr({\n                            x: plotX,\n                            y: plotY,\n                            anchorX: anchorX,\n                            anchorY: anchorY\n                        });\n                    } else {\n                        graphic = point.graphic = renderer.label(\n                            point.options.title || options.title || 'A',\n                            plotX,\n                            plotY,\n                            shape,\n                            anchorX,\n                            anchorY,\n                            options.useHTML\n                        )\n                        .css(merge(options.style, point.style))\n                        .attr(pointAttr)\n                        .attr({\n                            align: shape === 'flag' ? 'left' : 'center',\n                            width: options.width,\n                            height: options.height\n                        })\n                        .add(series.markerGroup)\n                        .shadow(options.shadow);\n\n                    }\n\n                    // Set the tooltip anchor position\n                    point.tooltipPos = [plotX, plotY];\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy();\n                }\n\n            }\n\n        },\n\n        /**\n         * Extend the column trackers with listeners to expand and contract stacks\n         */\n        drawTracker: function () {\n            var series = this,\n                points = series.points;\n\n            TrackerMixin.drawTrackerPoint.apply(this);\n\n            // Bring each stacked flag up on mouse over, this allows readability of vertically\n            // stacked elements as well as tight points on the x axis. #1924.\n            each(points, function (point) {\n                var graphic = point.graphic;\n                if (graphic) {\n                    addEvent(graphic.element, 'mouseover', function () {\n\n                        // Raise this point\n                        if (point.stackIndex > 0 && !point.raised) {\n                            point._y = graphic.y;\n                            graphic.attr({\n                                y: point._y - 8\n                            });\n                            point.raised = true;\n                        }\n\n                        // Revert other raised points\n                        each(points, function (otherPoint) {\n                            if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {\n                                otherPoint.graphic.attr({\n                                    y: otherPoint._y\n                                });\n                                otherPoint.raised = false;\n                            }\n                        });\n                    });\n                }\n            });\n        },\n\n        /**\n         * Disable animation\n         */\n        animate: noop,\n        buildKDTree: noop,\n        setClip: noop\n\n    });\n\n    // create the flag icon with anchor\n    symbols.flag = function (x, y, w, h, options) {\n        var anchorX = (options && options.anchorX) || x,\n            anchorY = (options &&  options.anchorY) || y;\n\n        return [\n            'M', anchorX, anchorY,\n            'L', x, y + h,\n            x, y,\n            x + w, y,\n            x + w, y + h,\n            x, y + h,\n            'Z'\n        ];\n    };\n\n    // create the circlepin and squarepin icons with anchor\n    each(['circle', 'square'], function (shape) {\n        symbols[shape + 'pin'] = function (x, y, w, h, options) {\n\n            var anchorX = options && options.anchorX,\n                anchorY = options &&  options.anchorY,\n                path,\n                labelTopOrBottomY;\n\n            // For single-letter flags, make sure circular flags are not taller than their width\n            if (shape === 'circle' && h > w) {\n                x -= Math.round((h - w) / 2);\n                w = h;\n            }\n\n            path = symbols[shape](x, y, w, h);\n\n            if (anchorX && anchorY) {\n                // if the label is below the anchor, draw the connecting line from the top edge of the label\n                // otherwise start drawing from the bottom edge\n                labelTopOrBottomY = (y > anchorY) ? y : y + h;\n                path.push('M', anchorX, labelTopOrBottomY, 'L', anchorX, anchorY);\n            }\n\n            return path;\n        };\n    });\n\n    // The symbol callbacks are generated on the SVGRenderer object in all browsers. Even\n    // VML browsers need this in order to generate shapes in export. Now share\n    // them with the VMLRenderer.\n    if (Renderer === VMLRenderer) {\n        each(['flag', 'circlepin', 'squarepin'], function (shape) {\n            VMLRenderer.prototype.symbols[shape] = symbols[shape];\n        });\n    }\n\n    /* ****************************************************************************\n     * End Flags series code                                                      *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n    /* ****************************************************************************\n     * Start Scroller code                                                        *\n     *****************************************************************************/\n    var addEvent = H.addEvent,\n        Axis = H.Axis,\n        Chart = H.Chart,\n        defaultDataGroupingUnits = H.defaultDataGroupingUnits,\n        defaultOptions = H.defaultOptions,\n        defined = H.defined,\n        destroyObjectProperties = H.destroyObjectProperties,\n        doc = H.doc,\n        each = H.each,\n        error = H.error,\n        extend = H.extend,\n        grep = H.grep,\n        hasTouch = H.hasTouch,\n        inArray = H.inArray,\n        isArray = H.isArray,\n        isObject = H.isObject,\n        isTouchDevice = H.isTouchDevice,\n        merge = H.merge,\n        pick = H.pick,\n        removeEvent = H.removeEvent,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes,\n        svg = H.svg,\n        wrap = H.wrap,\n\n        units = [].concat(defaultDataGroupingUnits), // copy\n        defaultSeriesType,\n\n        // Finding the min or max of a set of variables where we don't know if they are defined,\n        // is a pattern that is repeated several places in Highcharts. Consider making this\n        // a global utility method.\n        numExt = function (extreme) {\n            var numbers = grep(arguments, function (n) {\n                return typeof n === 'number';\n            });\n            if (numbers.length) {\n                return Math[extreme].apply(0, numbers);\n            }\n        };\n\n    // add more resolution to units\n    units[4] = ['day', [1, 2, 3, 4]]; // allow more days\n    units[5] = ['week', [1, 2, 3]]; // allow more weeks\n\n    defaultSeriesType = seriesTypes.areaspline === undefined ? 'line' : 'areaspline';\n\n    extend(defaultOptions, {\n        navigator: {\n            //enabled: true,\n            handles: {\n                backgroundColor: '#ebe7e8',\n                borderColor: '#b2b1b6'\n            },\n            height: 40,\n            margin: 25,\n            maskFill: 'rgba(128,179,236,0.3)',\n            maskInside: true,\n            outlineColor: '#b2b1b6',\n            outlineWidth: 1,\n            series: {\n                type: defaultSeriesType,\n                color: '#4572A7',\n                compare: null,\n                fillOpacity: 0.05,\n                dataGrouping: {\n                    approximation: 'average',\n                    enabled: true,\n                    groupPixelWidth: 2,\n                    smoothed: true,\n                    units: units\n                },\n                dataLabels: {\n                    enabled: false,\n                    zIndex: 2 // #1839\n                },\n                id: 'highcharts-navigator-series',\n                lineColor: null, // Allow color setting while disallowing default candlestick setting (#4602)\n                lineWidth: 1,\n                marker: {\n                    enabled: false\n                },\n                pointRange: 0,\n                shadow: false,\n                threshold: null\n            },\n            //top: undefined,\n            xAxis: {\n                tickWidth: 0,\n                lineWidth: 0,\n                gridLineColor: '#EEE',\n                gridLineWidth: 1,\n                tickPixelInterval: 200,\n                labels: {\n                    align: 'left',\n                    style: {\n                        color: '#888'\n                    },\n                    x: 3,\n                    y: -4\n                },\n                crosshair: false\n            },\n            yAxis: {\n                gridLineWidth: 0,\n                startOnTick: false,\n                endOnTick: false,\n                minPadding: 0.1,\n                maxPadding: 0.1,\n                labels: {\n                    enabled: false\n                },\n                crosshair: false,\n                title: {\n                    text: null\n                },\n                tickWidth: 0\n            }\n        },\n        scrollbar: {\n            //enabled: true\n            height: isTouchDevice ? 20 : 14,\n            barBackgroundColor: '#bfc8d1',\n            barBorderRadius: 0,\n            barBorderWidth: 1,\n            barBorderColor: '#bfc8d1',\n            buttonArrowColor: '#666',\n            buttonBackgroundColor: '#ebe7e8',\n            buttonBorderColor: '#bbb',\n            buttonBorderRadius: 0,\n            buttonBorderWidth: 1,\n            minWidth: 6,\n            rifleColor: '#666',\n            trackBackgroundColor: '#eeeeee',\n            trackBorderColor: '#eeeeee',\n            trackBorderWidth: 1,\n            // trackBorderRadius: 0\n            liveRedraw: svg && !isTouchDevice\n        }\n    });\n\n    /**\n     * The Scroller class\n     * @param {Object} chart\n     */\n    function Scroller(chart) {\n        var chartOptions = chart.options,\n            navigatorOptions = chartOptions.navigator,\n            navigatorEnabled = navigatorOptions.enabled,\n            scrollbarOptions = chartOptions.scrollbar,\n            scrollbarEnabled = scrollbarOptions.enabled,\n            height = navigatorEnabled ? navigatorOptions.height : 0,\n            scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;\n\n\n        this.handles = [];\n        this.scrollbarButtons = [];\n        this.elementsToDestroy = []; // Array containing the elements to destroy when Scroller is destroyed\n\n        this.chart = chart;\n        this.setBaseSeries();\n\n        this.height = height;\n        this.scrollbarHeight = scrollbarHeight;\n        this.scrollbarEnabled = scrollbarEnabled;\n        this.navigatorEnabled = navigatorEnabled;\n        this.navigatorOptions = navigatorOptions;\n        this.scrollbarOptions = scrollbarOptions;\n        this.outlineHeight = height + scrollbarHeight;\n\n        // Run scroller\n        this.init();\n    }\n\n    Scroller.prototype = {\n        /**\n         * Draw one of the handles on the side of the zoomed range in the navigator\n         * @param {Number} x The x center for the handle\n         * @param {Number} index 0 for left and 1 for right\n         */\n        drawHandle: function (x, index) {\n            var scroller = this,\n                chart = scroller.chart,\n                renderer = chart.renderer,\n                elementsToDestroy = scroller.elementsToDestroy,\n                handles = scroller.handles,\n                handlesOptions = scroller.navigatorOptions.handles,\n                attr = {\n                    fill: handlesOptions.backgroundColor,\n                    stroke: handlesOptions.borderColor,\n                    'stroke-width': 1\n                },\n                tempElem;\n\n            // create the elements\n            if (!scroller.rendered) {\n                // the group\n                handles[index] = renderer.g('navigator-handle-' + ['left', 'right'][index])\n                    .css({ cursor: 'ew-resize' })\n                    .attr({ zIndex: 10 - index }) // zIndex = 3 for right handle, 4 for left / 10 - #2908\n                    .add();\n\n                // the rectangle\n                tempElem = renderer.rect(-4.5, 0, 9, 16, 0, 1)\n                    .attr(attr)\n                    .add(handles[index]);\n                elementsToDestroy.push(tempElem);\n\n                // the rifles\n                tempElem = renderer\n                    .path([\n                        'M',\n                        -1.5, 4,\n                        'L',\n                        -1.5, 12,\n                        'M',\n                        0.5, 4,\n                        'L',\n                        0.5, 12\n                    ]).attr(attr)\n                    .add(handles[index]);\n                elementsToDestroy.push(tempElem);\n            }\n\n            // Place it\n            handles[index][chart.isResizing ? 'animate' : 'attr']({\n                translateX: scroller.scrollerLeft + scroller.scrollbarHeight + parseInt(x, 10),\n                translateY: scroller.top + scroller.height / 2 - 8\n            });\n        },\n\n        /**\n         * Draw the scrollbar buttons with arrows\n         * @param {Number} index 0 is left, 1 is right\n         */\n        drawScrollbarButton: function (index) {\n            var scroller = this,\n                chart = scroller.chart,\n                renderer = chart.renderer,\n                elementsToDestroy = scroller.elementsToDestroy,\n                scrollbarButtons = scroller.scrollbarButtons,\n                scrollbarHeight = scroller.scrollbarHeight,\n                scrollbarOptions = scroller.scrollbarOptions,\n                tempElem;\n\n            if (!scroller.rendered) {\n                scrollbarButtons[index] = renderer.g().add(scroller.scrollbarGroup);\n\n                tempElem = renderer.rect(\n                        -0.5,\n                        -0.5,\n                        scrollbarHeight + 1, // +1 to compensate for crispifying in rect method\n                        scrollbarHeight + 1,\n                        scrollbarOptions.buttonBorderRadius,\n                        scrollbarOptions.buttonBorderWidth\n                    ).attr({\n                        stroke: scrollbarOptions.buttonBorderColor,\n                        'stroke-width': scrollbarOptions.buttonBorderWidth,\n                        fill: scrollbarOptions.buttonBackgroundColor\n                    }).add(scrollbarButtons[index]);\n                elementsToDestroy.push(tempElem);\n\n                tempElem = renderer\n                    .path([\n                        'M',\n                        scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 - 3,\n                        'L',\n                        scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 + 3,\n                        scrollbarHeight / 2 + (index ? 2 : -2), scrollbarHeight / 2\n                    ]).attr({\n                        fill: scrollbarOptions.buttonArrowColor\n                    }).add(scrollbarButtons[index]);\n                elementsToDestroy.push(tempElem);\n            }\n\n            // adjust the right side button to the varying length of the scroll track\n            if (index) {\n                scrollbarButtons[index].attr({\n                    translateX: scroller.scrollerWidth - scrollbarHeight\n                });\n            }\n        },\n\n        /**\n         * Render the navigator and scroll bar\n         * @param {Number} min X axis value minimum\n         * @param {Number} max X axis value maximum\n         * @param {Number} pxMin Pixel value minimum\n         * @param {Number} pxMax Pixel value maximum\n         */\n        render: function (min, max, pxMin, pxMax) {\n            var scroller = this,\n                chart = scroller.chart,\n                renderer = chart.renderer,\n                navigatorLeft,\n                navigatorWidth,\n                scrollerLeft,\n                scrollerWidth,\n                scrollbarGroup = scroller.scrollbarGroup,\n                navigatorGroup = scroller.navigatorGroup,\n                scrollbar = scroller.scrollbar,\n                xAxis = scroller.xAxis,\n                scrollbarTrack = scroller.scrollbarTrack,\n                scrollbarHeight = scroller.scrollbarHeight,\n                scrollbarEnabled = scroller.scrollbarEnabled,\n                navigatorOptions = scroller.navigatorOptions,\n                scrollbarOptions = scroller.scrollbarOptions,\n                scrollbarMinWidth = scrollbarOptions.minWidth,\n                height = scroller.height,\n                top = scroller.top,\n                navigatorEnabled = scroller.navigatorEnabled,\n                outlineWidth = navigatorOptions.outlineWidth,\n                halfOutline = outlineWidth / 2,\n                zoomedMin,\n                zoomedMax,\n                range,\n                scrX,\n                scrWidth,\n                scrollbarPad = 0,\n                outlineHeight = scroller.outlineHeight,\n                barBorderRadius = scrollbarOptions.barBorderRadius,\n                strokeWidth,\n                scrollbarStrokeWidth = scrollbarOptions.barBorderWidth,\n                centerBarX,\n                outlineTop = top + halfOutline,\n                verb,\n                unionExtremes;\n\n            // Don't render the navigator until we have data (#486, #4202). Don't redraw while moving the handles (#4703).\n            if (!defined(min) || isNaN(min) || (scroller.hasDragged && !defined(pxMin))) {\n                return;\n            }\n\n            scroller.navigatorLeft = navigatorLeft = pick(\n                xAxis.left,\n                chart.plotLeft + scrollbarHeight // in case of scrollbar only, without navigator\n            );\n            scroller.navigatorWidth = navigatorWidth = pick(xAxis.len, chart.plotWidth - 2 * scrollbarHeight);\n            scroller.scrollerLeft = scrollerLeft = navigatorLeft - scrollbarHeight;\n            scroller.scrollerWidth = scrollerWidth = scrollerWidth = navigatorWidth + 2 * scrollbarHeight;\n\n            // Set the scroller x axis extremes to reflect the total. The navigator extremes\n            // should always be the extremes of the union of all series in the chart as\n            // well as the navigator series.\n            if (xAxis.getExtremes) {\n                unionExtremes = scroller.getUnionExtremes(true);\n\n                if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {\n                    xAxis.setExtremes(unionExtremes.dataMin, unionExtremes.dataMax, true, false);\n                }\n            }\n\n            // Get the pixel position of the handles\n            pxMin = pick(pxMin, xAxis.translate(min));\n            pxMax = pick(pxMax, xAxis.translate(max));\n            if (isNaN(pxMin) || Math.abs(pxMin) === Infinity) { // Verify (#1851, #2238)\n                pxMin = 0;\n                pxMax = scrollerWidth;\n            }\n\n            // Are we below the minRange? (#2618)\n            if (xAxis.translate(pxMax, true) - xAxis.translate(pxMin, true) < chart.xAxis[0].minRange) {\n                return;\n            }\n\n\n            // handles are allowed to cross, but never exceed the plot area\n            scroller.zoomedMax = Math.min(Math.max(pxMin, pxMax, 0), navigatorWidth);\n            scroller.zoomedMin = \n                Math.max(scroller.fixedWidth ? scroller.zoomedMax - scroller.fixedWidth : Math.min(pxMin, pxMax), 0);\n            scroller.range = scroller.zoomedMax - scroller.zoomedMin;\n            zoomedMax = Math.round(scroller.zoomedMax);\n            zoomedMin = Math.round(scroller.zoomedMin);\n            range = zoomedMax - zoomedMin;\n\n\n\n            // on first render, create all elements\n            if (!scroller.rendered) {\n\n                if (navigatorEnabled) {\n\n                    // draw the navigator group\n                    scroller.navigatorGroup = navigatorGroup = renderer.g('navigator')\n                        .attr({\n                            zIndex: 3\n                        })\n                        .add();\n\n                    scroller.leftShade = renderer.rect()\n                        .attr({\n                            fill: navigatorOptions.maskFill\n                        }).add(navigatorGroup);\n\n                    if (navigatorOptions.maskInside) {\n                        scroller.leftShade.css({ cursor: 'ew-resize' });\n                    } else {\n                        scroller.rightShade = renderer.rect()\n                            .attr({\n                                fill: navigatorOptions.maskFill\n                            }).add(navigatorGroup);\n                    }\n\n\n                    scroller.outline = renderer.path()\n                        .attr({\n                            'stroke-width': outlineWidth,\n                            stroke: navigatorOptions.outlineColor\n                        })\n                        .add(navigatorGroup);\n                }\n\n                if (scrollbarEnabled) {\n\n                    // draw the scrollbar group\n                    scroller.scrollbarGroup = scrollbarGroup = renderer.g('scrollbar').add();\n\n                    // the scrollbar track\n                    strokeWidth = scrollbarOptions.trackBorderWidth;\n                    scroller.scrollbarTrack = scrollbarTrack = renderer.rect().attr({\n                        x: 0,\n                        y: -strokeWidth % 2 / 2,\n                        fill: scrollbarOptions.trackBackgroundColor,\n                        stroke: scrollbarOptions.trackBorderColor,\n                        'stroke-width': strokeWidth,\n                        r: scrollbarOptions.trackBorderRadius || 0,\n                        height: scrollbarHeight\n                    }).add(scrollbarGroup);\n\n                    // the scrollbar itself\n                    scroller.scrollbar = scrollbar = renderer.rect()\n                        .attr({\n                            y: -scrollbarStrokeWidth % 2 / 2,\n                            height: scrollbarHeight,\n                            fill: scrollbarOptions.barBackgroundColor,\n                            stroke: scrollbarOptions.barBorderColor,\n                            'stroke-width': scrollbarStrokeWidth,\n                            r: barBorderRadius\n                        })\n                        .add(scrollbarGroup);\n\n                    scroller.scrollbarRifles = renderer.path()\n                        .attr({\n                            stroke: scrollbarOptions.rifleColor,\n                            'stroke-width': 1\n                        })\n                        .add(scrollbarGroup);\n                }\n            }\n\n            // place elements\n            verb = chart.isResizing ? 'animate' : 'attr';\n\n            if (navigatorEnabled) {\n                scroller.leftShade[verb](navigatorOptions.maskInside ? {\n                    x: navigatorLeft + zoomedMin,\n                    y: top,\n                    width: zoomedMax - zoomedMin,\n                    height: height\n                } : {\n                    x: navigatorLeft,\n                    y: top,\n                    width: zoomedMin,\n                    height: height\n                });\n                if (scroller.rightShade) {\n                    scroller.rightShade[verb]({\n                        x: navigatorLeft + zoomedMax,\n                        y: top,\n                        width: navigatorWidth - zoomedMax,\n                        height: height\n                    });\n                }\n\n                scroller.outline[verb]({ d: [\n                    'M',\n                    scrollerLeft, outlineTop, // left\n                    'L',\n                    navigatorLeft + zoomedMin - halfOutline, outlineTop, // upper left of zoomed range\n                    navigatorLeft + zoomedMin - halfOutline, outlineTop + outlineHeight, // lower left of z.r.\n                    'L',\n                    navigatorLeft + zoomedMax - halfOutline, outlineTop + outlineHeight, // lower right of z.r.\n                    'L',\n                    navigatorLeft + zoomedMax - halfOutline, outlineTop, // upper right of z.r.\n                    scrollerLeft + scrollerWidth, outlineTop // right\n                ].concat(navigatorOptions.maskInside ? [\n                    'M',\n                    navigatorLeft + zoomedMin + halfOutline, outlineTop, // upper left of zoomed range\n                    'L',\n                    navigatorLeft + zoomedMax - halfOutline, outlineTop // upper right of z.r.\n                ] : []) });\n                // draw handles\n                scroller.drawHandle(zoomedMin + halfOutline, 0);\n                scroller.drawHandle(zoomedMax + halfOutline, 1);\n            }\n\n            // draw the scrollbar\n            if (scrollbarEnabled && scrollbarGroup) {\n\n                // draw the buttons\n                scroller.drawScrollbarButton(0);\n                scroller.drawScrollbarButton(1);\n\n                scrollbarGroup[verb]({\n                    translateX: scrollerLeft,\n                    translateY: Math.round(outlineTop + height)\n                });\n\n                scrollbarTrack[verb]({\n                    width: scrollerWidth\n                });\n\n                // prevent the scrollbar from drawing to small (#1246)\n                scrX = scrollbarHeight + zoomedMin;\n                scrWidth = range - scrollbarStrokeWidth;\n                if (scrWidth < scrollbarMinWidth) {\n                    scrollbarPad = (scrollbarMinWidth - scrWidth) / 2;\n                    scrWidth = scrollbarMinWidth;\n                    scrX -= scrollbarPad;\n                }\n                scroller.scrollbarPad = scrollbarPad;\n                scrollbar[verb]({\n                    x: Math.floor(scrX) + (scrollbarStrokeWidth % 2 / 2),\n                    width: scrWidth\n                });\n\n                centerBarX = scrollbarHeight + zoomedMin + range / 2 - 0.5;\n\n                scroller.scrollbarRifles\n                    .attr({\n                        visibility: range > 12 ? 'visible' : 'hidden'\n                    })[verb]({\n                        d: [\n                            'M',\n                            centerBarX - 3, scrollbarHeight / 4,\n                            'L',\n                            centerBarX - 3, 2 * scrollbarHeight / 3,\n                            'M',\n                            centerBarX, scrollbarHeight / 4,\n                            'L',\n                            centerBarX, 2 * scrollbarHeight / 3,\n                            'M',\n                            centerBarX + 3, scrollbarHeight / 4,\n                            'L',\n                            centerBarX + 3, 2 * scrollbarHeight / 3\n                        ]\n                    });\n            }\n\n            scroller.scrollbarPad = scrollbarPad;\n            scroller.rendered = true;\n        },\n\n        /**\n         * Set up the mouse and touch events for the navigator and scrollbar\n         */\n        addEvents: function () {\n            var container = this.chart.container,\n                mouseDownHandler = this.mouseDownHandler,\n                mouseMoveHandler = this.mouseMoveHandler,\n                mouseUpHandler = this.mouseUpHandler,\n                _events;\n\n            // Mouse events\n            _events = [\n                [container, 'mousedown', mouseDownHandler],\n                [container, 'mousemove', mouseMoveHandler],\n                [doc, 'mouseup', mouseUpHandler]\n            ];\n\n            // Touch events\n            if (hasTouch) {\n                _events.push(\n                    [container, 'touchstart', mouseDownHandler],\n                    [container, 'touchmove', mouseMoveHandler],\n                    [doc, 'touchend', mouseUpHandler]\n                );\n            }\n\n            // Add them all\n            each(_events, function (args) {\n                addEvent.apply(null, args);\n            });\n            this._events = _events;\n        },\n\n        /**\n         * Removes the event handlers attached previously with addEvents.\n         */\n        removeEvents: function () {\n            each(this._events, function (args) {\n                removeEvent.apply(null, args);\n            });\n            this._events = undefined;\n            if (this.navigatorEnabled && this.baseSeries) {\n                removeEvent(this.baseSeries, 'updatedData', this.updatedDataHandler);\n            }\n        },\n\n        /**\n         * Initiate the Scroller object\n         */\n        init: function () {\n            var scroller = this,\n                chart = scroller.chart,\n                xAxis,\n                yAxis,\n                scrollbarHeight = scroller.scrollbarHeight,\n                navigatorOptions = scroller.navigatorOptions,\n                height = scroller.height,\n                top = scroller.top,\n                dragOffset,\n                baseSeries = scroller.baseSeries;\n\n            /**\n             * Event handler for the mouse down event.\n             */\n            scroller.mouseDownHandler = function (e) {\n                e = chart.pointer.normalize(e);\n\n                var zoomedMin = scroller.zoomedMin,\n                    zoomedMax = scroller.zoomedMax,\n                    top = scroller.top,\n                    scrollbarHeight = scroller.scrollbarHeight,\n                    scrollerLeft = scroller.scrollerLeft,\n                    scrollerWidth = scroller.scrollerWidth,\n                    navigatorLeft = scroller.navigatorLeft,\n                    navigatorWidth = scroller.navigatorWidth,\n                    scrollbarPad = scroller.scrollbarPad,\n                    range = scroller.range,\n                    chartX = e.chartX,\n                    chartY = e.chartY,\n                    baseXAxis = chart.xAxis[0],\n                    fixedMax,\n                    ext,\n                    handleSensitivity = isTouchDevice ? 10 : 7,\n                    left,\n                    isOnNavigator;\n\n                if (chartY > top && chartY < top + height + scrollbarHeight) { // we're vertically inside the navigator\n                    isOnNavigator = !scroller.scrollbarEnabled || chartY < top + height;\n\n                    // grab the left handle\n                    if (isOnNavigator && Math.abs(chartX - zoomedMin - navigatorLeft) < handleSensitivity) {\n                        scroller.grabbedLeft = true;\n                        scroller.otherHandlePos = zoomedMax;\n                        scroller.fixedExtreme = baseXAxis.max;\n                        chart.fixedRange = null;\n\n                    // grab the right handle\n                    } else if (isOnNavigator && Math.abs(chartX - zoomedMax - navigatorLeft) < handleSensitivity) {\n                        scroller.grabbedRight = true;\n                        scroller.otherHandlePos = zoomedMin;\n                        scroller.fixedExtreme = baseXAxis.min;\n                        chart.fixedRange = null;\n\n                    // grab the zoomed range\n                    } else if (chartX > navigatorLeft + zoomedMin - scrollbarPad && chartX < navigatorLeft + zoomedMax + scrollbarPad) {\n                        scroller.grabbedCenter = chartX;\n                        scroller.fixedWidth = range;\n\n                        dragOffset = chartX - zoomedMin;\n\n\n                    // shift the range by clicking on shaded areas, scrollbar track or scrollbar buttons\n                    } else if (chartX > scrollerLeft && chartX < scrollerLeft + scrollerWidth) {\n\n                        // Center around the clicked point\n                        if (isOnNavigator) {\n                            left = chartX - navigatorLeft - range / 2;\n\n                        // Click on scrollbar\n                        } else {\n\n                            // Click left scrollbar button\n                            if (chartX < navigatorLeft) {\n                                left = zoomedMin - range * 0.2;\n\n                            // Click right scrollbar button\n                            } else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {\n                                left = zoomedMin + range * 0.2;\n\n                            // Click on scrollbar track, shift the scrollbar by one range\n                            } else {\n                                left = chartX < navigatorLeft + zoomedMin ? // on the left\n                                    zoomedMin - range :\n                                    zoomedMax;\n                            }\n                        }\n                        if (left < 0) {\n                            left = 0;\n                        } else if (left + range >= navigatorWidth) {\n                            left = navigatorWidth - range;\n                            fixedMax = scroller.getUnionExtremes().dataMax; // #2293, #3543\n                        }\n                        if (left !== zoomedMin) { // it has actually moved\n                            scroller.fixedWidth = range; // #1370\n\n                            ext = xAxis.toFixedRange(left, left + range, null, fixedMax);\n                            baseXAxis.setExtremes(\n                                ext.min,\n                                ext.max,\n                                true,\n                                false,\n                                { trigger: 'navigator' }\n                            );\n                        }\n                    }\n\n                }\n            };\n\n            /**\n             * Event handler for the mouse move event.\n             */\n            scroller.mouseMoveHandler = function (e) {\n                var scrollbarHeight = scroller.scrollbarHeight,\n                    navigatorLeft = scroller.navigatorLeft,\n                    navigatorWidth = scroller.navigatorWidth,\n                    scrollerLeft = scroller.scrollerLeft,\n                    scrollerWidth = scroller.scrollerWidth,\n                    range = scroller.range,\n                    chartX,\n                    hasDragged;\n\n                // In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger\n                // down in the center of the scrollbar. This should be ignored.\n                if (!e.touches || e.touches[0].pageX !== 0) { // #4696, scrollbar failed on Android\n\n                    e = chart.pointer.normalize(e);\n                    chartX = e.chartX;\n\n                    // validation for handle dragging\n                    if (chartX < navigatorLeft) {\n                        chartX = navigatorLeft;\n                    } else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {\n                        chartX = scrollerLeft + scrollerWidth - scrollbarHeight;\n                    }\n\n                    // drag left handle\n                    if (scroller.grabbedLeft) {\n                        hasDragged = true;\n                        scroller.render(0, 0, chartX - navigatorLeft, scroller.otherHandlePos);\n\n                    // drag right handle\n                    } else if (scroller.grabbedRight) {\n                        hasDragged = true;\n                        scroller.render(0, 0, scroller.otherHandlePos, chartX - navigatorLeft);\n\n                    // drag scrollbar or open area in navigator\n                    } else if (scroller.grabbedCenter) {\n\n                        hasDragged = true;\n                        if (chartX < dragOffset) { // outside left\n                            chartX = dragOffset;\n                        } else if (chartX > navigatorWidth + dragOffset - range) { // outside right\n                            chartX = navigatorWidth + dragOffset - range;\n                        }\n\n                        scroller.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);\n\n                    }\n                    if (hasDragged && scroller.scrollbarOptions.liveRedraw) {\n                        setTimeout(function () {\n                            scroller.mouseUpHandler(e);\n                        }, 0);\n                    }\n                    scroller.hasDragged = hasDragged;\n                }\n            };\n\n            /**\n             * Event handler for the mouse up event.\n             */\n            scroller.mouseUpHandler = function (e) {\n                var ext,\n                    fixedMin,\n                    fixedMax;\n\n                if (scroller.hasDragged) {\n                    // When dragging one handle, make sure the other one doesn't change\n                    if (scroller.zoomedMin === scroller.otherHandlePos) {\n                        fixedMin = scroller.fixedExtreme;\n                    } else if (scroller.zoomedMax === scroller.otherHandlePos) {\n                        fixedMax = scroller.fixedExtreme;\n                    }\n\n                    // Snap to right edge (#4076)\n                    if (scroller.zoomedMax === scroller.navigatorWidth) {\n                        fixedMax = scroller.getUnionExtremes().dataMax;\n                    }\n\n                    ext = xAxis.toFixedRange(scroller.zoomedMin, scroller.zoomedMax, fixedMin, fixedMax);\n                    if (defined(ext.min)) {\n                        chart.xAxis[0].setExtremes(\n                            ext.min,\n                            ext.max,\n                            true,\n                            false,\n                            {\n                                trigger: 'navigator',\n                                triggerOp: 'navigator-drag',\n                                DOMEvent: e // #1838\n                            }\n                        );\n                    }\n                }\n\n                if (e.type !== 'mousemove') {\n                    scroller.grabbedLeft = scroller.grabbedRight = scroller.grabbedCenter = scroller.fixedWidth =\n                        scroller.fixedExtreme = scroller.otherHandlePos = scroller.hasDragged = dragOffset = null;\n                }\n\n            };\n\n\n\n            var xAxisIndex = chart.xAxis.length,\n                yAxisIndex = chart.yAxis.length;\n\n            // make room below the chart\n            chart.extraBottomMargin = scroller.outlineHeight + navigatorOptions.margin;\n\n            if (scroller.navigatorEnabled) {\n                // an x axis is required for scrollbar also\n                scroller.xAxis = xAxis = new Axis(chart, merge({\n                    // inherit base xAxis' break and ordinal options\n                    breaks: baseSeries && baseSeries.xAxis.options.breaks,\n                    ordinal: baseSeries && baseSeries.xAxis.options.ordinal\n                }, navigatorOptions.xAxis, {\n                    id: 'navigator-x-axis',\n                    isX: true,\n                    type: 'datetime',\n                    index: xAxisIndex,\n                    height: height,\n                    offset: 0,\n                    offsetLeft: scrollbarHeight,\n                    offsetRight: -scrollbarHeight,\n                    keepOrdinalPadding: true, // #2436\n                    startOnTick: false,\n                    endOnTick: false,\n                    minPadding: 0,\n                    maxPadding: 0,\n                    zoomEnabled: false\n                }));\n\n                scroller.yAxis = yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {\n                    id: 'navigator-y-axis',\n                    alignTicks: false,\n                    height: height,\n                    offset: 0,\n                    index: yAxisIndex,\n                    zoomEnabled: false\n                }));\n\n                // If we have a base series, initialize the navigator series\n                if (baseSeries || navigatorOptions.series.data) {\n                    scroller.addBaseSeries();\n\n                // If not, set up an event to listen for added series\n                } else if (chart.series.length === 0) {\n\n                    wrap(chart, 'redraw', function (proceed, animation) {\n                        // We've got one, now add it as base and reset chart.redraw\n                        if (chart.series.length > 0 && !scroller.series) {\n                            scroller.setBaseSeries();\n                            chart.redraw = proceed; // reset\n                        }\n                        proceed.call(chart, animation);\n                    });\n                }\n\n\n            // in case of scrollbar only, fake an x axis to get translation\n            } else {\n                scroller.xAxis = xAxis = {\n                    translate: function (value, reverse) {\n                        var axis = chart.xAxis[0],\n                            ext = axis.getExtremes(),\n                            scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,\n                            min = numExt('min', axis.options.min, ext.dataMin),\n                            valueRange = numExt('max', axis.options.max, ext.dataMax) - min;\n\n                        return reverse ?\n                            // from pixel to value\n                            (value * valueRange / scrollTrackWidth) + min :\n                            // from value to pixel\n                            scrollTrackWidth * (value - min) / valueRange;\n                    },\n                    toFixedRange: Axis.prototype.toFixedRange\n                };\n            }\n\n\n            /**\n             * For stock charts, extend the Chart.getMargins method so that we can set the final top position\n             * of the navigator once the height of the chart, including the legend, is determined. #367.\n             */\n            wrap(chart, 'getMargins', function (proceed) {\n\n                var legend = this.legend,\n                    legendOptions = legend.options;\n\n                proceed.apply(this, [].slice.call(arguments, 1));\n\n                // Compute the top position\n                scroller.top = top = scroller.navigatorOptions.top ||\n                    this.chartHeight - scroller.height - scroller.scrollbarHeight - this.spacing[2] -\n                            (legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ?\n                                legend.legendHeight + pick(legendOptions.margin, 10) : 0);\n\n                if (xAxis && yAxis) { // false if navigator is disabled (#904)\n\n                    xAxis.options.top = yAxis.options.top = top;\n\n                    xAxis.setAxisSize();\n                    yAxis.setAxisSize();\n                }\n            });\n\n\n            scroller.addEvents();\n        },\n\n        /**\n         * Get the union data extremes of the chart - the outer data extremes of the base\n         * X axis and the navigator axis.\n         */\n        getUnionExtremes: function (returnFalseOnNoBaseSeries) {\n            var baseAxis = this.chart.xAxis[0],\n                navAxis = this.xAxis,\n                navAxisOptions = navAxis.options,\n                baseAxisOptions = baseAxis.options,\n                ret;\n\n            if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {\n                ret = {\n                    dataMin: pick( // #4053\n                        navAxisOptions && navAxisOptions.min,\n                        numExt(\n                            'min',\n                            baseAxisOptions.min,\n                            baseAxis.dataMin,\n                            navAxis.dataMin\n                        )\n                    ),\n                    dataMax: pick(\n                        navAxisOptions && navAxisOptions.max,\n                        numExt(\n                            'max',\n                            baseAxisOptions.max,\n                            baseAxis.dataMax,\n                            navAxis.dataMax\n                        )\n                    )\n                };\n            }\n            return ret;\n        },\n\n        /**\n         * Set the base series. With a bit of modification we should be able to make\n         * this an API method to be called from the outside\n         */\n        setBaseSeries: function (baseSeriesOption) {\n            var chart = this.chart;\n\n            baseSeriesOption = baseSeriesOption || chart.options.navigator.baseSeries;\n\n            // If we're resetting, remove the existing series\n            if (this.series) {\n                this.series.remove();\n            }\n\n            // Set the new base series\n            this.baseSeries = chart.series[baseSeriesOption] ||\n                (typeof baseSeriesOption === 'string' && chart.get(baseSeriesOption)) ||\n                chart.series[0];\n\n            // When run after render, this.xAxis already exists\n            if (this.xAxis) {\n                this.addBaseSeries();\n            }\n        },\n\n        addBaseSeries: function () {\n            var baseSeries = this.baseSeries,\n                baseOptions = baseSeries ? baseSeries.options : {},\n                baseData = baseOptions.data,\n                mergedNavSeriesOptions,\n                navigatorSeriesOptions = this.navigatorOptions.series,\n                navigatorData;\n\n            // remove it to prevent merging one by one\n            navigatorData = navigatorSeriesOptions.data;\n            this.hasNavigatorData = !!navigatorData;\n\n            // Merge the series options\n            mergedNavSeriesOptions = merge(baseOptions, navigatorSeriesOptions, {\n                enableMouseTracking: false,\n                group: 'nav', // for columns\n                padXAxis: false,\n                pointValKey: inArray('close', baseSeries.pointArrayMap || []) > -1 && 'close', // #1905\n                xAxis: 'navigator-x-axis',\n                yAxis: 'navigator-y-axis',\n                name: 'Navigator',\n                showInLegend: false,\n                stacking: false, // We only allow one series anyway (#4823)\n                isInternal: true,\n                visible: true\n            });\n\n            // set the data back\n            mergedNavSeriesOptions.data = navigatorData || baseData;\n\n            // add the series\n            this.series = this.chart.initSeries(mergedNavSeriesOptions);\n\n            // Respond to updated data in the base series.\n            // Abort if lazy-loading data from the server.\n            if (baseSeries && this.navigatorOptions.adaptToUpdatedData !== false) {\n                addEvent(baseSeries, 'updatedData', this.updatedDataHandler);\n                // Survive Series.update()\n                baseSeries.userOptions.events = extend(baseSeries.userOptions.event, { updatedData: this.updatedDataHandler });\n\n            }\n        },\n\n        updatedDataHandler: function () {\n            var scroller = this.chart.scroller,\n                baseSeries = scroller.baseSeries,\n                baseXAxis = baseSeries.xAxis,\n                baseExtremes = baseXAxis.getExtremes(),\n                baseMin = baseExtremes.min,\n                baseMax = baseExtremes.max,\n                baseDataMin = baseExtremes.dataMin,\n                baseDataMax = baseExtremes.dataMax,\n                range = baseMax - baseMin,\n                stickToMin,\n                stickToMax,\n                newMax,\n                newMin,\n                doRedraw,\n                navigatorSeries = scroller.series,\n                navXData = navigatorSeries.xData,\n                hasSetExtremes = !!baseXAxis.setExtremes;\n\n            // detect whether to move the range\n            stickToMax = baseMax >= navXData[navXData.length - 1] - (this.closestPointRange || 0); // #570\n            stickToMin = baseMin <= baseDataMin;\n\n            // set the navigator series data to the new data of the base series\n            if (!scroller.hasNavigatorData) {\n                navigatorSeries.options.pointStart = baseSeries.xData[0];\n                navigatorSeries.setData(baseSeries.options.data, false);\n                doRedraw = true;\n            }\n\n            // if the zoomed range is already at the min, move it to the right as new data\n            // comes in\n            if (stickToMin) {\n                newMin = baseDataMin;\n                newMax = newMin + range;\n            }\n\n            // if the zoomed range is already at the max, move it to the right as new data\n            // comes in\n            if (stickToMax) {\n                newMax = baseDataMax;\n                if (!stickToMin) { // if stickToMin is true, the new min value is set above\n                    newMin = Math.max(newMax - range, navigatorSeries.xData[0]);\n                }\n            }\n\n            // update the extremes\n            if (hasSetExtremes && (stickToMin || stickToMax)) {\n                if (!isNaN(newMin)) {\n                    baseXAxis.setExtremes(newMin, newMax, true, false, { trigger: 'updatedData' });\n                }\n\n            // if it is not at any edge, just move the scroller window to reflect the new series data\n            } else {\n                if (doRedraw) {\n                    this.chart.redraw(false);\n                }\n\n                scroller.render(\n                    Math.max(baseMin, baseDataMin),\n                    Math.min(baseMax, baseDataMax)\n                );\n            }\n        },\n\n        /**\n         * Destroys allocated elements.\n         */\n        destroy: function () {\n            var scroller = this;\n\n            // Disconnect events added in addEvents\n            scroller.removeEvents();\n\n            // Destroy properties\n            each([scroller.xAxis, scroller.yAxis, scroller.leftShade, scroller.rightShade, scroller.outline, scroller.scrollbarTrack, scroller.scrollbarRifles, scroller.scrollbarGroup, scroller.scrollbar], function (prop) {\n                if (prop && prop.destroy) {\n                    prop.destroy();\n                }\n            });\n            scroller.xAxis = scroller.yAxis = scroller.leftShade = scroller.rightShade = scroller.outline = scroller.scrollbarTrack = scroller.scrollbarRifles = scroller.scrollbarGroup = scroller.scrollbar = null;\n\n            // Destroy elements in collection\n            each([scroller.scrollbarButtons, scroller.handles, scroller.elementsToDestroy], function (coll) {\n                destroyObjectProperties(coll);\n            });\n        }\n    };\n\n    H.Scroller = Scroller;\n\n\n    /**\n     * For Stock charts, override selection zooming with some special features because\n     * X axis zooming is already allowed by the Navigator and Range selector.\n     */\n    wrap(Axis.prototype, 'zoom', function (proceed, newMin, newMax) {\n        var chart = this.chart,\n            chartOptions = chart.options,\n            zoomType = chartOptions.chart.zoomType,\n            previousZoom,\n            navigator = chartOptions.navigator,\n            rangeSelector = chartOptions.rangeSelector,\n            ret;\n\n        if (this.isXAxis && ((navigator && navigator.enabled) ||\n                (rangeSelector && rangeSelector.enabled))) {\n\n            // For x only zooming, fool the chart.zoom method not to create the zoom button\n            // because the property already exists\n            if (zoomType === 'x') {\n                chart.resetZoomButton = 'blocked';\n\n            // For y only zooming, ignore the X axis completely\n            } else if (zoomType === 'y') {\n                ret = false;\n\n            // For xy zooming, record the state of the zoom before zoom selection, then when\n            // the reset button is pressed, revert to this state\n            } else if (zoomType === 'xy') {\n                previousZoom = this.previousZoom;\n                if (defined(newMin)) {\n                    this.previousZoom = [this.min, this.max];\n                } else if (previousZoom) {\n                    newMin = previousZoom[0];\n                    newMax = previousZoom[1];\n                    delete this.previousZoom;\n                }\n            }\n\n        }\n        return ret !== undefined ? ret : proceed.call(this, newMin, newMax);\n    });\n\n    // Initialize scroller for stock charts\n    wrap(Chart.prototype, 'init', function (proceed, options, callback) {\n\n        addEvent(this, 'beforeRender', function () {\n            var options = this.options;\n            if (options.navigator.enabled || options.scrollbar.enabled) {\n                this.scroller = new Scroller(this);\n            }\n        });\n\n        proceed.call(this, options, callback);\n\n    });\n\n    // Pick up badly formatted point options to addPoint\n    wrap(Series.prototype, 'addPoint', function (proceed, options, redraw, shift, animation) {\n        var turboThreshold = this.options.turboThreshold;\n        if (turboThreshold && this.xData.length > turboThreshold && isObject(options) && !isArray(options) && this.chart.scroller) {\n            error(20, true);\n        }\n        proceed.call(this, options, redraw, shift, animation);\n    });\n\n    /* ****************************************************************************\n     * End Scroller code                                                          *\n     *****************************************************************************/\n\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            Axis = H.Axis,\n            Chart = H.Chart,\n            css = H.css,\n            createElement = H.createElement,\n            dateFormat = H.dateFormat,\n            defaultOptions = H.defaultOptions,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            discardElement = H.discardElement,\n            each = H.each,\n            extend = H.extend,\n            HCDate = H.Date,\n            merge = H.merge,\n            pick = H.pick,\n            pInt = H.pInt,\n            removeEvent = H.removeEvent,\n            wrap = H.wrap;\n        \n    /* ****************************************************************************\n     * Start Range Selector code                                                  *\n     *****************************************************************************/\n    extend(defaultOptions, {\n        rangeSelector: {\n            // allButtonsEnabled: false,\n            // enabled: true,\n            // buttons: {Object}\n            // buttonSpacing: 0,\n            buttonTheme: {\n                width: 28,\n                height: 18,\n                fill: '#f7f7f7',\n                padding: 2,\n                r: 0,\n                'stroke-width': 0,\n                style: {\n                    color: '#444',\n                    cursor: 'pointer',\n                    fontWeight: 'normal'\n                },\n                zIndex: 7, // #484, #852\n                states: {\n                    hover: {\n                        fill: '#e7e7e7'\n                    },\n                    select: {\n                        fill: '#e7f0f9',\n                        style: {\n                            color: 'black',\n                            fontWeight: 'bold'\n                        }\n                    }\n                }\n            },\n            height: 35, // reserved space for buttons and input\n            inputPosition: {\n                align: 'right'\n            },\n            // inputDateFormat: '%b %e, %Y',\n            // inputEditDateFormat: '%Y-%m-%d',\n            // inputEnabled: true,\n            // inputStyle: {},\n            labelStyle: {\n                color: '#666'\n            }\n            // selected: undefined\n        }\n    });\n    defaultOptions.lang = merge(defaultOptions.lang, {\n        rangeSelectorZoom: 'Zoom',\n        rangeSelectorFrom: 'From',\n        rangeSelectorTo: 'To'\n    });\n\n    /**\n     * The object constructor for the range selector\n     * @param {Object} chart\n     */\n    function RangeSelector(chart) {\n\n        // Run RangeSelector\n        this.init(chart);\n    }\n\n    RangeSelector.prototype = {\n        /**\n         * The method to run when one of the buttons in the range selectors is clicked\n         * @param {Number} i The index of the button\n         * @param {Object} rangeOptions\n         * @param {Boolean} redraw\n         */\n        clickButton: function (i, redraw) {\n            var rangeSelector = this,\n                selected = rangeSelector.selected,\n                chart = rangeSelector.chart,\n                buttons = rangeSelector.buttons,\n                rangeOptions = rangeSelector.buttonOptions[i],\n                baseAxis = chart.xAxis[0],\n                unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {},\n                dataMin = unionExtremes.dataMin,\n                dataMax = unionExtremes.dataMax,\n                newMin,\n                newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568\n                now,\n                type = rangeOptions.type,\n                baseXAxisOptions,\n                range = rangeOptions._range,\n                rangeMin,\n                year,\n                minSetting,\n                rangeSetting,\n                ctx,\n                dataGrouping = rangeOptions.dataGrouping;\n\n            if (dataMin === null || dataMax === null || // chart has no data, base series is removed\n                    i === rangeSelector.selected) { // same button is clicked twice\n                return;\n            }\n\n            // Set the fixed range before range is altered\n            chart.fixedRange = range;\n\n            // Apply dataGrouping associated to button\n            if (dataGrouping) {\n                this.forcedDataGrouping = true;\n                Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);\n            }\n\n            // Apply range\n            if (type === 'month' || type === 'year') {\n                if (!baseAxis) {\n                    // This is set to the user options and picked up later when the axis is instantiated\n                    // so that we know the min and max.\n                    range = rangeOptions;\n                } else {\n                    ctx = {\n                        range: rangeOptions,\n                        max: newMax,\n                        dataMin: dataMin,\n                        dataMax: dataMax\n                    };\n                    newMin = baseAxis.minFromRange.call(ctx);\n                    if (typeof ctx.newMax === 'number') {\n                        newMax = ctx.newMax;\n                    }\n                }\n\n            // Fixed times like minutes, hours, days\n            } else if (range) {\n                newMin = Math.max(newMax - range, dataMin);\n                newMax = Math.min(newMin + range, dataMax);\n        \n            } else if (type === 'ytd') {\n\n                // On user clicks on the buttons, or a delayed action running from the beforeRender\n                // event (below), the baseAxis is defined.\n                if (baseAxis) {\n\n                    // When ___doublequote___ytd___doublequote___ is the pre-selected button for the initial view, its calculation\n                    // is delayed and rerun in the beforeRender event (below). When the series\n                    // are initialized, but before the chart is rendered, we have access to the xData\n                    // array (#942).\n                    if (dataMax === undefined) {\n                        dataMin = Number.MAX_VALUE;\n                        dataMax = Number.MIN_VALUE;\n                        each(chart.series, function (series) {\n                            var xData = series.xData; // reassign it to the last item\n                            dataMin = Math.min(xData[0], dataMin);\n                            dataMax = Math.max(xData[xData.length - 1], dataMax);\n                        });\n                        redraw = false;\n                    }\n                    now = new HCDate(dataMax);\n                    year = now[HCDate.hcGetFullYear]();\n                    newMin = rangeMin = Math.max(dataMin || 0, HCDate.UTC(year, 0, 1));\n                    now = now.getTime();\n                    newMax = Math.min(dataMax || now, now);\n\n                // ___doublequote___ytd___doublequote___ is pre-selected. We don't yet have access to processed point and extremes data\n                // (things like pointStart and pointInterval are missing), so we delay the process (#942)\n                } else {\n                    addEvent(chart, 'beforeRender', function () {\n                        rangeSelector.clickButton(i);\n                    });\n                    return;\n                }\n            } else if (type === 'all' && baseAxis) {\n                newMin = dataMin;\n                newMax = dataMax;\n            }\n\n            // Deselect previous button\n            if (buttons[selected]) {\n                buttons[selected].setState(0);\n            }\n            // Select this button\n            if (buttons[i]) {\n                buttons[i].setState(2);\n                rangeSelector.lastSelected = i;\n            }\n\n            // Update the chart\n            if (!baseAxis) {\n                // Axis not yet instanciated. Temporarily set min and range\n                // options and remove them on chart load (#4317).\n                baseXAxisOptions = chart.options.xAxis[0];\n                rangeSetting = baseXAxisOptions.range;\n                baseXAxisOptions.range = range;\n                minSetting = baseXAxisOptions.min;\n                baseXAxisOptions.min = rangeMin;\n                rangeSelector.setSelected(i);\n                addEvent(chart, 'load', function resetMinAndRange() {\n                    baseXAxisOptions.range = rangeSetting;\n                    baseXAxisOptions.min = minSetting;\n                });\n            } else {\n                // Existing axis object. Set extremes after render time.\n                baseAxis.setExtremes(\n                    newMin,\n                    newMax,\n                    pick(redraw, 1),\n                    0,\n                    {\n                        trigger: 'rangeSelectorButton',\n                        rangeSelectorButton: rangeOptions\n                    }\n                );\n                rangeSelector.setSelected(i);\n            }\n        },\n\n        /**\n         * Set the selected option. This method only sets the internal flag, it doesn't\n         * update the buttons or the actual zoomed range.\n         */\n        setSelected: function (selected) {\n            this.selected = this.options.selected = selected;\n        },\n\n        /**\n         * The default buttons for pre-selecting time frames\n         */\n        defaultButtons: [{\n            type: 'month',\n            count: 1,\n            text: '1m'\n        }, {\n            type: 'month',\n            count: 3,\n            text: '3m'\n        }, {\n            type: 'month',\n            count: 6,\n            text: '6m'\n        }, {\n            type: 'ytd',\n            text: 'YTD'\n        }, {\n            type: 'year',\n            count: 1,\n            text: '1y'\n        }, {\n            type: 'all',\n            text: 'All'\n        }],\n\n        /**\n         * Initialize the range selector\n         */\n        init: function (chart) {\n\n            var rangeSelector = this,\n                options = chart.options.rangeSelector,\n                fireEvent = fireEvent,\n                buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),\n                selectedOption = options.selected,\n                blurInputs = rangeSelector.blurInputs = function () {\n                    var minInput = rangeSelector.minInput,\n                        maxInput = rangeSelector.maxInput;\n                    if (minInput && minInput.blur) { //#3274 in some case blur is not defined\n                        fireEvent(minInput, 'blur'); //#3274\n                    }\n                    if (maxInput && maxInput.blur) { //#3274 in some case blur is not defined\n                        fireEvent(maxInput, 'blur'); //#3274\n                    }\n                };\n\n            rangeSelector.chart = chart;\n            rangeSelector.options = options;\n            rangeSelector.buttons = [];\n\n            chart.extraTopMargin = options.height;\n            rangeSelector.buttonOptions = buttonOptions;\n\n            addEvent(chart.container, 'mousedown', blurInputs);\n            addEvent(chart, 'resize', blurInputs);\n\n            // Extend the buttonOptions with actual range\n            each(buttonOptions, rangeSelector.computeButtonRange);\n\n            // zoomed range based on a pre-selected button index\n            if (selectedOption !== undefined && buttonOptions[selectedOption]) {\n                this.clickButton(selectedOption, false);\n            }\n\n\n            addEvent(chart, 'load', function () {\n                // If a data grouping is applied to the current button, release it when extremes change\n                addEvent(chart.xAxis[0], 'setExtremes', function (e) {\n                    if (this.max - this.min !== chart.fixedRange && e.trigger !== 'rangeSelectorButton' &&\n                            e.trigger !== 'updatedData' && rangeSelector.forcedDataGrouping) {\n                        this.setDataGrouping(false, false);\n                    }\n                });\n                // Normalize the pressed button whenever a new range is selected\n                addEvent(chart.xAxis[0], 'afterSetExtremes', function () {\n                    rangeSelector.updateButtonStates(true);\n                });\n            });\n        },\n\n        /**\n         * Dynamically update the range selector buttons after a new range has been set\n         */\n        updateButtonStates: function (updating) {\n            var rangeSelector = this,\n                chart = this.chart,\n                baseAxis = chart.xAxis[0],\n                unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis,\n                dataMin = unionExtremes.dataMin,\n                dataMax = unionExtremes.dataMax,\n                selected = rangeSelector.selected,\n                allButtonsEnabled = rangeSelector.options.allButtonsEnabled,\n                buttons = rangeSelector.buttons;\n\n            if (updating && chart.fixedRange !== Math.round(baseAxis.max - baseAxis.min)) {\n                if (buttons[selected]) {\n                    buttons[selected].setState(0);\n                }\n                rangeSelector.setSelected(null);\n            }\n\n            each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n                var actualRange = Math.round(baseAxis.max - baseAxis.min),\n                    range = rangeOptions._range,\n                    type = rangeOptions.type,\n                    count = rangeOptions.count || 1,\n                    // Disable buttons where the range exceeds what is allowed in the current view\n                    isTooGreatRange = range > dataMax - dataMin,\n                    // Disable buttons where the range is smaller than the minimum range\n                    isTooSmallRange = range < baseAxis.minRange,\n                    // Disable the All button if we're already showing all\n                    isAllButAlreadyShowingAll = rangeOptions.type === 'all' && baseAxis.max - baseAxis.min >= dataMax - dataMin &&\n                        buttons[i].state !== 2,\n                    // Disable the YTD button if the complete range is within the same year\n                    isYTDButNotAvailable = rangeOptions.type === 'ytd' && dateFormat('%Y', dataMin) === dateFormat('%Y', dataMax),\n                    // Set a button on export\n                    isSelectedForExport = chart.renderer.forExport && i === selected,\n\n                    isSameRange = range === actualRange,\n\n                    hasNoData = !baseAxis.hasVisibleSeries;\n\n                // Months and years have a variable range so we check the extremes\n                if ((type === 'month' || type === 'year') && (actualRange >= { month: 28, year: 365 }[type] * 24 * 36e5 * count) &&\n                        (actualRange <= { month: 31, year: 366 }[type] * 24 * 36e5 * count)) {\n                    isSameRange = true;\n                }\n                // The new zoom area happens to match the range for a button - mark it selected.\n                // This happens when scrolling across an ordinal gap. It can be seen in the intraday\n                // demos when selecting 1h and scroll across the night gap.\n                if (isSelectedForExport || (isSameRange && i !== selected) && i === rangeSelector.lastSelected) {\n                    rangeSelector.setSelected(i);\n                    buttons[i].setState(2);\n\n                } else if (!allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || isYTDButNotAvailable || hasNoData)) {\n                    buttons[i].setState(3);\n\n                } else if (buttons[i].state === 3) {\n                    buttons[i].setState(0);\n                }\n            });\n        },\n\n        /**\n         * Compute and cache the range for an individual button\n         */\n        computeButtonRange: function (rangeOptions) {\n            var type = rangeOptions.type,\n                count = rangeOptions.count || 1,\n\n                // these time intervals have a fixed number of milliseconds, as opposed\n                // to month, ytd and year\n                fixedTimes = {\n                    millisecond: 1,\n                    second: 1000,\n                    minute: 60 * 1000,\n                    hour: 3600 * 1000,\n                    day: 24 * 3600 * 1000,\n                    week: 7 * 24 * 3600 * 1000\n                };\n\n            // Store the range on the button object\n            if (fixedTimes[type]) {\n                rangeOptions._range = fixedTimes[type] * count;\n            } else if (type === 'month' || type === 'year') {\n                rangeOptions._range = { month: 30, year: 365 }[type] * 24 * 36e5 * count;\n            }\n        },\n\n        /**\n         * Set the internal and displayed value of a HTML input for the dates\n         * @param {String} name\n         * @param {Number} time\n         */\n        setInputValue: function (name, time) {\n            var options = this.chart.options.rangeSelector;\n\n            if (defined(time)) {\n                this[name + 'Input'].HCTime = time;\n            }\n\n            this[name + 'Input'].value = dateFormat(\n                options.inputEditDateFormat || '%Y-%m-%d',\n                this[name + 'Input'].HCTime\n            );\n            this[name + 'DateBox'].attr({\n                text: dateFormat(options.inputDateFormat || '%b %e, %Y', this[name + 'Input'].HCTime)\n            });\n        },\n\n        showInput: function (name) {\n            var inputGroup = this.inputGroup,\n                dateBox = this[name + 'DateBox'];\n\n            css(this[name + 'Input'], {\n                left: (inputGroup.translateX + dateBox.x) + 'px',\n                top: inputGroup.translateY + 'px',\n                width: (dateBox.width - 2) + 'px',\n                height: (dateBox.height - 2) + 'px',\n                border: '2px solid silver'\n            });\n        },\n\n        hideInput: function (name) {\n            css(this[name + 'Input'], {\n                border: 0,\n                width: '1px',\n                height: '1px'\n            });\n            this.setInputValue(name);\n        },\n\n        /**\n         * Draw either the 'from' or the 'to' HTML input box of the range selector\n         * @param {Object} name\n         */\n        drawInput: function (name) {\n            var rangeSelector = this,\n                chart = rangeSelector.chart,\n                chartStyle = chart.renderer.style || {},\n                renderer = chart.renderer,\n                options = chart.options.rangeSelector,\n                lang = defaultOptions.lang,\n                div = rangeSelector.div,\n                isMin = name === 'min',\n                input,\n                label,\n                dateBox,\n                inputGroup = this.inputGroup;\n\n            // Create the text label\n            this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset)\n                .attr({\n                    padding: 2\n                })\n                .css(merge(chartStyle, options.labelStyle))\n                .add(inputGroup);\n            inputGroup.offset += label.width + 5;\n\n            // Create an SVG label that shows updated date ranges and and records click events that\n            // bring in the HTML input.\n            this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)\n                .attr({\n                    padding: 2,\n                    width: options.inputBoxWidth || 90,\n                    height: options.inputBoxHeight || 17,\n                    stroke: options.inputBoxBorderColor || 'silver',\n                    'stroke-width': 1\n                })\n                .css(merge({\n                    textAlign: 'center',\n                    color: '#444'\n                }, chartStyle, options.inputStyle))\n                .on('click', function () {\n                    rangeSelector.showInput(name); // If it is already focused, the onfocus event doesn't fire (#3713)\n                    rangeSelector[name + 'Input'].focus();\n                })\n                .add(inputGroup);\n            inputGroup.offset += dateBox.width + (isMin ? 10 : 0);\n\n\n            // Create the HTML input element. This is rendered as 1x1 pixel then set to the right size\n            // when focused.\n            this[name + 'Input'] = input = createElement('input', {\n                name: name,\n                className: 'highcharts-range-selector',\n                type: 'text'\n            }, extend({\n                position: 'absolute',\n                border: 0,\n                width: '1px', // Chrome needs a pixel to see it\n                height: '1px',\n                padding: 0,\n                textAlign: 'center',\n                fontSize: chartStyle.fontSize,\n                fontFamily: chartStyle.fontFamily,\n                left: '-9em', // #4798\n                top: chart.plotTop + 'px' // prevent jump on focus in Firefox\n            }, options.inputStyle), div);\n\n            // Blow up the input box\n            input.onfocus = function () {\n                rangeSelector.showInput(name);\n            };\n            // Hide away the input box\n            input.onblur = function () {\n                rangeSelector.hideInput(name);\n            };\n\n            // handle changes in the input boxes\n            input.onchange = function () {\n                var inputValue = input.value,\n                    value = (options.inputDateParser || Date.parse)(inputValue),\n                    xAxis = chart.xAxis[0],\n                    dataMin = xAxis.dataMin,\n                    dataMax = xAxis.dataMax;\n\n                // If the value isn't parsed directly to a value by the browser's Date.parse method,\n                // like YYYY-MM-DD in IE, try parsing it a different way\n                if (isNaN(value)) {\n                    value = inputValue.split('-');\n                    value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));\n                }\n\n                if (!isNaN(value)) {\n\n                    // Correct for timezone offset (#433)\n                    if (!defaultOptions.global.useUTC) {\n                        value = value + new Date().getTimezoneOffset() * 60 * 1000;\n                    }\n\n                    // Validate the extremes. If it goes beyound the data min or max, use the\n                    // actual data extreme (#2438).\n                    if (isMin) {\n                        if (value > rangeSelector.maxInput.HCTime) {\n                            value = undefined;\n                        } else if (value < dataMin) {\n                            value = dataMin;\n                        }\n                    } else {\n                        if (value < rangeSelector.minInput.HCTime) {\n                            value = undefined;\n                        } else if (value > dataMax) {\n                            value = dataMax;\n                        }\n                    }\n\n                    // Set the extremes\n                    if (value !== undefined) {\n                        chart.xAxis[0].setExtremes(\n                            isMin ? value : xAxis.min,\n                            isMin ? xAxis.max : value,\n                            undefined,\n                            undefined,\n                            { trigger: 'rangeSelectorInput' }\n                        );\n                    }\n                }\n            };\n        },\n\n        /**\n         * Get the position of the range selector buttons and inputs. This can be overridden from outside for custom positioning.\n         */\n        getPosition: function () {\n            var chart = this.chart,\n                options = chart.options.rangeSelector,\n                buttonTop = pick((options.buttonPosition || {}).y, chart.plotTop - chart.axisOffset[0] - options.height);\n\n            return {\n                buttonTop: buttonTop,\n                inputTop: buttonTop - 10\n            };\n        },\n\n        /**\n         * Render the range selector including the buttons and the inputs. The first time render\n         * is called, the elements are created and positioned. On subsequent calls, they are\n         * moved and updated.\n         * @param {Number} min X axis minimum\n         * @param {Number} max X axis maximum\n         */\n        render: function (min, max) {\n\n            var rangeSelector = this,\n                chart = rangeSelector.chart,\n                renderer = chart.renderer,\n                container = chart.container,\n                chartOptions = chart.options,\n                navButtonOptions = chartOptions.exporting && chartOptions.navigation && chartOptions.navigation.buttonOptions,\n                options = chartOptions.rangeSelector,\n                buttons = rangeSelector.buttons,\n                lang = defaultOptions.lang,\n                div = rangeSelector.div,\n                inputGroup = rangeSelector.inputGroup,\n                buttonTheme = options.buttonTheme,\n                buttonPosition = options.buttonPosition || {},\n                inputEnabled = options.inputEnabled,\n                states = buttonTheme && buttonTheme.states,\n                plotLeft = chart.plotLeft,\n                buttonLeft,\n                pos = this.getPosition(),\n                buttonGroup = rangeSelector.group,\n                buttonBBox,\n                rendered = rangeSelector.rendered;\n\n\n            // create the elements\n            if (!rendered) {\n\n                rangeSelector.group = buttonGroup = renderer.g('range-selector-buttons').add();\n\n                rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(buttonPosition.x, plotLeft), 15)\n                    .css(options.labelStyle)\n                    .add(buttonGroup);\n\n                // button starting position\n                buttonLeft = pick(buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;\n\n                each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n                    buttons[i] = renderer.button(\n                            rangeOptions.text,\n                            buttonLeft,\n                            0,\n                            function () {\n                                rangeSelector.clickButton(i);\n                                rangeSelector.isActive = true;\n                            },\n                            buttonTheme,\n                            states && states.hover,\n                            states && states.select,\n                            states && states.disabled\n                        )\n                        .css({\n                            textAlign: 'center'\n                        })\n                        .add(buttonGroup);\n\n                    // increase button position for the next button\n                    buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);\n\n                    if (rangeSelector.selected === i) {\n                        buttons[i].setState(2);\n                    }\n                });\n\n                rangeSelector.updateButtonStates();\n\n                // first create a wrapper outside the container in order to make\n                // the inputs work and make export correct\n                if (inputEnabled !== false) {\n                    rangeSelector.div = div = createElement('div', null, {\n                        position: 'relative',\n                        height: 0,\n                        zIndex: 1 // above container\n                    });\n\n                    container.parentNode.insertBefore(div, container);\n\n                    // Create the group to keep the inputs\n                    rangeSelector.inputGroup = inputGroup = renderer.g('input-group')\n                        .add();\n                    inputGroup.offset = 0;\n\n                    rangeSelector.drawInput('min');\n                    rangeSelector.drawInput('max');\n                }\n            }\n\n            // Set or update the group position\n            buttonGroup[rendered ? 'animate' : 'attr']({\n                translateY: pos.buttonTop\n            });\n\n            if (inputEnabled !== false) {\n\n                // Update the alignment to the updated spacing box\n                inputGroup.align(extend({\n                    y: pos.inputTop,\n                    width: inputGroup.offset,\n                    // Detect collision with the exporting buttons\n                    x: navButtonOptions && (pos.inputTop < (navButtonOptions.y || 0) + navButtonOptions.height - chart.spacing[0]) ?\n                        -40 : 0\n                }, options.inputPosition), true, chart.spacingBox);\n\n                // Hide if overlapping - inputEnabled is null or undefined\n                if (!defined(inputEnabled)) {\n                    buttonBBox = buttonGroup.getBBox();\n                    inputGroup[inputGroup.translateX < buttonBBox.x + buttonBBox.width + 10 ? 'hide' : 'show']();\n                }\n\n                // Set or reset the input values\n                rangeSelector.setInputValue('min', min);\n                rangeSelector.setInputValue('max', max);\n            }\n\n            rangeSelector.rendered = true;\n        },\n\n        /**\n         * Destroys allocated elements.\n         */\n        destroy: function () {\n            var minInput = this.minInput,\n                maxInput = this.maxInput,\n                chart = this.chart,\n                blurInputs = this.blurInputs,\n                key;\n\n            removeEvent(chart.container, 'mousedown', blurInputs);\n            removeEvent(chart, 'resize', blurInputs);\n\n            // Destroy elements in collections\n            destroyObjectProperties(this.buttons);\n\n            // Clear input element events\n            if (minInput) {\n                minInput.onfocus = minInput.onblur = minInput.onchange = null;\n            }\n            if (maxInput) {\n                maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;\n            }\n\n            // Destroy HTML and SVG elements\n            for (key in this) {\n                if (this[key] && key !== 'chart') {\n                    if (this[key].destroy) { // SVGElement\n                        this[key].destroy();\n                    } else if (this[key].nodeType) { // HTML element\n                        discardElement(this[key]);\n                    }\n                }\n                this[key] = null;\n            }\n        }\n    };\n\n    /**\n     * Add logic to normalize the zoomed range in order to preserve the pressed state of range selector buttons\n     */\n    Axis.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {\n        var fixedRange = this.chart && this.chart.fixedRange,\n            newMin = pick(fixedMin, this.translate(pxMin, true)),\n            newMax = pick(fixedMax, this.translate(pxMax, true)),\n            changeRatio = fixedRange && (newMax - newMin) / fixedRange;\n\n        // If the difference between the fixed range and the actual requested range is\n        // too great, the user is dragging across an ordinal gap, and we need to release\n        // the range selector button.\n        if (changeRatio > 0.7 && changeRatio < 1.3) {\n            if (fixedMax) {\n                newMin = newMax - fixedRange;\n            } else {\n                newMax = newMin + fixedRange;\n            }\n        }\n        if (isNaN(newMin)) { // #1195\n            newMin = newMax = undefined;\n        }\n\n        return {\n            min: newMin,\n            max: newMax\n        };\n    };\n\n    Axis.prototype.minFromRange = function () {\n        var rangeOptions = this.range,\n            type = rangeOptions.type,\n            timeName = { month: 'Month', year: 'FullYear' }[type],\n            min,\n            max = this.max,\n            dataMin,\n            range,\n            // Get the true range from a start date\n            getTrueRange = function (base, count) {\n                var date = new Date(base);\n                date['set' + timeName](date['get' + timeName]() + count);\n                return date.getTime() - base;\n            };\n\n        if (typeof rangeOptions === 'number') {\n            min = this.max - rangeOptions;\n            range = rangeOptions;\n        } else {\n            min = max + getTrueRange(max, -rangeOptions.count);\n        }\n\n        dataMin = pick(this.dataMin, Number.MIN_VALUE);\n        if (isNaN(min)) {\n            min = dataMin;\n        }\n        if (min <= dataMin) {\n            min = dataMin;\n            if (range === undefined) { // #4501\n                range = getTrueRange(min, rangeOptions.count);\n            }\n            this.newMax = Math.min(min + range, this.dataMax);\n        }\n        if (isNaN(max)) {\n            min = undefined;\n        }\n        return min;\n\n    };\n\n    // Initialize scroller for stock charts\n    wrap(Chart.prototype, 'init', function (proceed, options, callback) {\n\n        addEvent(this, 'init', function () {\n            if (this.options.rangeSelector.enabled) {\n                this.rangeSelector = new RangeSelector(this);\n            }\n        });\n\n        proceed.call(this, options, callback);\n\n    });\n\n\n    H.RangeSelector = RangeSelector;\n\n    /* ****************************************************************************\n     * End Range Selector code                                                    *\n     *****************************************************************************/\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            removeEvent = H.removeEvent,\n            wrap = H.wrap;\n\n    Chart.prototype.callbacks.push(function (chart) {\n        var extremes,\n            scroller = chart.scroller,\n            rangeSelector = chart.rangeSelector;\n\n        function renderScroller() {\n            extremes = chart.xAxis[0].getExtremes();\n            scroller.render(extremes.min, extremes.max);\n        }\n\n        function renderRangeSelector() {\n            extremes = chart.xAxis[0].getExtremes();\n            if (!isNaN(extremes.min)) {\n                rangeSelector.render(extremes.min, extremes.max);\n            }\n        }\n\n        function afterSetExtremesHandlerScroller(e) {\n            if (e.triggerOp !== 'navigator-drag') {\n                scroller.render(e.min, e.max);\n            }\n        }\n\n        function afterSetExtremesHandlerRangeSelector(e) {\n            rangeSelector.render(e.min, e.max);\n        }\n\n        function destroyEvents() {\n            if (scroller) {\n                removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);\n            }\n            if (rangeSelector) {\n                removeEvent(chart, 'resize', renderRangeSelector);\n                removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);\n            }\n        }\n\n        // initiate the scroller\n        if (scroller) {\n            // redraw the scroller on setExtremes\n            addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);\n\n            // redraw the scroller on chart resize or box resize\n            wrap(chart, 'drawChartBox', function (proceed) {\n                var isDirtyBox = this.isDirtyBox;\n                proceed.call(this);\n                if (isDirtyBox) {\n                    renderScroller();\n                }\n            });\n\n            // do it now\n            renderScroller();\n        }\n        if (rangeSelector) {\n            // redraw the scroller on setExtremes\n            addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);\n\n            // redraw the scroller chart resize\n            addEvent(chart, 'resize', renderRangeSelector);\n\n            // do it now\n            renderRangeSelector();\n        }\n\n        // Remove resize/afterSetExtremes at chart destroy\n        addEvent(chart, 'destroy', destroyEvents);\n    });\n\n        return H;\n    }(Highcharts));\n    (function (H) {\n        var arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            Axis = H.Axis,\n            Chart = H.Chart,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            inArray = H.inArray,\n            isString = H.isString,\n            map = H.map,\n            merge = H.merge,\n            pick = H.pick,\n            Point = H.Point,\n            Pointer = H.Pointer,\n            Renderer = H.Renderer,\n            Series = H.Series,\n            splat = H.splat,\n            stop = H.stop,\n            SVGRenderer = H.SVGRenderer,\n            VMLRenderer = H.VMLRenderer,\n            wrap = H.wrap,\n\n\n            seriesProto = Series.prototype,\n            seriesInit = seriesProto.init, \n            seriesProcessData = seriesProto.processData,\n            pointTooltipFormatter = Point.prototype.tooltipFormatter;\n    /**\n     * A wrapper for Chart with all the default values for a Stock chart\n     */\n    H.StockChart = H.stockChart = function (a, b, c) {\n        var hasRenderToArg = isString(a) || a.nodeName,\n            options = arguments[hasRenderToArg ? 1 : 0],\n            seriesOptions = options.series, // to increase performance, don't merge the data\n            opposite,\n\n            // Always disable startOnTick:true on the main axis when the navigator is enabled (#1090)\n            navigatorEnabled = pick(options.navigator && options.navigator.enabled, true),\n            disableStartOnTick = navigatorEnabled ? {\n                startOnTick: false,\n                endOnTick: false\n            } : null,\n\n            lineOptions = {\n\n                marker: {\n                    enabled: false,\n                    radius: 2\n                }\n                // gapSize: 0\n            },\n            columnOptions = {\n                shadow: false,\n                borderWidth: 0\n            };\n\n        // apply X axis options to both single and multi y axes\n        options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {\n            return merge(\n                { // defaults\n                    minPadding: 0,\n                    maxPadding: 0,\n                    ordinal: true,\n                    title: {\n                        text: null\n                    },\n                    labels: {\n                        overflow: 'justify'\n                    },\n                    showLastLabel: true\n                }, xAxisOptions, // user options\n                { // forced options\n                    type: 'datetime',\n                    categories: null\n                },\n                disableStartOnTick\n            );\n        });\n\n        // apply Y axis options to both single and multi y axes\n        options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {\n            opposite = pick(yAxisOptions.opposite, true);\n            return merge({ // defaults\n                labels: {\n                    y: -2\n                },\n                opposite: opposite,\n                showLastLabel: false,\n                title: {\n                    text: null\n                }\n            }, yAxisOptions // user options\n            );\n        });\n\n        options.series = null;\n\n        options = merge(\n            {\n                chart: {\n                    panning: true,\n                    pinchType: 'x'\n                },\n                navigator: {\n                    enabled: true\n                },\n                scrollbar: {\n                    enabled: true\n                },\n                rangeSelector: {\n                    enabled: true\n                },\n                title: {\n                    text: null,\n                    style: {\n                        fontSize: '16px'\n                    }\n                },\n                tooltip: {\n                    shared: true,\n                    crosshairs: true\n                },\n                legend: {\n                    enabled: false\n                },\n\n                plotOptions: {\n                    line: lineOptions,\n                    spline: lineOptions,\n                    area: lineOptions,\n                    areaspline: lineOptions,\n                    arearange: lineOptions,\n                    areasplinerange: lineOptions,\n                    column: columnOptions,\n                    columnrange: columnOptions,\n                    candlestick: columnOptions,\n                    ohlc: columnOptions\n                }\n\n            },\n            options, // user's options\n\n            { // forced options\n                _stock: true, // internal flag\n                chart: {\n                    inverted: false\n                }\n            }\n        );\n\n        options.series = seriesOptions;\n\n        return hasRenderToArg ? \n            new Chart(a, options, c) :\n            new Chart(options, b);\n    };\n\n    // Implement the pinchType option\n    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n\n        var pinchType = options.chart.pinchType || '';\n\n        proceed.call(this, chart, options);\n\n        // Pinch status\n        this.pinchX = this.pinchHor = pinchType.indexOf('x') !== -1;\n        this.pinchY = this.pinchVert = pinchType.indexOf('y') !== -1;\n        this.hasZoom = this.hasZoom || this.pinchHor || this.pinchVert;\n    });\n\n    // Override the automatic label alignment so that the first Y axis' labels\n    // are drawn on top of the grid line, and subsequent axes are drawn outside\n    wrap(Axis.prototype, 'autoLabelAlign', function (proceed) {\n        var chart = this.chart,\n            options = this.options,\n            panes = chart._labelPanes = chart._labelPanes || {},\n            key,\n            labelOptions = this.options.labels;\n        if (this.chart.options._stock && this.coll === 'yAxis') {\n            key = options.top + ',' + options.height;\n            if (!panes[key] && labelOptions.enabled) { // do it only for the first Y axis of each pane\n                if (labelOptions.x === 15) { // default\n                    labelOptions.x = 0;\n                }\n                if (labelOptions.align === undefined) {\n                    labelOptions.align = 'right';\n                }\n                panes[key] = 1;\n                return 'right';\n            }\n        }\n        return proceed.call(this, [].slice.call(arguments, 1));\n    });\n\n    // Override getPlotLinePath to allow for multipane charts\n    wrap(Axis.prototype, 'getPlotLinePath', function (proceed, value, lineWidth, old, force, translatedValue) {\n        var axis = this,\n            series = (this.isLinked && !this.series ? this.linkedParent.series : this.series),\n            chart = axis.chart,\n            renderer = chart.renderer,\n            axisLeft = axis.left,\n            axisTop = axis.top,\n            x1,\n            y1,\n            x2,\n            y2,\n            result = [],\n            axes = [], //#3416 need a default array\n            axes2,\n            uniqueAxes,\n            transVal;\n\n        // Ignore in case of color Axis. #3360, #3524\n        if (axis.coll === 'colorAxis') {\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        }\n\n        // Get the related axes based on series\n        axes = (axis.isXAxis ?\n            (defined(axis.options.yAxis) ?\n                [chart.yAxis[axis.options.yAxis]] :\n                map(series, function (s) {\n                    return s.yAxis;\n                })\n            ) :\n            (defined(axis.options.xAxis) ?\n                [chart.xAxis[axis.options.xAxis]] :\n                map(series, function (s) {\n                    return s.xAxis;\n                })\n            )\n        );\n\n        // Get the related axes based options.*Axis setting #2810\n        axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);\n        each(axes2, function (A) {\n            if (defined(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {\n                var a = (A.isXAxis ? 'yAxis' : 'xAxis'),\n                    rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][0]);\n\n                if (axis === rax) {\n                    axes.push(A);\n                }\n            }\n        });\n\n\n        // Remove duplicates in the axes array. If there are no axes in the axes array,\n        // we are adding an axis without data, so we need to populate this with grid\n        // lines (#2796).\n        uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; //#3742\n        each(axes, function (axis2) {\n            if (inArray(axis2, uniqueAxes) === -1) {\n                uniqueAxes.push(axis2);\n            }\n        });\n\n        transVal = pick(translatedValue, axis.translate(value, null, null, old));\n\n        if (!isNaN(transVal)) {\n            if (axis.horiz) {\n                each(uniqueAxes, function (axis2) {\n                    var skip;\n\n                    y1 = axis2.pos;\n                    y2 = y1 + axis2.len;\n                    x1 = x2 = Math.round(transVal + axis.transB);\n\n                    if (x1 < axisLeft || x1 > axisLeft + axis.width) { // outside plot area\n                        if (force) {\n                            x1 = x2 = Math.min(Math.max(axisLeft, x1), axisLeft + axis.width);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    if (!skip) {\n                        result.push('M', x1, y1, 'L', x2, y2);\n                    }\n                });\n            } else {\n                each(uniqueAxes, function (axis2) {\n                    var skip;\n\n                    x1 = axis2.pos;\n                    x2 = x1 + axis2.len;\n                    y1 = y2 = Math.round(axisTop + axis.height - translatedValue);\n\n                    if (y1 < axisTop || y1 > axisTop + axis.height) { // outside plot area\n                        if (force) {\n                            y1 = y2 = Math.min(Math.max(axisTop, y1), axis.top + axis.height);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    if (!skip) {\n                        result.push('M', x1, y1, 'L', x2, y2);\n                    }\n                });\n            }\n        }\n        return result.length > 0 ?\n            renderer.crispPolyLine(result, lineWidth || 1) :\n            null; //#3557 getPlotLinePath in regular Highcharts also returns null\n    });\n\n    // Override getPlotBandPath to allow for multipane charts\n    Axis.prototype.getPlotBandPath = function (from, to) {\n        var toPath = this.getPlotLinePath(to, null, null, true),\n            path = this.getPlotLinePath(from, null, null, true),\n            result = [],\n            i;\n\n        if (path && toPath && path.toString() !== toPath.toString()) {\n            // Go over each subpath\n            for (i = 0; i < path.length; i += 6) {\n                result.push('M', path[i + 1], path[i + 2], 'L', path[i + 4], path[i + 5], toPath[i + 4], toPath[i + 5], toPath[i + 1], toPath[i + 2]);\n            }\n        } else { // outside the axis area\n            result = null;\n        }\n\n        return result;\n    };\n\n    // Function to crisp a line with multiple segments\n    SVGRenderer.prototype.crispPolyLine = function (points, width) {\n        // points format: ['M', 0, 0, 'L', 100, 0]    \n        // normalize to a crisp line\n        var i;\n        for (i = 0; i < points.length; i = i + 6) {\n            if (points[i + 1] === points[i + 4]) {\n                // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                points[i + 1] = points[i + 4] = Math.round(points[i + 1]) - (width % 2 / 2);\n            }\n            if (points[i + 2] === points[i + 5]) {\n                points[i + 2] = points[i + 5] = Math.round(points[i + 2]) + (width % 2 / 2);\n            }\n        }\n        return points;\n    };\n    if (Renderer === VMLRenderer) {\n        VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;\n    }\n\n\n    // Wrapper to hide the label\n    wrap(Axis.prototype, 'hideCrosshair', function (proceed, i) {\n    \n        proceed.call(this, i);\n\n        if (this.crossLabel) {\n            this.crossLabel = this.crossLabel.hide();\n        }\n    });\n\n    // Wrapper to draw the label\n    wrap(Axis.prototype, 'drawCrosshair', function (proceed, e, point) {\n    \n        // Draw the crosshair\n        proceed.call(this, e, point);\n\n        // Check if the label has to be drawn\n        if (!defined(this.crosshair.label) || !this.crosshair.label.enabled) {\n            return;\n        }\n\n        var chart = this.chart,\n            options = this.options.crosshair.label,        // the label's options\n            horiz = this.horiz,                            // axis orientation\n            opposite = this.opposite,                    // axis position\n            left = this.left,                            // left position\n            top = this.top,                                // top position\n            crossLabel = this.crossLabel,                // reference to the svgElement\n            posx,\n            posy,\n            crossBox,\n            formatOption = options.format,\n            formatFormat = '',\n            limit,\n            align,\n            tickInside = this.options.tickPosition === 'inside',\n            snap = this.crosshair.snap !== false,\n            value;\n\n        align = (horiz ? 'center' : opposite ? (this.labelAlign === 'right' ? 'right' : 'left') : (this.labelAlign === 'left' ? 'left' : 'center'));\n\n        // If the label does not exist yet, create it.\n        if (!crossLabel) {\n            crossLabel = this.crossLabel = chart.renderer.label(null, null, null, options.shape || 'callout')\n            .attr({\n                align: options.align || align,\n                zIndex: 12,\n                fill: options.backgroundColor || (this.series[0] && this.series[0].color) || 'gray',\n                padding: pick(options.padding, 8),\n                stroke: options.borderColor || '',\n                'stroke-width': options.borderWidth || 0,\n                r: pick(options.borderRadius, 3)\n            })\n            .css(extend({\n                color: 'white',\n                fontWeight: 'normal',\n                fontSize: '11px',\n                textAlign: 'center'\n            }, options.style))\n            .add();\n        }\n\n        if (horiz) {\n            posx = snap ? point.plotX + left : e.chartX;\n            posy = top + (opposite ? 0 : this.height);\n        } else {\n            posx = opposite ? this.width + left : 0;\n            posy = snap ? point.plotY + top : e.chartY;\n        }\n\n        if (!formatOption && !options.formatter) {\n            if (this.isDatetimeAxis) {\n                formatFormat = '%b %d, %Y';\n            }\n            formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';\n        }\n\n        // Show the label\n        value = snap ? point[this.isXAxis ? 'x' : 'y'] : this.toValue(horiz ? e.chartX : e.chartY);\n        crossLabel.attr({\n            text: formatOption ? format(formatOption, { value: value }) : options.formatter.call(this, value),\n            anchorX: horiz ? posx : (this.opposite ? 0 : chart.chartWidth),\n            anchorY: horiz ? (this.opposite ? chart.chartHeight : 0) : posy,\n            x: posx,\n            y: posy,\n            visibility: 'visible'\n        });\n        crossBox = crossLabel.getBBox();\n\n        // now it is placed we can correct its position\n        if (horiz) {\n            if ((tickInside && !opposite) || (!tickInside && opposite)) {\n                posy = crossLabel.y - crossBox.height;\n            }\n        } else {\n            posy = crossLabel.y - (crossBox.height / 2);\n        }\n\n        // check the edges\n        if (horiz) {\n            limit = {\n                left: left - crossBox.x,\n                right: left + this.width - crossBox.x\n            };\n        } else {\n            limit = {\n                left: this.labelAlign === 'left' ? left : 0,\n                right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth\n            };\n        }\n\n        // left edge\n        if (crossLabel.translateX < limit.left) {\n            posx += limit.left - crossLabel.translateX;\n        }\n        // right edge\n        if (crossLabel.translateX + crossBox.width >= limit.right) {\n            posx -= crossLabel.translateX + crossBox.width - limit.right;\n        }\n\n        // show the crosslabel\n        crossLabel.attr({ x: posx, y: posy, visibility: 'visible' });\n    });\n\n    /* ****************************************************************************\n     * Start value compare logic                                                  *\n     *****************************************************************************/\n    \n    /**\n     * Extend series.init by adding a method to modify the y value used for plotting\n     * on the y axis. This method is called both from the axis when finding dataMin\n     * and dataMax, and from the series.translate method.\n     */\n    seriesProto.init = function () {\n\n        // Call base method\n        seriesInit.apply(this, arguments);\n\n        // Set comparison mode\n        this.setCompare(this.options.compare);\n    };\n\n    /**\n     * The setCompare method can be called also from the outside after render time\n     */\n    seriesProto.setCompare = function (compare) {\n\n        // Set or unset the modifyValue method\n        this.modifyValue = (compare === 'value' || compare === 'percent') ? function (value, point) {\n            var compareValue = this.compareValue;\n        \n            if (value !== undefined) { // #2601\n\n                // get the modified value\n                value = compare === 'value' ?\n                    value - compareValue : // compare value\n                    value = 100 * (value / compareValue) - 100; // compare percent\n\n                // record for tooltip etc.\n                if (point) {\n                    point.change = value;\n                }\n\n            }\n\n            return value;\n        } : null;\n\n        // Mark dirty\n        if (this.chart.hasRendered) {\n            this.isDirty = true;\n        }\n\n    };\n\n    /**\n     * Extend series.processData by finding the first y value in the plot area,\n     * used for comparing the following values\n     */\n    seriesProto.processData = function () {\n        var series = this,\n            i,\n            processedXData,\n            processedYData,\n            length;\n\n        // call base method\n        seriesProcessData.apply(this, arguments);\n\n        if (series.xAxis && series.processedYData) { // not pies\n\n            // local variables\n            processedXData = series.processedXData;\n            processedYData = series.processedYData;\n            length = processedYData.length;\n\n            // find the first value for comparison\n            for (i = 0; i < length; i++) {\n                if (typeof processedYData[i] === 'number' && processedXData[i] >= series.xAxis.min && processedYData[i] !== 0) {\n                    series.compareValue = processedYData[i];\n                    break;\n                }\n            }\n        }\n    };\n\n    /**\n     * Modify series extremes\n     */\n    wrap(seriesProto, 'getExtremes', function (proceed) {\n        var extremes;\n\n        proceed.apply(this, [].slice.call(arguments, 1));\n\n        if (this.modifyValue) {\n            extremes = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];\n            this.dataMin = arrayMin(extremes);\n            this.dataMax = arrayMax(extremes);\n        }\n    });\n\n    /**\n     * Add a utility method, setCompare, to the Y axis\n     */\n    Axis.prototype.setCompare = function (compare, redraw) {\n        if (!this.isXAxis) {\n            each(this.series, function (series) {\n                series.setCompare(compare);\n            });\n            if (pick(redraw, true)) {\n                this.chart.redraw();\n            }\n        }\n    };\n\n    /**\n     * Extend the tooltip formatter by adding support for the point.change variable\n     * as well as the changeDecimals option\n     */\n    Point.prototype.tooltipFormatter = function (pointFormat) {\n        var point = this;\n\n        pointFormat = pointFormat.replace(\n            '{point.change}',\n            (point.change > 0 ? '+' : '') + H.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, 2))\n        ); \n    \n        return pointTooltipFormatter.apply(this, [pointFormat]);\n    };\n\n    /* ****************************************************************************\n     * End value compare logic                                                    *\n     *****************************************************************************/\n\n\n    /**\n     * Extend the Series prototype to create a separate series clip box. This is related\n     * to using multiple panes, and a future pane logic should incorporate this feature (#2754).\n     */\n    wrap(Series.prototype, 'render', function (proceed) {\n        // Only do this on stock charts (#2939), and only if the series type handles clipping\n        // in the animate method (#2975).\n        if (this.chart.options._stock && this.xAxis) {\n\n            // First render, initial clip box\n            if (!this.clipBox && this.animate) {\n                this.clipBox = merge(this.chart.clipBox);\n                this.clipBox.width = this.xAxis.len;\n                this.clipBox.height = this.yAxis.len;\n\n            // On redrawing, resizing etc, update the clip rectangle\n            } else if (this.chart[this.sharedClipKey]) {\n                stop(this.chart[this.sharedClipKey]); // #2998\n                this.chart[this.sharedClipKey].attr({\n                    width: this.xAxis.len,\n                    height: this.yAxis.len\n                });\n            }\n        }\n        proceed.call(this);\n    });\n\n        return H;\n    }(Highcharts));\n\n";
return s;